# React Native Video v7 Documentation

> Complete documentation for React Native Video v7

This file contains all documentation content in a single document following the llmstxt.org standard.

## Configuration

# Configuration

Configure video caching behavior and storage limits.

:::tip Pro Feature - Coming Soon
Video caching is a Pro feature currently in development.
:::

## Global Configuration

```tsx
import { VideoCache } from 'react-native-video';

VideoCache.configure({
  // Storage
  maxCacheSize: 500 * 1024 * 1024, // 500 MB
  cacheLocation: 'auto', // 'auto', 'internal', 'external'
  
  // Caching behavior
  defaultCachePercentage: 50,
  enableBackgroundCaching: true,
  cacheOnWifiOnly: true,
  
  // Management
  autoCleanup: true,
  maxCacheAge: 7 * 24 * 60 * 60 * 1000, // 7 days
  cleanupThreshold: 0.9, // Clean when 90% full
  
  // Performance
  maxConcurrentCaches: 2,
  chunkSize: 1 * 1024 * 1024, // 1 MB
});
```

## Storage Settings

### maxCacheSize

Maximum total cache size in bytes.

```tsx
VideoCache.configure({
  maxCacheSize: 1024 * 1024 * 1024, // 1 GB
});
```

**Default**: `500 * 1024 * 1024` (500 MB)

### cacheLocation

Where to store cached videos.

```tsx
VideoCache.configure({
  cacheLocation: 'auto', // Let SDK choose best location
});
```

**Options:**
- `'auto'` - SDK chooses automatically
- `'internal'` - Internal storage (always available)
- `'external'` - External/SD card (if available)

**Default**: `'auto'`

### cacheDirectory

Custom cache directory path.

```tsx
VideoCache.configure({
  cacheDirectory: '/custom/cache/path',
});
```

## Caching Behavior

### defaultCachePercentage

Default percentage to cache when not specified.

```tsx
VideoCache.configure({
  defaultCachePercentage: 30, // Cache first 30%
});
```

**Default**: `50`

### enableBackgroundCaching

Enable background caching when app is idle.

```tsx
VideoCache.configure({
  enableBackgroundCaching: true,
});
```

**Default**: `true`

### cacheOnWifiOnly

Only cache on WiFi connections.

```tsx
VideoCache.configure({
  cacheOnWifiOnly: true,
});
```

**Default**: `true`

### allowCellularCaching

Allow caching on cellular networks.

```tsx
VideoCache.configure({
  allowCellularCaching: false,
});
```

**Default**: `false`

## Management Settings

### autoCleanup

Automatically clean up old cache.

```tsx
VideoCache.configure({
  autoCleanup: true,
  maxCacheAge: 14 * 24 * 60 * 60 * 1000, // 14 days
});
```

**Default**: `true`

### maxCacheAge

Maximum age of cache before cleanup (in milliseconds).

```tsx
VideoCache.configure({
  maxCacheAge: 30 * 24 * 60 * 60 * 1000, // 30 days
});
```

**Default**: `7 * 24 * 60 * 60 * 1000` (7 days)

### cleanupThreshold

Storage usage threshold to trigger cleanup (0-1).

```tsx
VideoCache.configure({
  cleanupThreshold: 0.95, // Clean when 95% full
});
```

**Default**: `0.9` (90%)

### cleanupStrategy

Strategy for removing cached videos.

```tsx
VideoCache.configure({
  cleanupStrategy: 'lru', // 'lru', 'lfu', 'fifo', 'size'
});
```

**Options:**
- `'lru'` - Least Recently Used
- `'lfu'` - Least Frequently Used
- `'fifo'` - First In, First Out
- `'size'` - Largest files first

**Default**: `'lru'`

## Performance Settings

### maxConcurrentCaches

Maximum number of simultaneous cache operations.

```tsx
VideoCache.configure({
  maxConcurrentCaches: 3,
});
```

**Default**: `2`

### chunkSize

Size of chunks for caching (in bytes).

```tsx
VideoCache.configure({
  chunkSize: 2 * 1024 * 1024, // 2 MB
});
```

**Default**: `1 * 1024 * 1024` (1 MB)

### bufferSize

Buffer size for read/write operations.

```tsx
VideoCache.configure({
  bufferSize: 512 * 1024, // 512 KB
});
```

**Default**: `256 * 1024` (256 KB)

## Per-Video Configuration

Override global settings per video:

```tsx
await VideoCache.cache({
  url: 'https://example.com/video.mp4',
  
  // Override defaults
  percentage: 75, // Cache 75% instead of default
  priority: 'high',
  allowCellular: true, // Override WiFi-only
  neverExpire: true, // Don't auto-cleanup this video
});
```

## Priority Levels

Set caching priority:

```tsx
await VideoCache.cache({
  url: 'https://example.com/video.mp4',
  percentage: 50,
  priority: 'high', // 'high', 'medium', 'low'
});
```

**Priority affects:**
- Queue position
- Background caching order
- Cleanup resistance

## Network Policies

### WiFi-Only Caching

```tsx
VideoCache.configure({
  cacheOnWifiOnly: true,
  allowCellularCaching: false,
});
```

### Cellular with Limit

```tsx
VideoCache.configure({
  allowCellularCaching: true,
  cellularCacheLimit: 50 * 1024 * 1024, // 50 MB max
});
```

### Adaptive Caching

```tsx
VideoCache.configure({
  adaptiveStrategy: true, // Adjust based on conditions
  wifiCachePercentage: 75, // Cache more on WiFi
  cellularCachePercentage: 25, // Cache less on cellular
});
```

## Complete Example

```tsx
import { VideoCache } from 'react-native-video';

// Production configuration
VideoCache.configure({
  // Storage - 1 GB max
  maxCacheSize: 1024 * 1024 * 1024,
  cacheLocation: 'auto',
  
  // Behavior - WiFi-only, 50% default
  defaultCachePercentage: 50,
  enableBackgroundCaching: true,
  cacheOnWifiOnly: true,
  
  // Management - Auto-cleanup after 14 days
  autoCleanup: true,
  maxCacheAge: 14 * 24 * 60 * 60 * 1000,
  cleanupThreshold: 0.9,
  cleanupStrategy: 'lru',
  
  // Performance - 2 concurrent, 2MB chunks
  maxConcurrentCaches: 2,
  chunkSize: 2 * 1024 * 1024,
});
```

## Platform-Specific Configuration

### iOS

```tsx
VideoCache.configure({
  ios: {
    useDocumentsDirectory: false, // Use caches directory
    protectFromBackup: true,
    urlCacheSize: 50 * 1024 * 1024, // 50 MB URL cache
  },
});
```

### Android

```tsx
VideoCache.configure({
  android: {
    preferExternal: true, // Prefer external storage
    useMediaStore: false,
    cachePartition: 'cache', // 'cache' or 'data'
  },
});
```

## Reset Configuration

```tsx
VideoCache.resetConfiguration();
```

## Get Current Configuration

```tsx
const config = VideoCache.getConfiguration();
console.log(config);
```

## Best Practices

1. **Storage Limits** - Set based on device/user needs
2. **WiFi-Only** - Enable for cellular data savings
3. **Auto Cleanup** - Keep cache fresh and manageable
4. **Priority System** - Use for important content
5. **Adaptive Strategy** - Better user experience
6. **Platform-Specific** - Optimize per platform

## See Also

- [Getting Started](./getting-started.md) - Video caching basics
- [Strategies](./strategies.md) - Caching strategies
- [Cache Management](./management.md) - Manage cached content
- [Storage](./storage.md) - Storage management

---

## Getting Started

# Getting Started

Pre-cache video content for instant playback and reduced bandwidth usage.

:::tip Pro Feature - Coming Soon
Video caching is a Pro feature currently in development.
:::

## Overview

Video caching provides:

| Feature | Description |
|---------|-------------|
| **Instant Playback** | Zero startup delay from cached content |
| **Seamless Streaming** | Play while caching in background |
| **Partial Caching** | Cache only first X% or X seconds |
| **Offline Playback** | Watch without network connection |
| **Smart Cleanup** | Automatic LRU-based cache management |
| **Bandwidth Savings** | Reduce data usage on repeat views |

## Quick Start

### Automatic Caching

The simplest approach - cache is used automatically:

```tsx
import { useVideoPlayer, VideoView } from 'react-native-video';

function Player({ source }) {
  const player = useVideoPlayer({
    uri: source,
    cache: true, // Enable caching
  });

  return ;
}
```

That's it! The SDK automatically:
- Caches video segments as they stream
- Uses cached data on repeat playback
- Manages storage limits

### Manual Caching

For more control, cache videos before playback:

```tsx
import { useCache } from 'react-native-video';

function VideoItem({ video }) {
  const cache = useCache(video.url);

  useEffect(() => {
    // Cache first 30 seconds to disk
    cache.save({ duration: 30 });
  }, []);

  return (
    
      Cached: {cache.progress}%
      
    
  );
}
```

## useCache Hook

React hook for caching control:

```tsx
const cache = useCache(url: string);
```

### Properties

| Property | Type | Description |
|----------|------|-------------|
| `isCached` | `boolean` | Whether video has cached content |
| `progress` | `number` | Cache progress (0-100) |
| `size` | `number` | Cached size in bytes |
| `status` | `CacheStatus` | `'idle'` \| `'caching'` \| `'cached'` \| `'error'` |

### Methods

| Method | Description |
|--------|-------------|
| `save(options)` | Save video to cache (persistent) |
| `cancel()` | Cancel ongoing caching |
| `clear()` | Remove from cache |

### Example

```tsx
function SmartVideoPlayer({ source }) {
  const cache = useCache(source);
  const player = useVideoPlayer({ uri: source, cache: true });

  // Cache on mount - persists across app restarts
  useEffect(() => {
    if (!cache.isCached) {
      cache.save({ percentage: 50 });
    }
  }, []);

  return (
    
      
      
      {cache.status === 'caching' && (
        
      )}
    
  );
}
```

## Cache Options

```ts
interface CacheOptions {
  percentage?: number;  // Cache first X% (default: 100)
  duration?: number;    // Cache first X seconds
  priority?: 'high' | 'medium' | 'low';
  networkPolicy?: 'any' | 'wifi' | 'unmetered';
}
```

### Cache by Percentage

```tsx
// Cache first 50% - persists on disk
cache.save({ percentage: 50 });
```

### Cache by Duration

```tsx
// Cache first 30 seconds
cache.save({ duration: 30 });
```

### Priority Caching

```tsx
// High priority - cache immediately
cache.save({ priority: 'high' });

// Low priority - cache when idle
cache.save({ priority: 'low' });
```

### Network Policy

```tsx
// Only cache on WiFi
cache.save({ networkPolicy: 'wifi' });

// Only on unmetered connections
cache.save({ networkPolicy: 'unmetered' });
```

## Feed Caching

Cache videos as user scrolls - they persist across app restarts:

```tsx
import { FlatList } from 'react-native';
import { useCache, useVideoPlayer, VideoView, VideoCache } from 'react-native-video';

function VideoFeed({ videos }) {
  return (
     (
        
      )}
      onViewableItemsChanged={({ viewableItems }) => {
        // Cache next 2 videos to disk
        viewableItems.forEach(({ index }) => {
          const nextVideos = videos.slice(index + 1, index + 3);
          nextVideos.forEach(v => VideoCache.save(v.url, { percentage: 30 }));
        });
      }}
    />
  );
}

function VideoItem({ video }) {
  const cache = useCache(video.url);
  const player = useVideoPlayer({ uri: video.url, cache: true });

  return (
    
      
      {cache.isCached && }
    
  );
}
```

## Global Configuration

Configure caching behavior globally:

```tsx
import { VideoCache } from 'react-native-video';

// At app startup
VideoCache.configure({
  // Storage
  maxSize: 500 * 1024 * 1024, // 500 MB
  
  // Behavior
  defaultPercentage: 50,
  networkPolicy: 'wifi',
  
  // Cleanup
  maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days
  cleanupStrategy: 'lru',
});
```

## Cache Status

Check cache status for any URL:

```tsx
const status = await VideoCache.getStatus(url);

console.log(status);
// {
//   isCached: true,
//   percentage: 50,
//   size: 25_000_000, // 25 MB
//   createdAt: Date,
//   lastAccessed: Date,
// }
```

## Complete Example

```tsx
import React, { useEffect, useState } from 'react';
import { View, Text, FlatList, TouchableOpacity } from 'react-native';
import { 
  useVideoPlayer, 
  VideoView, 
  useCache,
  VideoCache 
} from 'react-native-video';

// Configure at app startup
VideoCache.configure({
  maxSize: 500 * 1024 * 1024,
  networkPolicy: 'wifi',
});

function App() {
  const [videos] = useState([
    { id: '1', url: 'https://example.com/video1.mp4', title: 'Video 1' },
    { id: '2', url: 'https://example.com/video2.mp4', title: 'Video 2' },
    { id: '3', url: 'https://example.com/video3.mp4', title: 'Video 3' },
  ]);

  return (
     }
      keyExtractor={(item) => item.id}
    />
  );
}

function CachedVideoPlayer({ video }) {
  const cache = useCache(video.url);
  
  const player = useVideoPlayer({
    uri: video.url,
    cache: true,
  }, (_player) => {
    _player.play();
  });

  // Cache first 30 seconds - persists on disk
  useEffect(() => {
    if (!cache.isCached) {
      cache.save({ duration: 30 });
    }
  }, []);

  return (
    
      
      
      
        {video.title}
        
        {cache.status === 'caching' && (
          Caching: {cache.progress}%
        )}
        
        {cache.isCached && (
          
            ✓ Cached
          
        )}
      
      
       cache.clear()}>
        Clear Cache
      
    
  );
}
```

## Platform Configuration

### iOS

Add background fetch capability for background caching:

```xml

UIBackgroundModes

  fetch

```

### Android

Required permissions:

```xml

```

## Platform Support

| Feature | iOS | Android |
|---------|-----|---------|
| Automatic caching | ✅ | ✅ |
| Partial caching | ✅ | ✅ |
| Background caching | ✅ | ✅ |
| Offline playback | ✅ | ✅ |
| HLS caching | ✅ | ✅ |
| DASH caching | ❌ | ✅ |

## Next Steps

- [Configuration](./configuration.md) - Advanced cache settings
- [Strategies](./strategies.md) - Smart caching strategies
- [Management](./management.md) - Cache cleanup and monitoring
- [Storage](./storage.md) - Storage optimization

---

## Cache Management

# Cache Management

Manage, monitor, and optimize cached video content.

:::tip Pro Feature - Coming Soon
Video caching is a Pro feature currently in development.
:::

## Overview

Cache management features:
- **View Cached Videos** - List all cached content
- **Clear Cache** - Remove cached videos
- **Storage Monitoring** - Track cache usage
- **Automatic Cleanup** - Remove old/unused cache
- **Manual Cleanup** - User-controlled cleanup

## View Cached Videos

Get all cached videos:

```tsx
import { VideoCache } from 'react-native-video';

const cachedVideos = await VideoCache.getAllCached();

cachedVideos.forEach(video => {
  console.log('URL:', video.url);
  console.log('Size:', video.size);
  console.log('Percentage:', video.percentage);
  console.log('Created:', video.createdAt);
  console.log('Last Accessed:', video.lastAccessed);
});
```

## Cache Info

Get detailed info for specific video:

```tsx
const info = await VideoCache.getInfo('https://example.com/video.mp4');

if (info) {
  console.log('Cached:', info.cached);
  console.log('Percentage:', info.percentage);
  console.log('Size:', info.size);
  console.log('Path:', info.localPath);
  console.log('Created:', info.createdAt);
  console.log('Last Accessed:', info.lastAccessed);
  console.log('Access Count:', info.accessCount);
}
```

## Clear Cache

### Clear Specific Video

```tsx
await VideoCache.clear('https://example.com/video.mp4');
```

### Clear Multiple Videos

```tsx
const urls = [
  'https://example.com/video1.mp4',
  'https://example.com/video2.mp4',
  'https://example.com/video3.mp4',
];

await VideoCache.clearMultiple(urls);
```

### Clear All Cache

```tsx
await VideoCache.clearAll();
```

### Clear by Pattern

```tsx
// Clear all videos from specific domain
await VideoCache.clearByPattern('https://cdn.example.com/*');
```

## Storage Monitoring

### Get Storage Info

```tsx
const storage = await VideoCache.getStorageInfo();

console.log('Total Cache Size:', storage.totalSize);
console.log('Used Size:', storage.usedSize);
console.log('Available Size:', storage.availableSize);
console.log('Usage Percentage:', storage.usagePercentage);
console.log('Cached Videos Count:', storage.cachedVideos);
```

### Monitor Storage Changes

```tsx
VideoCache.onStorageChange((storage) => {
  console.log('Cache usage:', storage.usagePercentage);
  
  if (storage.usagePercentage > 0.9) {
    console.warn('Cache almost full!');
  }
});
```

## Automatic Cleanup

### Age-Based Cleanup

Remove videos older than specified age:

```tsx
// Clean cache older than 7 days
await VideoCache.clearOlderThan(7 * 24 * 60 * 60 * 1000);
```

### Usage-Based Cleanup

Remove least used cache:

```tsx
// Remove 10 least recently used videos
await VideoCache.clearLeastUsed(10);
```

### Size-Based Cleanup

Remove cache to reach target size:

```tsx
// Reduce cache to 300 MB
await VideoCache.reduceCacheTo(300 * 1024 * 1024);
```

### Strategy-Based Cleanup

Use cleanup strategies:

```tsx
// LRU - Least Recently Used
await VideoCache.cleanup('lru', { count: 5 });

// LFU - Least Frequently Used
await VideoCache.cleanup('lfu', { count: 5 });

// Size - Largest files first
await VideoCache.cleanup('size', { targetSize: 200 * 1024 * 1024 });
```

## Manual Cleanup UI

Provide user interface for cache management:

```tsx
import React, { useState, useEffect } from 'react';
import { View, Text, Button, FlatList } from 'react-native';
import { VideoCache } from 'react-native-video';

function CacheManagementScreen() {
  const [cachedVideos, setCachedVideos] = useState([]);
  const [storage, setStorage] = useState(null);

  useEffect(() => {
    loadCache();
  }, []);

  const loadCache = async () => {
    const videos = await VideoCache.getAllCached();
    const storageInfo = await VideoCache.getStorageInfo();
    
    setCachedVideos(videos);
    setStorage(storageInfo);
  };

  const clearVideo = async (url) => {
    await VideoCache.clear(url);
    await loadCache();
  };

  const clearAll = async () => {
    await VideoCache.clearAll();
    await loadCache();
  };

  const clearOld = async () => {
    await VideoCache.clearOlderThan(7 * 24 * 60 * 60 * 1000);
    await loadCache();
  };

  return (
    
      {storage && (
        
          Cache Size: {formatBytes(storage.usedSize)}
          Usage: {(storage.usagePercentage * 100).toFixed(1)}%
          Videos: {storage.cachedVideos}
        
      )}

      
        
        
      

       (
          
            
              {item.url}
              Size: {formatBytes(item.size)}
              Cached: {item.percentage}%
              Accessed: {formatDate(item.lastAccessed)}
            
             clearVideo(item.url)} />
          
        )}
      />
    
  );
}

function formatBytes(bytes) {
  if (bytes  {
  console.log('Video cached:', video.url);
});

// Video removed
VideoCache.onCleared((url) => {
  console.log('Video cleared:', url);
});

// Cache full
VideoCache.onCacheFull((storage) => {
  console.warn('Cache full!', storage);
  // Trigger cleanup
  VideoCache.cleanup('lru', { count: 5 });
});

// Storage low
VideoCache.onStorageLow((storage) => {
  console.warn('Storage low!');
});
```

## Complete Management Example

```tsx
import { VideoCache } from 'react-native-video';

class CacheManager {
  constructor() {
    this.setupAutoCleanup();
    this.setupMonitoring();
  }

  setupAutoCleanup() {
    // Daily cleanup at 3 AM
    setInterval(() => {
      const hour = new Date().getHours();
      if (hour === 3) {
        this.performCleanup();
      }
    }, 60 * 60 * 1000); // Check every hour
  }

  setupMonitoring() {
    VideoCache.onStorageChange(async (storage) => {
      // Auto-cleanup when 90% full
      if (storage.usagePercentage > 0.9) {
        await this.performCleanup();
      }
    });
  }

  async performCleanup() {
    // 1. Remove videos older than 14 days
    await VideoCache.clearOlderThan(14 * 24 * 60 * 60 * 1000);

    // 2. If still over 80%, remove least used
    const storage = await VideoCache.getStorageInfo();
    if (storage.usagePercentage > 0.8) {
      await VideoCache.clearLeastUsed(10);
    }

    // 3. Log cleanup
    console.log('Cache cleanup completed');
    const analytics = await VideoCache.getAnalytics();
    console.log('Analytics:', analytics);
  }

  async getCacheReport() {
    const videos = await VideoCache.getAllCached();
    const storage = await VideoCache.getStorageInfo();
    const analytics = await VideoCache.getAnalytics();

    return {
      totalVideos: videos.length,
      totalSize: storage.usedSize,
      usage: storage.usagePercentage,
      hitRate: analytics.hitRate,
      oldestVideo: videos.sort((a, b) => a.createdAt - b.createdAt)[0],
      largestVideo: videos.sort((a, b) => b.size - a.size)[0],
    };
  }
}

export default new CacheManager();
```

## Best Practices

1. **Auto Cleanup** - Enable automatic cleanup
2. **Storage Monitoring** - Track usage regularly
3. **User Control** - Let users manage cache
4. **Protected Cache** - Protect important content
5. **Analytics** - Track cache performance
6. **Age-Based Cleanup** - Remove old cache regularly

## See Also

- [Getting Started](./getting-started.md) - Video caching basics
- [Configuration](./configuration.md) - Configure caching
- [Strategies](./strategies.md) - Caching strategies
- [Storage](./storage.md) - Storage management

---

## Storage Management

# Storage Management

Manage storage locations, limits, and optimization for video cache.

:::tip Pro Feature - Coming Soon
Video caching is a Pro feature currently in development.
:::

## Overview

Storage management features:
- **Location Control** - Choose where to store cache
- **Size Limits** - Set maximum cache size
- **Storage Types** - Internal vs external storage
- **Quota Management** - Monitor and manage storage quota
- **Optimization** - Optimize storage usage

## Storage Locations

### Auto (Recommended)

Let SDK choose best location:

```tsx
import { VideoCache } from 'react-native-video';

VideoCache.configure({
  cacheLocation: 'auto', // SDK chooses automatically
});
```

SDK considers:
- Available space
- Platform capabilities
- User preferences
- Storage speed

### Internal Storage

Always use internal storage:

```tsx
VideoCache.configure({
  cacheLocation: 'internal',
});
```

**Benefits:**
- Always available
- Faster access
- More secure

**Drawbacks:**
- Limited space
- Shared with app data

### External Storage

Use external/SD card (Android):

```tsx
VideoCache.configure({
  cacheLocation: 'external',
});
```

**Benefits:**
- More space
- Removable

**Drawbacks:**
- May not be available
- Slower access
- Less secure

## Custom Directory

Specify custom cache directory:

```tsx
VideoCache.configure({
  cacheDirectory: '/custom/path/cache',
});
```

### Platform-Specific Paths

```tsx
import { Platform } from 'react-native';

VideoCache.configure({
  cacheDirectory: Platform.select({
    ios: '/Library/Caches/Videos',
    android: '/sdcard/Android/data/com.app/cache',
  }),
});
```

## Storage Limits

### Max Cache Size

Set maximum total cache size:

```tsx
VideoCache.configure({
  maxCacheSize: 1024 * 1024 * 1024, // 1 GB
});
```

### Per-Video Limit

Limit size per video:

```tsx
VideoCache.configure({
  maxVideoSize: 100 * 1024 * 1024, // 100 MB per video
});
```

### Dynamic Limits

Adjust limits based on available space:

```tsx
const availableSpace = await VideoCache.getAvailableSpace();

let maxCacheSize;
if (availableSpace > 10 * 1024 * 1024 * 1024) {
  maxCacheSize = 2 * 1024 * 1024 * 1024; // 2 GB if >10 GB available
} else if (availableSpace > 5 * 1024 * 1024 * 1024) {
  maxCacheSize = 1 * 1024 * 1024 * 1024; // 1 GB if >5 GB available
} else {
  maxCacheSize = 500 * 1024 * 1024; // 500 MB otherwise
}

VideoCache.configure({ maxCacheSize });
```

## Storage Info

### Get Available Space

```tsx
const availableSpace = await VideoCache.getAvailableSpace();
console.log('Available:', formatBytes(availableSpace));
```

### Get Total Space

```tsx
const totalSpace = await VideoCache.getTotalSpace();
console.log('Total:', formatBytes(totalSpace));
```

### Get Cache Usage

```tsx
const storage = await VideoCache.getStorageInfo();
console.log('Cache Size:', formatBytes(storage.usedSize));
console.log('Available in Cache:', formatBytes(storage.availableSize));
console.log('Usage:', (storage.usagePercentage * 100).toFixed(1) + '%');
```

## Storage Optimization

### Compression

Enable cache compression:

```tsx
VideoCache.configure({
  enableCompression: true,
  compressionQuality: 0.8, // 0-1
});
```

### Deduplication

Avoid caching duplicate content:

```tsx
VideoCache.configure({
  enableDeduplication: true, // Use checksums to detect duplicates
});
```

### Cleanup Threshold

Auto-cleanup when reaching threshold:

```tsx
VideoCache.configure({
  cleanupThreshold: 0.9, // Clean when 90% full
  cleanupTarget: 0.7, // Clean down to 70%
});
```

## Storage Monitoring

### Real-Time Monitoring

```tsx
VideoCache.onStorageChange((storage) => {
  console.log('Cache usage:', storage.usagePercentage);
  
  if (storage.usagePercentage > 0.95) {
    // Critical - force cleanup
    VideoCache.clearLeastUsed(10);
  } else if (storage.usagePercentage > 0.9) {
    // Warning - notify user
    showStorageWarning();
  }
});
```

### Periodic Checks

```tsx
setInterval(async () => {
  const storage = await VideoCache.getStorageInfo();
  const device = await VideoCache.getAvailableSpace();
  
  console.log('Cache:', formatBytes(storage.usedSize));
  console.log('Device:', formatBytes(device));
  
  // Warn if device storage is low
  if (device  {
    loadStorage();
  }, []);

  const loadStorage = async () => {
    const info = await VideoCache.getStorageInfo();
    setStorage(info);
  };

  const applySettings = async () => {
    await VideoCache.configure({
      maxCacheSize: maxSize * 1024 * 1024,
      defaultCachePercentage: cachePercentage,
      cacheOnWifiOnly: wifiOnly,
    });
    
    await loadStorage();
  };

  const clearCache = async () => {
    await VideoCache.clearAll();
    await loadStorage();
  };

  return (
    
      Storage Settings

      {storage && (
        
          Used: {formatBytes(storage.usedSize)}
          Limit: {formatBytes(storage.totalSize)}
          Usage: {(storage.usagePercentage * 100).toFixed(1)}%
        
      )}

      
        Max Cache Size: {maxSize} MB
        
      

      
        Cache Percentage: {cachePercentage}%
        
      

      
        WiFi Only:
        
      

      
      
    
  );
}
```

## Complete Example

```tsx
import { VideoCache } from 'react-native-video';

class StorageManager {
  async initialize() {
    await this.setupStorage();
    this.startMonitoring();
  }

  async setupStorage() {
    // Get available space
    const available = await VideoCache.getAvailableSpace();
    
    // Set cache size based on available space
    let maxCacheSize;
    if (available > 10 * 1024 * 1024 * 1024) {
      maxCacheSize = 2 * 1024 * 1024 * 1024; // 2 GB
    } else if (available > 5 * 1024 * 1024 * 1024) {
      maxCacheSize = 1 * 1024 * 1024 * 1024; // 1 GB
    } else {
      maxCacheSize = 500 * 1024 * 1024; // 500 MB
    }

    VideoCache.configure({
      maxCacheSize,
      cacheLocation: 'auto',
      cleanupThreshold: 0.9,
      cleanupTarget: 0.7,
      enableCompression: true,
      enableDeduplication: true,
    });
  }

  startMonitoring() {
    VideoCache.onStorageChange((storage) => {
      console.log('Storage usage:', storage.usagePercentage);
      
      if (storage.usagePercentage > 0.95) {
        this.emergencyCleanup();
      } else if (storage.usagePercentage > 0.9) {
        this.autoCleanup();
      }
    });

    // Check device storage every hour
    setInterval(async () => {
      const available = await VideoCache.getAvailableSpace();
      if (available < 100 * 1024 * 1024) {
        console.warn('Device storage critically low!');
        this.emergencyCleanup();
      }
    }, 60 * 60 * 1000);
  }

  async autoCleanup() {
    await VideoCache.clearOlderThan(7 * 24 * 60 * 60 * 1000);
  }

  async emergencyCleanup() {
    await VideoCache.clearAllExceptProtected();
  }

  async getStorageReport() {
    const storage = await VideoCache.getStorageInfo();
    const device = await VideoCache.getAvailableSpace();
    const videos = await VideoCache.getAllCached();

    return {
      cacheUsed: storage.usedSize,
      cacheLimit: storage.totalSize,
      cacheUsage: storage.usagePercentage,
      deviceAvailable: device,
      videosCount: videos.length,
      avgVideoSize: storage.usedSize / videos.length,
    };
  }
}

export default new StorageManager();
```

## Best Practices

1. **Dynamic Limits** - Adjust based on available space
2. **Auto Cleanup** - Enable automatic cleanup
3. **User Control** - Let users configure limits
4. **Monitoring** - Track storage usage
5. **Platform-Specific** - Optimize per platform
6. **Compression** - Enable for storage savings

## See Also

- [Getting Started](./getting-started.md) - Video caching basics
- [Configuration](./configuration.md) - Configure caching
- [Strategies](./strategies.md) - Caching strategies
- [Cache Management](./management.md) - Manage cached content

---

## Caching Strategies

# Caching Strategies

Smart strategies for when and how to cache videos to disk.

:::tip Pro Feature - Coming Soon
Video caching is a Pro feature currently in development.
:::

## Overview

Caching strategies - all data persists across app restarts:

| Strategy | Description |
|----------|-------------|
| **On Demand** | Cache when user navigates to video |
| **Predictive** | Cache likely-to-watch videos ahead |
| **Background** | Cache during idle time |
| **Scheduled** | Cache at specific times (e.g., overnight) |
| **Smart Queue** | Priority-based caching |

## On-Demand Caching

Cache when user views or scrolls to video:

```tsx
import { VideoCache } from 'react-native-video';

function VideoItem({ video, isVisible }) {
  useEffect(() => {
    if (isVisible) {
      // User can see this video, start caching
      VideoCache.cache({
        url: video.url,
        percentage: 30, // Quick cache for instant playback
        priority: 'high',
      });
    }
  }, [isVisible]);

  return ;
}
```

## Predictive Caching

Cache next videos in feed:

```tsx
function VideoFeed({ videos, currentIndex }) {
  useEffect(() => {
    // Cache next 3 videos
    const nextVideos = videos.slice(currentIndex + 1, currentIndex + 4);
    
    nextVideos.forEach((video, index) => {
      VideoCache.cache({
        url: video.url,
        percentage: 50,
        priority: index === 0 ? 'high' : 'medium', // Higher priority for next video
      });
    });
  }, [currentIndex]);

  // ...
}
```

## Background Caching

Cache during idle time:

```tsx
import { AppState } from 'react-native';
import { VideoCache } from 'react-native-video';

function setupBackgroundCaching() {
  AppState.addEventListener('change', (state) => {
    if (state === 'background') {
      // App is backgrounded, start caching
      VideoCache.queueForBackground(popularVideos.map(v => ({
        url: v.url,
        percentage: 50,
      })));
    }
  });
}
```

## Scheduled Caching

Cache at specific times (e.g., overnight):

```tsx
import { VideoCache } from 'react-native-video';

async function scheduleNightlyCaching() {
  const now = new Date();
  const tonight = new Date();
  tonight.setHours(2, 0, 0, 0); // 2 AM
  
  if (tonight  {
    VideoCache.queueForBackground(videosToCache, {
      requireWifi: true,
      requireCharging: true,
    });
  }, delay);
}
```

## Smart Queue

Priority-based queue management:

```tsx
// High priority - currently viewing
await VideoCache.cache({
  url: currentVideo.url,
  percentage: 100,
  priority: 'high',
});

// Medium priority - next in feed
await VideoCache.cache({
  url: nextVideo.url,
  percentage: 50,
  priority: 'medium',
});

// Low priority - popular content
await VideoCache.cache({
  url: popularVideo.url,
  percentage: 30,
  priority: 'low',
});
```

## Cache Profiles

### Aggressive (Fast Startup)

Cache more, use more storage:

```tsx
VideoCache.configure({
  defaultCachePercentage: 75, // Cache 75%
  maxConcurrentCaches: 3, // Cache 3 at once
  preloadNext: 3, // Preload 3 videos ahead
});
```

### Balanced (Recommended)

Balance between speed and storage:

```tsx
VideoCache.configure({
  defaultCachePercentage: 50, // Cache 50%
  maxConcurrentCaches: 2, // Cache 2 at once
  preloadNext: 2, // Preload 2 videos ahead
});
```

### Conservative (Storage-Saving)

Minimal caching, save storage:

```tsx
VideoCache.configure({
  defaultCachePercentage: 25, // Cache 25%
  maxConcurrentCaches: 1, // Cache 1 at a time
  preloadNext: 1, // Preload 1 video ahead
});
```

## Feed Caching

Cache videos in scrollable feed - all persisted to disk:

```tsx
import { FlatList } from 'react-native';
import { VideoCache } from 'react-native-video';

function VideoFeed({ videos }) {
  const onViewableItemsChanged = useRef(({ viewableItems }) => {
    viewableItems.forEach((item, index) => {
      // Cache visible video
      VideoCache.cache({
        url: item.item.url,
        percentage: 50,
        priority: 'high',
      });
      
      // Preload next videos
      const nextIndex = videos.indexOf(item.item) + 1;
      if (nextIndex  }
    />
  );
}
```

## Playlist Caching

Cache entire playlists:

```tsx
async function cachePlaylist(playlist) {
  for (let i = 0; i  100 * 1024 * 1024 && // 100 MB available
    batteryLevel > 0.5 // 50% battery
  ) {
    await VideoCache.cache({
      url: video.url,
      percentage: 50,
    });
  }
}
```

## User Preferences

Respect user cache preferences:

```tsx
import AsyncStorage from '@react-native-async-storage/async-storage';

async function cacheWithUserPreference(video) {
  const preferences = await AsyncStorage.getItem('cachePreferences');
  const { enabled, wifiOnly, percentage } = JSON.parse(preferences);

  if (!enabled) return;

  const networkState = await VideoCache.getNetworkState();
  
  if (wifiOnly && networkState.type !== 'wifi') {
    return; // Skip caching on cellular
  }

  await VideoCache.cache({
    url: video.url,
    percentage: percentage || 50,
  });
}
```

## Complete Example

```tsx
import React, { useEffect, useRef } from 'react';
import { FlatList, View } from 'react-native';
import { VideoCache, VideoView, useVideoPlayer } from 'react-native-video';

function SmartVideoFeed({ videos }) {
  const currentIndex = useRef(0);

  // Preload on mount
  useEffect(() => {
    preloadInitialVideos();
  }, []);

  const preloadInitialVideos = async () => {
    // Cache first video fully
    await VideoCache.cache({
      url: videos[0].url,
      percentage: 100,
      priority: 'high',
    });

    // Preload next 2 videos partially
    for (let i = 1; i  {
    if (viewableItems.length === 0) return;

    const index = videos.findIndex(v => v.id === viewableItems[0].item.id);
    currentIndex.current = index;

    // Preload next videos
    for (let i = index + 1; i  }
    />
  );
}

function CachedVideoItem({ video }) {
  const player = useVideoPlayer({
    source: {
      uri: video.url,
      cache: true, // Use cache if available
    },
  });

  return (
    
      
    
  );
}
```

## Best Practices

1. **Proximity Caching** - Cache visible/next videos first
2. **Priority Queue** - Use priorities effectively
3. **Condition-Based** - Check network/storage/battery
4. **User Preference** - Respect user settings
5. **Storage Aware** - Don't cache if storage is low
6. **Network Smart** - Prefer WiFi for large caches

## See Also

- [Getting Started](./getting-started.md) - Video caching basics
- [Configuration](./configuration.md) - Configure caching
- [Cache Management](./management.md) - Manage cached content
- [Storage](./storage.md) - Storage management

---

## Adaptive Streaming Downloads

# Adaptive Streaming Downloads

Download HLS and DASH content for offline playback with quality and track selection.

:::tip Pro Feature
Adaptive streaming downloads require a Pro license.
:::

## Overview

Download adaptive streaming content (HLS/DASH) with:
- Quality selection (resolution/bitrate)
- Audio track selection
- Subtitle track selection
- Automatic quality selection
- Segment-based progress tracking

## Basic HLS Download

```tsx
import { VideoDownloader } from 'react-native-video';

const download = await VideoDownloader.download({
  url: 'https://example.com/playlist.m3u8',
  title: 'My HLS Video',
  type: 'hls',
});

await download.start();
```

## Quality Selection

### Automatic Quality (Recommended)

Download the best quality available:

```tsx
const download = await VideoDownloader.download({
  url: 'https://example.com/playlist.m3u8',
  title: 'My Video',
  type: 'hls',
  quality: 'auto', // Downloads highest quality
});
```

### Specific Quality

Choose a specific resolution or bitrate:

```tsx
const download = await VideoDownloader.download({
  url: 'https://example.com/playlist.m3u8',
  title: 'My Video',
  type: 'hls',
  quality: {
    resolution: '1080p',
    // or bitrate: 5000000 (5 Mbps)
  },
});
```

### List Available Qualities

Get all available quality levels before downloading:

```tsx
const qualities = await VideoDownloader.getAvailableQualities(
  'https://example.com/playlist.m3u8'
);

console.log(qualities);
// [
//   { width: 1920, height: 1080, bitrate: 5000000, label: '1080p' },
//   { width: 1280, height: 720, bitrate: 2500000, label: '720p' },
//   { width: 854, height: 480, bitrate: 1000000, label: '480p' },
// ]
```

## Track Selection

### Audio Tracks

Download specific audio tracks:

```tsx
const download = await VideoDownloader.download({
  url: 'https://example.com/playlist.m3u8',
  title: 'My Video',
  type: 'hls',
  audioTracks: [
    { language: 'en', label: 'English' },
    { language: 'es', label: 'Spanish' },
  ],
});
```

### Subtitle Tracks

Download specific subtitle tracks:

```tsx
const download = await VideoDownloader.download({
  url: 'https://example.com/playlist.m3u8',
  title: 'My Video',
  type: 'hls',
  subtitleTracks: [
    { language: 'en', label: 'English' },
    { language: 'fr', label: 'French' },
  ],
});
```

### List Available Tracks

Get all available tracks before downloading:

```tsx
const tracks = await VideoDownloader.getAvailableTracks(
  'https://example.com/playlist.m3u8'
);

console.log(tracks.audio);
// [
//   { id: '1', language: 'en', label: 'English', default: true },
//   { id: '2', language: 'es', label: 'Spanish' },
// ]

console.log(tracks.subtitles);
// [
//   { id: '1', language: 'en', label: 'English' },
//   { id: '2', language: 'fr', label: 'French' },
// ]
```

## DASH Downloads

Download DASH content similarly to HLS:

```tsx
const download = await VideoDownloader.download({
  url: 'https://example.com/manifest.mpd',
  title: 'My DASH Video',
  type: 'dash',
  quality: {
    resolution: '720p',
  },
  audioTracks: [{ language: 'en' }],
});

await download.start();
```

## Advanced Options

### Full Configuration

```tsx
const download = await VideoDownloader.download({
  url: 'https://example.com/playlist.m3u8',
  title: 'My Video',
  type: 'hls',
  
  // Quality selection
  quality: {
    resolution: '1080p',
    // or: bitrate: 5000000,
    // or: 'auto' for best quality
  },
  
  // Track selection
  audioTracks: [
    { language: 'en', label: 'English' },
  ],
  subtitleTracks: [
    { language: 'en', label: 'English' },
    { language: 'es', label: 'Spanish' },
  ],
  
  // Storage optimization
  removeSourceAfterDownload: false,
  
  // Custom headers
  headers: {
    'Authorization': 'Bearer token',
  },
});
```

## Progress Tracking

Adaptive streaming downloads provide detailed segment progress:

```tsx
download.onProgress((progress) => {
  console.log(`Overall: ${progress.percentage}%`);
  console.log(`Segments: ${progress.segmentsDownloaded} / ${progress.totalSegments}`);
  console.log(`Speed: ${(progress.speed / 1024 / 1024).toFixed(2)} MB/s`);
});
```

## Playing Downloaded Content

```tsx
const download = await VideoDownloader.download({
  url: 'https://example.com/playlist.m3u8',
  title: 'My Video',
  type: 'hls',
});

await download.start();

// Play the downloaded content
const player = useVideoPlayer(download.localPath);

return ;
```

## Complete Example

```tsx
import React, { useState, useEffect } from 'react';
import { View, Text, Button, FlatList } from 'react-native';
import { VideoDownloader } from 'react-native-video';

function AdaptiveDownloadExample() {
  const [qualities, setQualities] = useState([]);
  const [selectedQuality, setSelectedQuality] = useState(null);
  const [download, setDownload] = useState(null);
  const [progress, setProgress] = useState(0);

  const url = 'https://example.com/playlist.m3u8';

  useEffect(() => {
    loadQualities();
  }, []);

  const loadQualities = async () => {
    const available = await VideoDownloader.getAvailableQualities(url);
    setQualities(available);
  };

  const startDownload = async () => {
    const dl = await VideoDownloader.download({
      url,
      title: 'My HLS Video',
      type: 'hls',
      quality: selectedQuality || 'auto',
    });

    dl.onProgress((prog) => {
      setProgress(prog.percentage);
    });

    dl.onComplete((result) => {
      console.log('Downloaded:', result.localPath);
    });

    setDownload(dl);
    await dl.start();
  };

  return (
    
      Select Quality:
       (
           setSelectedQuality(item)}
          />
        )}
      />
      
      
      
      {download && Progress: {progress}%}
    
  );
}
```

## See Also

- [Track Selection](./track-selection.md) - Advanced track selection
- [Configuration](./configuration.md) - Download configuration options

---

## Basic Downloads

# Basic Downloads

Download MP4 videos for offline playback with simple API.

## Quick Start

```tsx
import { VideoDownloader } from 'react-native-video';

const download = await VideoDownloader.download({
  url: 'https://example.com/video.mp4',
  title: 'My Video',
});

await download.start();
```

## Download Options

```tsx
interface DownloadOptions {
  url: string;
  title: string;
  metadata?: Record;
  headers?: Record;
  filename?: string;
  directory?: string;
}
```

### url (required)

The URL of the video file to download.

```tsx
const download = await VideoDownloader.download({
  url: 'https://cdn.example.com/videos/my-video.mp4',
  title: 'My Video',
});
```

### title (required)

Human-readable title for the download. Used in UI and notifications.

```tsx
const download = await VideoDownloader.download({
  url: 'https://example.com/video.mp4',
  title: 'Introduction to React Native',
});
```

### metadata (optional)

Custom data attached to the download. See [Metadata](./metadata.md) for details.

```tsx
const download = await VideoDownloader.download({
  url: 'https://example.com/video.mp4',
  title: 'My Video',
  metadata: {
    courseId: '12345',
    chapterId: '3',
    duration: 300,
    thumbnail: 'https://example.com/thumb.jpg',
  },
});
```

### headers (optional)

Custom HTTP headers for the download request.

```tsx
const download = await VideoDownloader.download({
  url: 'https://example.com/video.mp4',
  title: 'My Video',
  headers: {
    'Authorization': 'Bearer token',
    'X-Custom-Header': 'value',
  },
});
```

### filename (optional)

Custom filename for the downloaded file. If not provided, generates from URL.

```tsx
const download = await VideoDownloader.download({
  url: 'https://example.com/video.mp4',
  title: 'My Video',
  filename: 'intro-video.mp4',
});
```

### directory (optional)

Custom directory path. Defaults to app's documents directory.

```tsx
const download = await VideoDownloader.download({
  url: 'https://example.com/video.mp4',
  title: 'My Video',
  directory: 'courses/react-native',
});
```

## Progress Tracking

Monitor download progress in real-time:

```tsx
const download = await VideoDownloader.download({
  url: 'https://example.com/video.mp4',
  title: 'My Video',
});

download.onProgress((progress) => {
  console.log(`Downloaded: ${progress.bytesDownloaded} / ${progress.totalBytes}`);
  console.log(`Progress: ${progress.percentage}%`);
  console.log(`Speed: ${progress.speed} bytes/sec`);
  console.log(`ETA: ${progress.estimatedTimeRemaining} seconds`);
});

await download.start();
```

### Progress Object

```ts
interface DownloadProgress {
  bytesDownloaded: number;
  totalBytes: number;
  percentage: number; // 0-100
  speed: number; // bytes per second
  estimatedTimeRemaining: number; // seconds
}
```

## Download Control

### Start

Begin or resume downloading:

```tsx
await download.start();
```

### Pause

Temporarily pause the download:

```tsx
await download.pause();
```

### Resume

Resume a paused download:

```tsx
await download.resume();
```

### Cancel

Cancel and remove the download:

```tsx
await download.cancel();
```

## Events

Listen to download lifecycle events:

```tsx
const download = await VideoDownloader.download({
  url: 'https://example.com/video.mp4',
  title: 'My Video',
});

// Progress updates
download.onProgress((progress) => {
  console.log(`${progress.percentage}% complete`);
});

// State changes
download.onStateChange((state) => {
  console.log('State:', state);
});

// Completion
download.onComplete((result) => {
  console.log('Download complete!');
  console.log('Local path:', result.localPath);
});

// Errors
download.onError((error) => {
  console.error('Download failed:', error.message);
});

await download.start();
```

## Playing Downloaded Videos

Once downloaded, play the video using its local path:

```tsx
const download = await VideoDownloader.download({
  url: 'https://example.com/video.mp4',
  title: 'My Video',
});

await download.start();

// After download completes
const player = useVideoPlayer(download.localPath);

return ;
```

## Complete Example

```tsx
import React, { useState } from 'react';
import { View, Text, Button, ProgressBar } from 'react-native';
import { VideoDownloader } from 'react-native-video';

function DownloadExample() {
  const [download, setDownload] = useState(null);
  const [progress, setProgress] = useState(0);
  const [state, setState] = useState('idle');

  const startDownload = async () => {
    const dl = await VideoDownloader.download({
      url: 'https://example.com/video.mp4',
      title: 'My Video',
    });

    dl.onProgress((prog) => setProgress(prog.percentage));
    dl.onStateChange((s) => setState(s));
    
    dl.onComplete((result) => {
      console.log('Downloaded to:', result.localPath);
    });

    setDownload(dl);
    await dl.start();
  };

  return (
    
      State: {state}
      {state === 'downloading' && (
        
          
          {progress}%
        
      )}
      
      
      
      {download && state === 'downloading' && (
         download.pause()} />
      )}
      
      {download && state === 'paused' && (
         download.resume()} />
      )}
    
  );
}
```

---

## Configuration

# Configuration

Configure download behavior, storage, networking, and performance settings.

## Global Configuration

Set default configuration for all downloads:

```tsx
import { VideoDownloader } from 'react-native-video';

VideoDownloader.configure({
  maxConcurrentDownloads: 3,
  allowCellularDownload: false,
  directory: 'MyApp/Videos',
  retryAttempts: 3,
  timeout: 30000,
});
```

## Configuration Options

### maxConcurrentDownloads

Maximum number of simultaneous downloads.

```tsx
VideoDownloader.configure({
  maxConcurrentDownloads: 2, // Download 2 videos at once
});
```

**Default**: `3`

### allowCellularDownload

Allow downloads over cellular/mobile data.

```tsx
VideoDownloader.configure({
  allowCellularDownload: true, // Allow mobile data
});
```

**Default**: `false` (WiFi only)

### directory

Custom download directory.

```tsx
VideoDownloader.configure({
  directory: 'MyApp/Videos/Courses',
});
```

**Default**: App's documents directory

### retryAttempts

Number of retry attempts on download failure.

```tsx
VideoDownloader.configure({
  retryAttempts: 5,
});
```

**Default**: `3`

### timeout

Network timeout in milliseconds.

```tsx
VideoDownloader.configure({
  timeout: 60000, // 60 seconds
});
```

**Default**: `30000` (30 seconds)

### chunkSize

Download chunk size in bytes.

```tsx
VideoDownloader.configure({
  chunkSize: 1024 * 1024, // 1 MB chunks
});
```

**Default**: `512 * 1024` (512 KB)

## Per-Download Configuration

Override global settings for specific downloads:

```tsx
const download = await VideoDownloader.download({
  url: 'https://example.com/video.mp4',
  title: 'My Video',
  
  // Override global settings
  allowCellularDownload: true,
  directory: 'MyApp/SpecialVideos',
  retryAttempts: 5,
  timeout: 120000,
});
```

## Storage Configuration

### Storage Location

#### Default Location

```tsx
// Uses app's default documents directory
VideoDownloader.configure({
  directory: undefined, // or omit
});
```

#### Custom Location

```tsx
VideoDownloader.configure({
  directory: 'Downloads/Videos',
});
```

#### Platform-Specific Paths

```tsx
import { Platform } from 'react-native';

VideoDownloader.configure({
  directory: Platform.select({
    ios: 'Library/Videos',
    android: 'Movies',
    default: 'Videos',
  }),
});
```

### Storage Limits

Set maximum storage usage:

```tsx
VideoDownloader.configure({
  maxStorageSize: 5 * 1024 * 1024 * 1024, // 5 GB
});
```

### Automatic Cleanup

Remove oldest downloads when storage limit is reached:

```tsx
VideoDownloader.configure({
  maxStorageSize: 5 * 1024 * 1024 * 1024,
  autoCleanup: true,
  cleanupStrategy: 'oldest', // or 'largest', 'least-viewed'
});
```

## Network Configuration

### WiFi Only

```tsx
VideoDownloader.configure({
  allowCellularDownload: false,
  pauseOnCellular: true, // Auto-pause when switching to cellular
});
```

### Bandwidth Limit

Limit download bandwidth:

```tsx
VideoDownloader.configure({
  maxBandwidth: 5 * 1024 * 1024, // 5 Mbps
});
```

### Connection Type

```tsx
VideoDownloader.configure({
  requiredConnectionType: 'wifi', // 'wifi', 'any', 'ethernet'
});
```

## Performance Configuration

### Parallel Segment Downloads

For HLS/DASH, download segments in parallel:

```tsx
VideoDownloader.configure({
  maxParallelSegments: 4,
});
```

### Background Downloads

Enable background downloads (iOS):

```tsx
VideoDownloader.configure({
  enableBackgroundDownloads: true,
});
```

### Battery Optimization

Pause downloads on low battery:

```tsx
VideoDownloader.configure({
  pauseOnLowBattery: true,
  lowBatteryThreshold: 20, // Pause below 20%
});
```

## Queue Configuration

### Queue Behavior

```tsx
VideoDownloader.configure({
  queueMode: 'fifo', // 'fifo' (first-in-first-out) or 'priority'
  autoStart: true, // Automatically start queued downloads
});
```

### Priority-Based Queue

```tsx
const highPriorityDownload = await VideoDownloader.download({
  url: 'https://example.com/important.mp4',
  title: 'Important Video',
  priority: 'high', // 'high', 'medium', 'low'
});

const lowPriorityDownload = await VideoDownloader.download({
  url: 'https://example.com/optional.mp4',
  title: 'Optional Video',
  priority: 'low',
});
```

## Error Handling Configuration

### Retry Strategy

```tsx
VideoDownloader.configure({
  retryAttempts: 3,
  retryDelay: 5000, // Wait 5 seconds between retries
  retryBackoff: 'exponential', // 'linear' or 'exponential'
});
```

### Error Callbacks

```tsx
VideoDownloader.configure({
  onError: (download, error) => {
    console.error(`Download failed: ${download.title}`, error);
    // Send to analytics
  },
  onRetry: (download, attempt) => {
    console.log(`Retrying ${download.title}, attempt ${attempt}`);
  },
});
```

## Notification Configuration

### Android Notifications

```tsx
VideoDownloader.configure({
  showNotification: true,
  notificationConfig: {
    channelId: 'video_downloads',
    channelName: 'Video Downloads',
    icon: 'ic_download',
    color: '#FF5722',
    onTap: (download) => {
      // Navigate to download screen
    },
  },
});
```

### iOS Background Tasks

```tsx
VideoDownloader.configure({
  enableBackgroundDownloads: true,
  backgroundSessionIdentifier: 'com.myapp.downloads',
});
```

## Complete Configuration Example

```tsx
import { VideoDownloader } from 'react-native-video';
import { Platform } from 'react-native';

// Global configuration on app start
VideoDownloader.configure({
  // Concurrency
  maxConcurrentDownloads: 3,
  maxParallelSegments: 4,
  
  // Network
  allowCellularDownload: false,
  pauseOnCellular: true,
  maxBandwidth: 10 * 1024 * 1024, // 10 Mbps
  timeout: 60000,
  
  // Storage
  directory: 'Downloads/Videos',
  maxStorageSize: 10 * 1024 * 1024 * 1024, // 10 GB
  autoCleanup: true,
  cleanupStrategy: 'oldest',
  
  // Retry
  retryAttempts: 3,
  retryDelay: 5000,
  retryBackoff: 'exponential',
  
  // Battery
  pauseOnLowBattery: true,
  lowBatteryThreshold: 20,
  
  // Queue
  queueMode: 'priority',
  autoStart: true,
  
  // Platform-specific
  ...Platform.select({
    ios: {
      enableBackgroundDownloads: true,
      backgroundSessionIdentifier: 'com.myapp.downloads',
    },
    android: {
      showNotification: true,
      notificationConfig: {
        channelId: 'video_downloads',
        channelName: 'Video Downloads',
        icon: 'ic_download',
      },
    },
  }),
  
  // Callbacks
  onError: (download, error) => {
    console.error('Download failed:', download.title, error);
    // Send to analytics
  },
  onComplete: (download) => {
    console.log('Download complete:', download.title);
    // Update UI
  },
});
```

## Runtime Configuration Changes

Update configuration at runtime:

```tsx
// Disable cellular when roaming
import NetInfo from '@react-native-community/netinfo';

NetInfo.addEventListener(state => {
  if (state.type === 'cellular' && state.details?.isConnectionExpensive) {
    VideoDownloader.configure({
      allowCellularDownload: false,
    });
  }
});
```

## Get Current Configuration

```tsx
const config = VideoDownloader.getConfiguration();

console.log(config);
// {
//   maxConcurrentDownloads: 3,
//   allowCellularDownload: false,
//   ...
// }
```

## Reset Configuration

```tsx
// Reset to defaults
VideoDownloader.resetConfiguration();
```

## Best Practices

1. **WiFi Only** - Default to WiFi-only downloads to save user data
2. **Storage Limits** - Set reasonable storage limits
3. **Auto Cleanup** - Enable automatic cleanup for better UX
4. **Battery Aware** - Pause downloads on low battery
5. **Retry Logic** - Use exponential backoff for retries
6. **Notifications** - Show download progress in notifications
7. **Background Downloads** - Enable for better UX on iOS

## See Also

- [Getting Started](./getting-started.md) - Download basics
- [Basic Downloads](./basic-downloads.md) - MP4 downloads

---

## DRM Downloads

# DRM Downloads

Download DRM-protected content for secure offline playback.

:::tip Pro Feature
DRM downloads require a Pro license.
:::

## Overview

Download and play DRM-protected content offline with support for:
- **Widevine** (Android)
- **FairPlay** (iOS)
- **PlayReady** (Windows, Xbox)
- License persistence
- Offline license renewal
- Secure storage

## Supported DRM Systems

| Platform | Widevine | FairPlay | PlayReady |
|----------|----------|----------|-----------|
| iOS | ❌ | ✅ | ❌ |
| Android | ✅ | ❌ | ❌ |

## Basic DRM Download

```tsx
import { VideoDownloader } from 'react-native-video';

const download = await VideoDownloader.download({
  url: 'https://example.com/protected-video.mp4',
  title: 'Protected Content',
  drm: {
    type: 'fairplay', // or 'widevine', 'playready'
    licenseServer: 'https://license.example.com/acquire',
    certificateUrl: 'https://license.example.com/cert', // FairPlay only
  },
});

await download.start();
```

## FairPlay (iOS)

### Basic FairPlay Download

```tsx
const download = await VideoDownloader.download({
  url: 'https://example.com/hls/master.m3u8',
  title: 'Protected Video',
  type: 'hls',
  drm: {
    type: 'fairplay',
    licenseServer: 'https://fps.example.com/license',
    certificateUrl: 'https://fps.example.com/cert.cer',
  },
});
```

### With Custom Headers

```tsx
const download = await VideoDownloader.download({
  url: 'https://example.com/hls/master.m3u8',
  title: 'Protected Video',
  type: 'hls',
  drm: {
    type: 'fairplay',
    licenseServer: 'https://fps.example.com/license',
    certificateUrl: 'https://fps.example.com/cert.cer',
    headers: {
      'Authorization': 'Bearer token',
      'X-Custom-Data': 'user-id-123',
    },
  },
});
```

### License Duration

```tsx
const download = await VideoDownloader.download({
  url: 'https://example.com/hls/master.m3u8',
  title: 'Protected Video',
  type: 'hls',
  drm: {
    type: 'fairplay',
    licenseServer: 'https://fps.example.com/license',
    certificateUrl: 'https://fps.example.com/cert.cer',
    licenseDuration: 7 * 24 * 60 * 60, // 7 days in seconds
  },
});
```

## Widevine (Android)

### Basic Widevine Download

```tsx
const download = await VideoDownloader.download({
  url: 'https://example.com/dash/manifest.mpd',
  title: 'Protected Video',
  type: 'dash',
  drm: {
    type: 'widevine',
    licenseServer: 'https://widevine.example.com/proxy',
  },
});
```

### With License Challenge

```tsx
const download = await VideoDownloader.download({
  url: 'https://example.com/dash/manifest.mpd',
  title: 'Protected Video',
  type: 'dash',
  drm: {
    type: 'widevine',
    licenseServer: 'https://widevine.example.com/proxy',
    headers: {
      'X-AxDRM-Message': 'license-token',
    },
  },
});
```

## PlayReady (Windows)

```tsx
const download = await VideoDownloader.download({
  url: 'https://example.com/smooth/manifest',
  title: 'Protected Video',
  drm: {
    type: 'playready',
    licenseServer: 'https://playready.example.com/license',
    headers: {
      'Authorization': 'Bearer token',
    },
  },
});
```

## License Management

### Check License Status

```tsx
const download = await VideoDownloadManager.findById(downloadId);

const licenseStatus = await download.getLicenseStatus();

console.log(licenseStatus);
// {
//   isValid: true,
//   expirationDate: '2024-12-31T23:59:59Z',
//   daysRemaining: 7,
//   canRenew: true,
// }
```

### Renew License

```tsx
const download = await VideoDownloadManager.findById(downloadId);

await download.renewLicense();

console.log('License renewed successfully');
```

### Auto-Renewal

Enable automatic license renewal before expiration:

```tsx
const download = await VideoDownloader.download({
  url: 'https://example.com/protected.mp4',
  title: 'Protected Video',
  drm: {
    type: 'fairplay',
    licenseServer: 'https://fps.example.com/license',
    certificateUrl: 'https://fps.example.com/cert.cer',
    autoRenew: true,
    renewBeforeDays: 2, // Renew 2 days before expiration
  },
});
```

## Offline Playback

### Play Downloaded DRM Content

```tsx
const download = await VideoDownloadManager.findById(downloadId);

// Check license before playing
const licenseStatus = await download.getLicenseStatus();

if (!licenseStatus.isValid) {
  console.error('License expired');
  // Attempt to renew
  await download.renewLicense();
}

// Play the content
const player = useVideoPlayer(download.localPath, {
  drm: download.drmConfig,
});

return ;
```

## Security Features

### Secure Storage

DRM downloads are automatically stored in secure, encrypted storage:

```tsx
const download = await VideoDownloader.download({
  url: 'https://example.com/protected.mp4',
  title: 'Protected Video',
  drm: {
    type: 'widevine',
    licenseServer: 'https://license.example.com',
  },
  secureStorage: true, // Default for DRM content
});
```

### Screenshot Prevention

Prevent screenshots during playback:

```tsx
const player = useVideoPlayer(download.localPath, {
  drm: download.drmConfig,
  preventScreenCapture: true,
});
```

## Error Handling

### License Acquisition Errors

```tsx
const download = await VideoDownloader.download({
  url: 'https://example.com/protected.mp4',
  title: 'Protected Video',
  drm: {
    type: 'fairplay',
    licenseServer: 'https://fps.example.com/license',
    certificateUrl: 'https://fps.example.com/cert.cer',
  },
});

download.onError((error) => {
  if (error.code === 'DRM_LICENSE_ERROR') {
    console.error('Failed to acquire license:', error.message);
    // Show user-friendly error
  } else if (error.code === 'DRM_CERTIFICATE_ERROR') {
    console.error('Invalid certificate:', error.message);
  }
});

await download.start();
```

### License Expiration Handling

```tsx
// Listen for license expiration
download.onLicenseExpiring((daysRemaining) => {
  console.log(`License expires in ${daysRemaining} days`);
  // Show renewal prompt to user
});

download.onLicenseExpired(() => {
  console.log('License has expired');
  // Disable playback, show renewal option
});
```

## Complete Example

```tsx
import React, { useState, useEffect } from 'react';
import { View, Text, Button, Alert } from 'react-native';
import { VideoDownloader, VideoDownloadManager, useVideoPlayer } from 'react-native-video';

function DRMDownloadExample() {
  const [download, setDownload] = useState(null);
  const [licenseStatus, setLicenseStatus] = useState(null);
  const [player, setPlayer] = useState(null);

  const startDownload = async () => {
    const dl = await VideoDownloader.download({
      url: 'https://example.com/hls/master.m3u8',
      title: 'Protected Content',
      type: 'hls',
      drm: {
        type: 'fairplay',
        licenseServer: 'https://fps.example.com/license',
        certificateUrl: 'https://fps.example.com/cert.cer',
        licenseDuration: 7 * 24 * 60 * 60,
        autoRenew: true,
        renewBeforeDays: 1,
      },
    });

    dl.onProgress((progress) => {
      console.log(`Downloaded: ${progress.percentage}%`);
    });

    dl.onComplete(async () => {
      const status = await dl.getLicenseStatus();
      setLicenseStatus(status);
      setDownload(dl);
    });

    dl.onError((error) => {
      Alert.alert('Download Failed', error.message);
    });

    await dl.start();
  };

  const playVideo = () => {
    if (!licenseStatus?.isValid) {
      Alert.alert('License Invalid', 'Please renew the license');
      return;
    }

    const p = useVideoPlayer(download.localPath, {
      drm: download.drmConfig,
      preventScreenCapture: true,
    });

    setPlayer(p);
  };

  const renewLicense = async () => {
    try {
      await download.renewLicense();
      const status = await download.getLicenseStatus();
      setLicenseStatus(status);
      Alert.alert('Success', 'License renewed');
    } catch (error) {
      Alert.alert('Renewal Failed', error.message);
    }
  };

  return (
    
      {!download && (
        
      )}

      {download && licenseStatus && (
        
          License Status: {licenseStatus.isValid ? 'Valid' : 'Expired'}
          Days Remaining: {licenseStatus.daysRemaining}
          
          {licenseStatus.isValid && (
            
          )}
          
          {licenseStatus.canRenew && (
            
          )}
        
      )}

      {player && (
        
      )}
    
  );
}
```

## Best Practices

1. **Check License Before Download** - Verify user has valid entitlement
2. **Monitor Expiration** - Track license expiration dates
3. **Auto-Renewal** - Enable auto-renewal for better UX
4. **Error Handling** - Provide clear error messages for license issues
5. **Secure Storage** - Always use secure storage for DRM content
6. **Test on Device** - DRM doesn't work in simulators/emulators

## See Also

- [Adaptive Streaming](./adaptive-streaming.md) - HLS/DASH downloads
- [Configuration](./configuration.md) - Download configuration
- [DRM Playback](../../players/drm.md) - Online DRM playback

---

## Getting Started

# Getting Started

Download videos for offline playback with full control over quality, tracks, and storage.

## Overview

The Downloading API enables:
- **Offline Playback** - Watch videos without an internet connection
- **Quality Control** - Download specific quality levels
- **Track Selection** - Choose audio/subtitle tracks to download
- **Progress Tracking** - Monitor download progress and status
- **Storage Management** - Control where and how files are stored
- **Metadata** - Attach custom data to downloads
- **DRM Support** - Download DRM-protected content *(Pro)*

## Basic Example

```tsx
import { VideoDownloader } from 'react-native-video';

// Simple MP4 download
const download = await VideoDownloader.download({
  url: 'https://example.com/video.mp4',
  title: 'My Video',
});

// Monitor progress
download.onProgress((progress) => {
  console.log(`Downloaded: ${progress.percentage}%`);
});

// Wait for completion
await download.start();

// Play the downloaded video
const player = useVideoPlayer(download.localPath);
```

## Installation

The Downloading feature requires additional native setup:

### iOS

Add to your `Podfile`:

```ruby
pod 'RNVideoDownloader', :path => '../node_modules/react-native-video/ios'
```

### Android

Add to `android/app/build.gradle`:

```gradle
dependencies {
  implementation project(':react-native-video-downloader')
}
```

## Quick Start

### 1. Create a Download

```tsx
const download = await VideoDownloader.download({
  url: 'https://example.com/video.mp4',
  title: 'My Video',
  metadata: {
    description: 'Video description',
    thumbnail: 'https://example.com/thumb.jpg',
  },
});
```

### 2. Start Downloading

```tsx
// Start immediately
await download.start();

// Or listen to events
download.onProgress((progress) => {
  console.log(`${progress.bytesDownloaded} / ${progress.totalBytes}`);
});

download.onComplete((result) => {
  console.log('Download completed!', result.localPath);
});

download.onError((error) => {
  console.error('Download failed:', error);
});

await download.start();
```

### 3. Play Downloaded Video

```tsx
const player = useVideoPlayer(download.localPath);

return ;
```

## Download Manager

Manage multiple downloads with the Download Manager:

```tsx
import { VideoDownloadManager } from 'react-native-video';

// Get all downloads
const downloads = await VideoDownloadManager.getAll();

// Find specific download
const download = await VideoDownloadManager.findById(downloadId);

// Remove download
await VideoDownloadManager.remove(downloadId);

// Get total storage used
const totalSize = await VideoDownloadManager.getTotalSize();
```

## Download States

Downloads progress through these states:

| State | Description |
|-------|-------------|
| `queued` | Waiting to start |
| `downloading` | Actively downloading |
| `paused` | Temporarily paused |
| `completed` | Successfully downloaded |
| `failed` | Download failed |
| `cancelled` | User cancelled |

```tsx
download.onStateChange((state) => {
  switch (state) {
    case 'queued':
      console.log('Waiting to start...');
      break;
    case 'downloading':
      console.log('Downloading...');
      break;
    case 'completed':
      console.log('Ready to play!');
      break;
    case 'failed':
      console.log('Something went wrong');
      break;
  }
});
```

## Next Steps

- [Basic Downloads](./basic-downloads.md) - Download MP4 videos
- [Adaptive Streaming](./adaptive-streaming.md) - Download HLS/DASH *(Pro)*
- [Track Selection](./track-selection.md) - Choose specific audio/subtitle tracks *(Pro)*
- [Metadata](./metadata.md) - Attach custom data to downloads
- [Configuration](./configuration.md) - Configure download behavior

---

## Metadata

# Metadata

Attach custom data to downloads for organization and UI display.

## Overview

Metadata allows you to:
- Store custom information with downloads
- Organize downloads by category, course, etc.
- Display thumbnails and descriptions
- Track download context (user, timestamp, etc.)
- Build rich offline libraries

## Basic Metadata

```tsx
import { VideoDownloader } from 'react-native-video';

const download = await VideoDownloader.download({
  url: 'https://example.com/video.mp4',
  title: 'Introduction to React Native',
  metadata: {
    description: 'Learn the basics of React Native development',
    thumbnail: 'https://example.com/thumbnails/intro.jpg',
    duration: 600, // seconds
    instructor: 'John Doe',
  },
});
```

## Common Metadata Fields

### Course/Educational Content

```tsx
const download = await VideoDownloader.download({
  url: 'https://example.com/lecture.mp4',
  title: 'Lecture 5: State Management',
  metadata: {
    courseId: 'react-native-101',
    courseName: 'React Native Fundamentals',
    chapterId: '3',
    chapterName: 'Advanced Concepts',
    lessonNumber: 5,
    instructor: 'Jane Smith',
    duration: 1800,
    thumbnail: 'https://cdn.example.com/thumbs/lecture5.jpg',
    tags: ['react', 'state', 'hooks'],
    difficulty: 'intermediate',
  },
});
```

### Movies/Entertainment

```tsx
const download = await VideoDownloader.download({
  url: 'https://example.com/movie.mp4',
  title: 'The Matrix',
  metadata: {
    genre: ['Action', 'Sci-Fi'],
    year: 1999,
    director: 'Wachowski Brothers',
    cast: ['Keanu Reeves', 'Laurence Fishburne'],
    rating: 'R',
    duration: 8160, // seconds
    thumbnail: 'https://cdn.example.com/posters/matrix.jpg',
    synopsis: 'A computer hacker learns from mysterious rebels...',
    imdbId: 'tt0133093',
  },
});
```

### User-Generated Content

```tsx
const download = await VideoDownloader.download({
  url: 'https://example.com/user-video.mp4',
  title: 'My Vacation 2024',
  metadata: {
    userId: 'user123',
    uploadDate: '2024-01-15',
    location: 'Paris, France',
    tags: ['vacation', 'travel', 'europe'],
    thumbnail: 'https://example.com/thumbs/vacation.jpg',
    isPrivate: true,
    views: 0,
  },
});
```

## Retrieving Metadata

### Get Download with Metadata

```tsx
const download = await VideoDownloadManager.findById(downloadId);

console.log(download.metadata);
// {
//   courseId: 'react-native-101',
//   chapterName: 'Advanced Concepts',
//   ...
// }
```

### List Downloads with Metadata

```tsx
const downloads = await VideoDownloadManager.getAll();

downloads.forEach(download => {
  console.log(download.title);
  console.log(download.metadata);
});
```

## Filtering by Metadata

### By Course

```tsx
const downloads = await VideoDownloadManager.getAll();

const courseDownloads = downloads.filter(
  d => d.metadata?.courseId === 'react-native-101'
);
```

### By Tag

```tsx
const reactDownloads = downloads.filter(
  d => d.metadata?.tags?.includes('react')
);
```

### By Custom Field

```tsx
const recentDownloads = downloads.filter(
  d => {
    const date = new Date(d.metadata?.downloadDate);
    const weekAgo = Date.now() - 7 * 24 * 60 * 60 * 1000;
    return date.getTime() > weekAgo;
  }
);
```

## Updating Metadata

Update metadata after download creation:

```tsx
const download = await VideoDownloadManager.findById(downloadId);

await download.updateMetadata({
  ...download.metadata,
  views: (download.metadata?.views || 0) + 1,
  lastViewed: new Date().toISOString(),
});
```

## Displaying Metadata in UI

### Download List with Thumbnails

```tsx
import React from 'react';
import { FlatList, Image, Text, View } from 'react-native';

function DownloadList({ downloads }) {
  return (
     (
        
          
          
            {item.title}
            
              {item.metadata?.description}
            
            
              {formatDuration(item.metadata?.duration)}
            
          
        
      )}
    />
  );
}
```

### Grouped by Category

```tsx
function GroupedDownloads({ downloads }) {
  const grouped = downloads.reduce((acc, download) => {
    const category = download.metadata?.category || 'Uncategorized';
    if (!acc[category]) {
      acc[category] = [];
    }
    acc[category].push(download);
    return acc;
  }, {});

  return (
    
      {Object.entries(grouped).map(([category, items]) => (
        
          {category}
           }
          />
        
      ))}
    
  );
}
```

## Searchable Metadata

Make downloads searchable by metadata:

```tsx
function searchDownloads(query, downloads) {
  const lowerQuery = query.toLowerCase();
  
  return downloads.filter(download => {
    // Search title
    if (download.title.toLowerCase().includes(lowerQuery)) {
      return true;
    }
    
    // Search description
    if (download.metadata?.description?.toLowerCase().includes(lowerQuery)) {
      return true;
    }
    
    // Search tags
    if (download.metadata?.tags?.some(tag => 
      tag.toLowerCase().includes(lowerQuery)
    )) {
      return true;
    }
    
    return false;
  });
}
```

## Sorting by Metadata

```tsx
// Sort by duration
const sortedByDuration = [...downloads].sort((a, b) => 
  (a.metadata?.duration || 0) - (b.metadata?.duration || 0)
);

// Sort by date
const sortedByDate = [...downloads].sort((a, b) => 
  new Date(b.metadata?.uploadDate) - new Date(a.metadata?.uploadDate)
);

// Sort by lesson number
const sortedByLesson = [...downloads].sort((a, b) =>
  (a.metadata?.lessonNumber || 0) - (b.metadata?.lessonNumber || 0)
);
```

## Complete Example

```tsx
import React, { useState, useEffect } from 'react';
import { View, FlatList, Image, Text, TextInput } from 'react-native';
import { VideoDownloadManager } from 'react-native-video';

function DownloadLibrary() {
  const [downloads, setDownloads] = useState([]);
  const [searchQuery, setSearchQuery] = useState('');
  const [filter, setFilter] = useState('all');

  useEffect(() => {
    loadDownloads();
  }, []);

  const loadDownloads = async () => {
    const all = await VideoDownloadManager.getAll();
    setDownloads(all);
  };

  const filteredDownloads = downloads
    .filter(d => {
      // Filter by category
      if (filter !== 'all' && d.metadata?.category !== filter) {
        return false;
      }
      
      // Filter by search
      if (searchQuery) {
        const query = searchQuery.toLowerCase();
        return (
          d.title.toLowerCase().includes(query) ||
          d.metadata?.description?.toLowerCase().includes(query) ||
          d.metadata?.tags?.some(tag => tag.toLowerCase().includes(query))
        );
      }
      
      return true;
    })
    .sort((a, b) => 
      // Sort by lesson number if available
      (a.metadata?.lessonNumber || 999) - (b.metadata?.lessonNumber || 999)
    );

  return (
    
      
      
       (
          
            {item.metadata?.thumbnail && (
              
            )}
            
              {item.title}
              {item.metadata?.description && (
                
                  {item.metadata.description}
                
              )}
              {item.metadata?.duration && (
                
                  {Math.floor(item.metadata.duration / 60)} min
                
              )}
              {item.metadata?.tags && (
                
                  {item.metadata.tags.map(tag => (
                    {tag}
                  ))}
                
              )}
            
          
        )}
      />
    
  );
}
```

## Best Practices

1. **Consistent Structure** - Use consistent metadata fields across similar content types
2. **Thumbnails** - Always include thumbnails for better UX
3. **Search Keywords** - Add relevant tags for searchability
4. **Timestamps** - Include creation/download/update timestamps
5. **File Size** - Store file size for storage management UI
6. **Validation** - Validate metadata before saving

## See Also

- [Basic Downloads](./basic-downloads.md) - Download API basics
- [Configuration](./configuration.md) - Download configuration

---

## Track Selection

# Track Selection

Select specific audio and subtitle tracks when downloading adaptive streaming content.

:::tip Pro Feature
Advanced track selection requires a Pro license.
:::

## Overview

When downloading HLS/DASH content, you can:
- Select multiple audio tracks
- Select multiple subtitle tracks
- Set default tracks
- List available tracks before download

## Get Available Tracks

Before downloading, check what tracks are available:

```tsx
import { VideoDownloader } from 'react-native-video';

const tracks = await VideoDownloader.getAvailableTracks(
  'https://example.com/playlist.m3u8'
);

console.log(tracks);
// {
//   audio: [
//     { id: '1', language: 'en', label: 'English', channels: 2, bitrate: 128000, default: true },
//     { id: '2', language: 'es', label: 'Spanish', channels: 2, bitrate: 128000 },
//     { id: '3', language: 'en', label: 'English (5.1)', channels: 6, bitrate: 384000 },
//   ],
//   subtitles: [
//     { id: '1', language: 'en', label: 'English', format: 'vtt' },
//     { id: '2', language: 'es', label: 'Spanish', format: 'vtt' },
//     { id: '3', language: 'fr', label: 'French', format: 'vtt' },
//   ],
// }
```

## Audio Track Selection

### Select Single Audio Track

```tsx
const download = await VideoDownloader.download({
  url: 'https://example.com/playlist.m3u8',
  title: 'My Video',
  type: 'hls',
  audioTracks: [
    { language: 'en' }
  ],
});
```

### Select Multiple Audio Tracks

Download multiple audio tracks for multilingual support:

```tsx
const download = await VideoDownloader.download({
  url: 'https://example.com/playlist.m3u8',
  title: 'My Video',
  type: 'hls',
  audioTracks: [
    { language: 'en', label: 'English' },
    { language: 'es', label: 'Spanish' },
    { language: 'fr', label: 'French' },
  ],
});
```

### Select by Track ID

Use specific track IDs for precise selection:

```tsx
const tracks = await VideoDownloader.getAvailableTracks(url);
const englishTrack = tracks.audio.find(t => t.language === 'en');

const download = await VideoDownloader.download({
  url,
  title: 'My Video',
  type: 'hls',
  audioTracks: [
    { id: englishTrack.id }
  ],
});
```

### Audio Track Criteria

```ts
interface AudioTrackSelection {
  id?: string;           // Specific track ID
  language?: string;     // Language code (e.g., 'en', 'es')
  label?: string;        // Track label
  channels?: number;     // Audio channels (2, 6, etc.)
  minBitrate?: number;   // Minimum bitrate
  maxBitrate?: number;   // Maximum bitrate
  default?: boolean;     // Select default track
}
```

## Subtitle Track Selection

### Select Single Subtitle Track

```tsx
const download = await VideoDownloader.download({
  url: 'https://example.com/playlist.m3u8',
  title: 'My Video',
  type: 'hls',
  subtitleTracks: [
    { language: 'en' }
  ],
});
```

### Select Multiple Subtitle Tracks

```tsx
const download = await VideoDownloader.download({
  url: 'https://example.com/playlist.m3u8',
  title: 'My Video',
  type: 'hls',
  subtitleTracks: [
    { language: 'en', label: 'English' },
    { language: 'es', label: 'Spanish' },
    { language: 'fr', label: 'French' },
    { language: 'de', label: 'German' },
  ],
});
```

### Subtitle Track Criteria

```ts
interface SubtitleTrackSelection {
  id?: string;        // Specific track ID
  language?: string;  // Language code
  label?: string;     // Track label
  format?: string;    // Subtitle format ('vtt', 'srt', etc.)
  forced?: boolean;   // Forced subtitles only
  sdh?: boolean;      // SDH/CC subtitles
}
```

## Default Tracks

### Set Default Audio Track

```tsx
const download = await VideoDownloader.download({
  url: 'https://example.com/playlist.m3u8',
  title: 'My Video',
  type: 'hls',
  audioTracks: [
    { language: 'en', default: true },
    { language: 'es' },
  ],
});
```

### Set Default Subtitle Track

```tsx
const download = await VideoDownloader.download({
  url: 'https://example.com/playlist.m3u8',
  title: 'My Video',
  type: 'hls',
  subtitleTracks: [
    { language: 'en', default: true },
    { language: 'fr' },
  ],
});
```

## Advanced Selection

### Quality-Specific Audio

Select high-quality audio for high-resolution video:

```tsx
const download = await VideoDownloader.download({
  url: 'https://example.com/playlist.m3u8',
  title: 'My Video',
  type: 'hls',
  quality: '1080p',
  audioTracks: [
    {
      language: 'en',
      channels: 6,  // 5.1 surround
      minBitrate: 384000,
    },
  ],
});
```

### All Tracks

Download all available tracks:

```tsx
const tracks = await VideoDownloader.getAvailableTracks(url);

const download = await VideoDownloader.download({
  url,
  title: 'My Video',
  type: 'hls',
  audioTracks: tracks.audio,
  subtitleTracks: tracks.subtitles,
});
```

## Track Filtering

### Filter by Language

```tsx
const tracks = await VideoDownloader.getAvailableTracks(url);

// Only English and Spanish audio
const filteredAudio = tracks.audio.filter(
  t => ['en', 'es'].includes(t.language)
);

const download = await VideoDownloader.download({
  url,
  title: 'My Video',
  type: 'hls',
  audioTracks: filteredAudio,
});
```

### Filter by Channels

```tsx
const tracks = await VideoDownloader.getAvailableTracks(url);

// Only stereo audio (2 channels)
const stereoAudio = tracks.audio.filter(t => t.channels === 2);

const download = await VideoDownloader.download({
  url,
  title: 'My Video',
  type: 'hls',
  audioTracks: stereoAudio,
});
```

## Playing with Track Selection

After download, select tracks during playback:

```tsx
const download = await VideoDownloader.download({
  url: 'https://example.com/playlist.m3u8',
  title: 'My Video',
  type: 'hls',
  audioTracks: [
    { language: 'en' },
    { language: 'es' },
  ],
  subtitleTracks: [
    { language: 'en' },
    { language: 'es' },
  ],
});

await download.start();

// Play with track selection
const player = useVideoPlayer(download.localPath);

// Get available tracks
const availableTracks = player.getAvailableTextTracks();

// Select Spanish audio
player.selectAudioTrack({ language: 'es' });

// Select English subtitles
player.selectTextTrack({ language: 'en' });
```

## Complete Example

```tsx
import React, { useState, useEffect } from 'react';
import { View, Text, Button, FlatList, Switch } from 'react-native';
import { VideoDownloader } from 'react-native-video';

function TrackSelectionExample() {
  const [tracks, setTracks] = useState({ audio: [], subtitles: [] });
  const [selectedAudio, setSelectedAudio] = useState([]);
  const [selectedSubtitles, setSelectedSubtitles] = useState([]);

  const url = 'https://example.com/playlist.m3u8';

  useEffect(() => {
    loadTracks();
  }, []);

  const loadTracks = async () => {
    const available = await VideoDownloader.getAvailableTracks(url);
    setTracks(available);
  };

  const toggleAudioTrack = (track) => {
    setSelectedAudio(prev => {
      const exists = prev.find(t => t.id === track.id);
      if (exists) {
        return prev.filter(t => t.id !== track.id);
      }
      return [...prev, track];
    });
  };

  const toggleSubtitleTrack = (track) => {
    setSelectedSubtitles(prev => {
      const exists = prev.find(t => t.id === track.id);
      if (exists) {
        return prev.filter(t => t.id !== track.id);
      }
      return [...prev, track];
    });
  };

  const startDownload = async () => {
    const download = await VideoDownloader.download({
      url,
      title: 'My Video',
      type: 'hls',
      audioTracks: selectedAudio,
      subtitleTracks: selectedSubtitles,
    });

    await download.start();
  };

  return (
    
      Audio Tracks:
       (
          
             t.id === item.id)}
              onValueChange={() => toggleAudioTrack(item)}
            />
            {item.label} ({item.language}) - {item.channels}ch
          
        )}
      />

      Subtitle Tracks:
       (
          
             t.id === item.id)}
              onValueChange={() => toggleSubtitleTrack(item)}
            />
            {item.label} ({item.language})
          
        )}
      />

      
    
  );
}
```

## See Also

- [Adaptive Streaming](./adaptive-streaming.md) - HLS/DASH downloads
- [Configuration](./configuration.md) - Download configuration

---

## Basic Upload

# Basic Upload

Upload single files with simple API and automatic retry.

## Quick Start

```tsx
import { VideoUploader } from 'react-native-video';

const upload = await VideoUploader.upload({
  file: '/path/to/video.mp4',
  url: 'https://api.example.com/upload',
});

await upload.start();
```

## Upload Options

```tsx
interface UploadOptions {
  file: string;
  url: string;
  method?: 'POST' | 'PUT';
  headers?: Record;
  fields?: Record;
  metadata?: Record;
  fileKey?: string;
}
```

### file (required)

Local path to the file to upload.

```tsx
const upload = await VideoUploader.upload({
  file: '/var/mobile/Containers/Data/video.mp4',
  url: 'https://api.example.com/upload',
});
```

### url (required)

The server endpoint to upload to.

```tsx
const upload = await VideoUploader.upload({
  file: '/path/to/video.mp4',
  url: 'https://api.example.com/videos/upload',
});
```

### method (optional)

HTTP method to use. Defaults to `'POST'`.

```tsx
const upload = await VideoUploader.upload({
  file: '/path/to/video.mp4',
  url: 'https://api.example.com/upload',
  method: 'PUT',
});
```

### headers (optional)

Custom HTTP headers.

```tsx
const upload = await VideoUploader.upload({
  file: '/path/to/video.mp4',
  url: 'https://api.example.com/upload',
  headers: {
    'Authorization': 'Bearer token123',
    'X-Custom-Header': 'value',
  },
});
```

### fields (optional)

Additional form fields to send with the upload.

```tsx
const upload = await VideoUploader.upload({
  file: '/path/to/video.mp4',
  url: 'https://api.example.com/upload',
  fields: {
    title: 'My Video',
    description: 'Uploaded from mobile',
    userId: '12345',
  },
});
```

### metadata (optional)

Custom metadata for local tracking (not sent to server).

```tsx
const upload = await VideoUploader.upload({
  file: '/path/to/video.mp4',
  url: 'https://api.example.com/upload',
  metadata: {
    localId: 'abc123',
    timestamp: Date.now(),
    category: 'vacation',
  },
});
```

### fileKey (optional)

The form field name for the file. Defaults to `'file'`.

```tsx
const upload = await VideoUploader.upload({
  file: '/path/to/video.mp4',
  url: 'https://api.example.com/upload',
  fileKey: 'video', // Server expects 'video' field
});
```

## Progress Tracking

Monitor upload progress in real-time:

```tsx
const upload = await VideoUploader.upload({
  file: '/path/to/video.mp4',
  url: 'https://api.example.com/upload',
});

upload.onProgress((progress) => {
  console.log(`Uploaded: ${progress.bytesUploaded} / ${progress.totalBytes}`);
  console.log(`Progress: ${progress.percentage}%`);
  console.log(`Speed: ${progress.speed} bytes/sec`);
  console.log(`ETA: ${progress.estimatedTimeRemaining} seconds`);
});

await upload.start();
```

### Progress Object

```ts
interface UploadProgress {
  bytesUploaded: number;
  totalBytes: number;
  percentage: number; // 0-100
  speed: number; // bytes per second
  estimatedTimeRemaining: number; // seconds
}
```

## Upload Control

### Start

Begin the upload:

```tsx
await upload.start();
```

### Pause

Temporarily pause the upload:

```tsx
await upload.pause();
```

### Resume

Resume a paused upload:

```tsx
await upload.resume();
```

### Cancel

Cancel and remove the upload:

```tsx
await upload.cancel();
```

## Events

Listen to upload lifecycle events:

```tsx
const upload = await VideoUploader.upload({
  file: '/path/to/video.mp4',
  url: 'https://api.example.com/upload',
});

// Progress updates
upload.onProgress((progress) => {
  console.log(`${progress.percentage}% complete`);
});

// State changes
upload.onStateChange((state) => {
  console.log('State:', state);
});

// Completion
upload.onComplete((response) => {
  console.log('Upload complete!');
  console.log('Server response:', response.data);
  console.log('Status code:', response.statusCode);
});

// Errors
upload.onError((error) => {
  console.error('Upload failed:', error.message);
  console.error('Code:', error.code);
});

// Network changes
upload.onNetworkChange((state) => {
  console.log('Network:', state.isConnected ? 'Connected' : 'Disconnected');
});

await upload.start();
```

## Server Response

Handle server responses:

```tsx
upload.onComplete((response) => {
  console.log('Status:', response.statusCode);
  console.log('Headers:', response.headers);
  console.log('Body:', response.data);
  
  // Parse JSON response
  const data = JSON.parse(response.data);
  console.log('Video ID:', data.videoId);
  console.log('URL:', data.url);
});
```

## Error Handling

```tsx
upload.onError((error) => {
  switch (error.code) {
    case 'NETWORK_ERROR':
      console.error('Network error:', error.message);
      break;
    case 'SERVER_ERROR':
      console.error('Server error:', error.statusCode);
      break;
    case 'FILE_NOT_FOUND':
      console.error('File not found:', error.filePath);
      break;
    case 'CANCELLED':
      console.log('Upload was cancelled');
      break;
    default:
      console.error('Unknown error:', error);
  }
});
```

## Complete Example

```tsx
import React, { useState } from 'react';
import { View, Text, Button, ProgressBar } from 'react-native';
import { VideoUploader } from 'react-native-video';

function UploadExample({ filePath }) {
  const [upload, setUpload] = useState(null);
  const [progress, setProgress] = useState(0);
  const [state, setState] = useState('idle');
  const [response, setResponse] = useState(null);

  const startUpload = async () => {
    const ul = await VideoUploader.upload({
      file: filePath,
      url: 'https://api.example.com/upload',
      headers: {
        'Authorization': 'Bearer token',
      },
      fields: {
        title: 'My Video',
        userId: 'user123',
      },
    });

    ul.onProgress((prog) => setProgress(prog.percentage));
    ul.onStateChange((s) => setState(s));
    
    ul.onComplete((resp) => {
      console.log('Upload completed!');
      setResponse(resp);
    });

    ul.onError((error) => {
      console.error('Upload failed:', error);
      alert(`Upload failed: ${error.message}`);
    });

    setUpload(ul);
    await ul.start();
  };

  return (
    
      State: {state}
      
      {state === 'uploading' && (
        
          
          {progress}%
        
      )}
      
      
      
      {upload && state === 'uploading' && (
         upload.pause()} />
      )}
      
      {upload && state === 'paused' && (
         upload.resume()} />
      )}

      {response && (
        
          Upload successful!
          Status: {response.statusCode}
          Response: {JSON.stringify(response.data)}
        
      )}
    
  );
}
```

## Best Practices

1. **Auth Tokens** - Include authentication in headers
2. **Error Handling** - Always listen to `onError` events
3. **Network Awareness** - Enable network tracking for cellular/WiFi
4. **User Feedback** - Show progress and status to users
5. **Validation** - Validate file exists before uploading
6. **Retry Logic** - Enable automatic retry for reliability

## See Also

- [Multi-Part Upload](./multi-part-upload.md) - Large file uploads *(Pro)*
- [Queue Management](./queue-management.md) - Handle multiple uploads
- [Configuration](./configuration.md) - Upload configuration

---

## Configuration

# Configuration

Configure upload behavior globally and per-upload.

## Global Configuration

Configure defaults for all uploads:

```tsx
import { VideoUploadManager } from 'react-native-video';

VideoUploadManager.configure({
  // Queue settings
  maxConcurrentUploads: 2,
  queueMode: 'priority',
  autoStart: true,
  
  // Network settings
  requireWifi: false,
  allowCellular: true,
  networkTracking: true,
  
  // Retry settings
  retryAttempts: 3,
  retryDelay: 5000,
  
  // Multi-part settings
  chunkSize: 5 * 1024 * 1024,
  maxParallelUploads: 3,
  
  // Timeout settings
  timeout: 300000, // 5 minutes
  
  // Storage
  persistQueue: true,
});
```

## Per-Upload Configuration

Override global settings per upload:

```tsx
const upload = await VideoUploader.upload({
  file: '/path/to/video.mp4',
  url: 'https://api.example.com/upload',
  
  // Override global settings
  requireWifi: true,
  retryAttempts: 5,
  priority: 'high',
});
```

## Queue Settings

### maxConcurrentUploads

Maximum number of simultaneous uploads.

```tsx
VideoUploadManager.configure({
  maxConcurrentUploads: 3,
});
```

**Default**: `2`

### queueMode

Queue processing mode: `'fifo'` or `'priority'`.

```tsx
VideoUploadManager.configure({
  queueMode: 'priority', // Process by priority
});
```

**Default**: `'fifo'`

### autoStart

Automatically start uploads when added to queue.

```tsx
VideoUploadManager.configure({
  autoStart: true,
});
```

**Default**: `true`

## Network Settings

### requireWifi

Only upload on WiFi connections.

```tsx
VideoUploadManager.configure({
  requireWifi: true,
});
```

**Default**: `false`

### allowCellular

Allow uploads on cellular networks.

```tsx
VideoUploadManager.configure({
  allowCellular: true,
});
```

**Default**: `true`

### cellularDataLimit

Maximum data to upload on cellular (in bytes).

```tsx
VideoUploadManager.configure({
  cellularDataLimit: 100 * 1024 * 1024, // 100 MB
});
```

**Default**: `undefined` (no limit)

### networkTracking

Enable network state monitoring.

```tsx
VideoUploadManager.configure({
  networkTracking: true,
});
```

**Default**: `true`

## Retry Settings

### retryAttempts

Number of retry attempts on failure.

```tsx
VideoUploadManager.configure({
  retryAttempts: 5,
});
```

**Default**: `3`

### retryDelay

Delay between retries (in milliseconds).

```tsx
VideoUploadManager.configure({
  retryDelay: 10000, // 10 seconds
});
```

**Default**: `5000` (5 seconds)

### retryBackoff

Enable exponential backoff for retries.

```tsx
VideoUploadManager.configure({
  retryBackoff: true, // 5s, 10s, 20s, 40s...
});
```

**Default**: `false`

## Multi-Part Settings

### chunkSize

Size of each chunk in multi-part uploads (in bytes).

```tsx
VideoUploadManager.configure({
  chunkSize: 10 * 1024 * 1024, // 10 MB
});
```

**Default**: `5 * 1024 * 1024` (5 MB)

### maxParallelUploads

Number of chunks to upload simultaneously.

```tsx
VideoUploadManager.configure({
  maxParallelUploads: 5,
});
```

**Default**: `3`

### verifyChunks

Verify chunks with checksums.

```tsx
VideoUploadManager.configure({
  verifyChunks: true,
});
```

**Default**: `false`

### checksumAlgorithm

Checksum algorithm: `'md5'` or `'sha256'`.

```tsx
VideoUploadManager.configure({
  checksumAlgorithm: 'sha256',
});
```

**Default**: `'md5'`

## Timeout Settings

### timeout

Upload timeout (in milliseconds).

```tsx
VideoUploadManager.configure({
  timeout: 600000, // 10 minutes
});
```

**Default**: `300000` (5 minutes)

### connectionTimeout

Connection timeout (in milliseconds).

```tsx
VideoUploadManager.configure({
  connectionTimeout: 30000, // 30 seconds
});
```

**Default**: `30000` (30 seconds)

## Storage Settings

### persistQueue

Persist queue across app restarts.

```tsx
VideoUploadManager.configure({
  persistQueue: true,
});
```

**Default**: `true`

### storageLocation

Custom storage location for queue data.

```tsx
VideoUploadManager.configure({
  storageLocation: '/custom/path/uploads',
});
```

**Default**: Platform default

### cleanupOnComplete

Automatically remove completed uploads.

```tsx
VideoUploadManager.configure({
  cleanupOnComplete: true,
  cleanupDelay: 3600000, // 1 hour
});
```

**Default**: `false`

## Logging

### logLevel

Set logging level: `'debug'`, `'info'`, `'warn'`, `'error'`, `'none'`.

```tsx
VideoUploadManager.configure({
  logLevel: 'debug',
});
```

**Default**: `'warn'`

### customLogger

Provide custom logger:

```tsx
VideoUploadManager.configure({
  customLogger: {
    debug: (msg) => console.log('[DEBUG]', msg),
    info: (msg) => console.log('[INFO]', msg),
    warn: (msg) => console.warn('[WARN]', msg),
    error: (msg) => console.error('[ERROR]', msg),
  },
});
```

## Complete Configuration Example

```tsx
import { VideoUploadManager } from 'react-native-video';

VideoUploadManager.configure({
  // Queue
  maxConcurrentUploads: 2,
  queueMode: 'priority',
  autoStart: true,
  
  // Network
  requireWifi: false,
  allowCellular: true,
  cellularDataLimit: 100 * 1024 * 1024,
  networkTracking: true,
  
  // Retry
  retryAttempts: 5,
  retryDelay: 5000,
  retryBackoff: true,
  
  // Multi-part
  chunkSize: 5 * 1024 * 1024,
  maxParallelUploads: 3,
  verifyChunks: true,
  checksumAlgorithm: 'md5',
  
  // Timeout
  timeout: 300000,
  connectionTimeout: 30000,
  
  // Storage
  persistQueue: true,
  cleanupOnComplete: true,
  cleanupDelay: 3600000,
  
  // Logging
  logLevel: 'info',
});
```

## Platform-Specific Configuration

### iOS

```tsx
VideoUploadManager.configure({
  ios: {
    backgroundSessionId: 'com.example.uploads',
    enableCellularAccess: true,
    allowsExpensiveNetworkAccess: false,
    allowsConstrainedNetworkAccess: false,
  },
});
```

### Android

```tsx
VideoUploadManager.configure({
  android: {
    notificationTitle: 'Uploading Videos',
    notificationIcon: 'ic_upload',
    foregroundService: true,
    wakeLock: true,
  },
});
```

## Environment-Based Configuration

```tsx
const isDev = __DEV__;

VideoUploadManager.configure({
  logLevel: isDev ? 'debug' : 'error',
  retryAttempts: isDev ? 1 : 5,
  timeout: isDev ? 60000 : 300000,
});
```

## Reset Configuration

Reset to defaults:

```tsx
VideoUploadManager.resetConfiguration();
```

## Get Current Configuration

```tsx
const config = VideoUploadManager.getConfiguration();
console.log(config);
```

## Best Practices

1. **Configure Once** - Configure at app startup
2. **Environment-Based** - Use different configs for dev/prod
3. **User Preferences** - Let users override key settings (WiFi-only)
4. **Platform-Specific** - Use platform-specific settings when needed
5. **Logging** - Use debug logging in development only
6. **Retry Strategy** - Enable backoff for production
7. **Cleanup** - Auto-cleanup completed uploads

## See Also

- [Basic Upload](./basic-upload.md) - Simple file uploads
- [Multi-Part Upload](./multi-part-upload.md) - Large file uploads
- [Queue Management](./queue-management.md) - Handle multiple uploads
- [Network Tracking](./network-tracking.md) - Network-aware uploads

---

## Getting Started

# Getting Started

Upload media files in the background with automatic retry, network tracking, and queue management.

## Overview

The Background Upload SDK enables:
- **Background Uploads** - Continue uploading when app is backgrounded
- **Automatic Retry** - Retry failed uploads automatically
- **Network Tracking** - Pause/resume based on connectivity
- **Queue Management** - Handle multiple uploads efficiently
- **Multi-Part Upload** - Upload large files in chunks *(Pro)*
- **Progress Tracking** - Monitor upload progress in real-time
- **Server Verification** - Verify upload completion on server

## Basic Example

```tsx
import { VideoUploader } from 'react-native-video';

// Simple upload
const upload = await VideoUploader.upload({
  file: '/path/to/video.mp4',
  url: 'https://api.example.com/upload',
});

// Monitor progress
upload.onProgress((progress) => {
  console.log(`Uploaded: ${progress.percentage}%`);
});

// Wait for completion
await upload.start();

console.log('Upload completed!', upload.response);
```

## Installation

The Background Upload SDK requires additional native setup:

### iOS

Add background modes to `Info.plist`:

```xml
UIBackgroundModes

  fetch
  processing

```

Add to your `Podfile`:

```ruby
pod 'RNVideoUploader', :path => '../node_modules/react-native-video/ios'
```

### Android

Add to `AndroidManifest.xml`:

```xml

  

```

## Quick Start

### 1. Create an Upload

```tsx
const upload = await VideoUploader.upload({
  file: '/path/to/video.mp4',
  url: 'https://api.example.com/upload',
  method: 'POST',
  headers: {
    'Authorization': 'Bearer token',
  },
  metadata: {
    title: 'My Video',
    description: 'Uploaded from mobile',
  },
});
```

### 2. Start Uploading

```tsx
// Start immediately
await upload.start();

// Or listen to events
upload.onProgress((progress) => {
  console.log(`${progress.bytesUploaded} / ${progress.totalBytes}`);
});

upload.onComplete((response) => {
  console.log('Upload completed!', response);
});

upload.onError((error) => {
  console.error('Upload failed:', error);
});

await upload.start();
```

### 3. Handle Response

```tsx
const upload = await VideoUploader.upload({
  file: '/path/to/video.mp4',
  url: 'https://api.example.com/upload',
});

upload.onComplete((response) => {
  console.log('Server response:', response.data);
  console.log('Video ID:', response.data.videoId);
});

await upload.start();
```

## Upload Manager

Manage multiple uploads with the Upload Manager:

```tsx
import { VideoUploadManager } from 'react-native-video';

// Get all uploads
const uploads = await VideoUploadManager.getAll();

// Find specific upload
const upload = await VideoUploadManager.findById(uploadId);

// Cancel upload
await VideoUploadManager.cancel(uploadId);

// Get total bytes uploaded
const totalUploaded = await VideoUploadManager.getTotalBytesUploaded();
```

## Upload States

Uploads progress through these states:

| State | Description |
|-------|-------------|
| `queued` | Waiting to start |
| `uploading` | Actively uploading |
| `paused` | Temporarily paused |
| `completed` | Successfully uploaded |
| `failed` | Upload failed |
| `cancelled` | User cancelled |

```tsx
upload.onStateChange((state) => {
  switch (state) {
    case 'queued':
      console.log('Waiting to start...');
      break;
    case 'uploading':
      console.log('Uploading...');
      break;
    case 'completed':
      console.log('Upload complete!');
      break;
    case 'failed':
      console.log('Upload failed');
      break;
  }
});
```

## Network Tracking

Automatically pause/resume uploads based on connectivity:

```tsx
const upload = await VideoUploader.upload({
  file: '/path/to/video.mp4',
  url: 'https://api.example.com/upload',
  networkTracking: true, // Auto-pause when offline
  requireWifi: false, // Allow cellular uploads
});

upload.onNetworkChange((state) => {
  console.log('Network:', state.isConnected ? 'Online' : 'Offline');
  console.log('Type:', state.type); // 'wifi', 'cellular', 'ethernet'
});
```

## Automatic Retry

Uploads automatically retry on failure:

```tsx
const upload = await VideoUploader.upload({
  file: '/path/to/video.mp4',
  url: 'https://api.example.com/upload',
  retryAttempts: 3,
  retryDelay: 5000, // 5 seconds
});

upload.onRetry((attempt) => {
  console.log(`Retrying upload, attempt ${attempt}/3`);
});
```

## Next Steps

- [Basic Upload](./basic-upload.md) - Simple file uploads
- [Multi-Part Upload](./multi-part-upload.md) - Large file uploads *(Pro)*
- [Queue Management](./queue-management.md) - Handle multiple uploads
- [Network Tracking](./network-tracking.md) - Network-aware uploads
- [Configuration](./configuration.md) - Configure upload behavior

---

## Multi-Part Upload

# Multi-Part Upload

Upload large files in chunks with automatic retry and resumability.

:::tip Pro Feature
Multi-part uploads require a Pro license.
:::

## Overview

Multi-part uploads enable:
- **Large File Support** - Upload files of any size
- **Resumable Uploads** - Resume from where it left off
- **Parallel Chunks** - Upload multiple chunks simultaneously
- **Automatic Retry** - Retry failed chunks individually
- **Progress Tracking** - Track overall and per-chunk progress

## Basic Multi-Part Upload

```tsx
import { VideoUploader } from 'react-native-video';

const upload = await VideoUploader.upload({
  file: '/path/to/large-video.mp4',
  url: 'https://api.example.com/upload',
  multipart: true,
  chunkSize: 5 * 1024 * 1024, // 5 MB chunks
});

await upload.start();
```

## Configuration

### chunkSize

Size of each chunk in bytes.

```tsx
const upload = await VideoUploader.upload({
  file: '/path/to/video.mp4',
  url: 'https://api.example.com/upload',
  multipart: true,
  chunkSize: 10 * 1024 * 1024, // 10 MB
});
```

**Default**: `5 * 1024 * 1024` (5 MB)

### maxParallelUploads

Number of chunks to upload simultaneously.

```tsx
const upload = await VideoUploader.upload({
  file: '/path/to/video.mp4',
  url: 'https://api.example.com/upload',
  multipart: true,
  maxParallelUploads: 3, // Upload 3 chunks at once
});
```

**Default**: `3`

### uploadId

Custom upload ID for resuming uploads.

```tsx
const upload = await VideoUploader.upload({
  file: '/path/to/video.mp4',
  url: 'https://api.example.com/upload',
  multipart: true,
  uploadId: 'my-unique-upload-id',
});
```

## Server Integration

### Initiate Upload

The SDK first initiates the multi-part upload:

```tsx
// 1. SDK sends POST to initiate
POST https://api.example.com/upload/initiate
{
  "filename": "video.mp4",
  "fileSize": 104857600,
  "chunkSize": 5242880
}

// 2. Server responds with uploadId
{
  "uploadId": "abc123",
  "chunkCount": 20
}
```

### Upload Chunks

Each chunk is uploaded separately:

```tsx
// SDK uploads each chunk
PUT https://api.example.com/upload/chunk
Headers:
  X-Upload-Id: abc123
  X-Chunk-Index: 0
  X-Chunk-Count: 20
  Content-Type: application/octet-stream

Body: [chunk data]

// Server responds
{
  "chunkIndex": 0,
  "status": "received"
}
```

### Complete Upload

After all chunks are uploaded:

```tsx
// SDK sends completion request
POST https://api.example.com/upload/complete
{
  "uploadId": "abc123"
}

// Server merges chunks and responds
{
  "videoId": "video123",
  "url": "https://cdn.example.com/video123.mp4"
}
```

## Progress Tracking

Track overall and per-chunk progress:

```tsx
const upload = await VideoUploader.upload({
  file: '/path/to/video.mp4',
  url: 'https://api.example.com/upload',
  multipart: true,
});

// Overall progress
upload.onProgress((progress) => {
  console.log(`Overall: ${progress.percentage}%`);
  console.log(`Chunks: ${progress.chunksUploaded} / ${progress.totalChunks}`);
  console.log(`Speed: ${(progress.speed / 1024 / 1024).toFixed(2)} MB/s`);
});

// Per-chunk progress
upload.onChunkProgress((chunkProgress) => {
  console.log(`Chunk ${chunkProgress.index}: ${chunkProgress.percentage}%`);
});

await upload.start();
```

## Resumable Uploads

Resume uploads after interruption:

```tsx
// Start upload
const upload = await VideoUploader.upload({
  file: '/path/to/video.mp4',
  url: 'https://api.example.com/upload',
  multipart: true,
  uploadId: 'my-upload-123',
});

// Upload interrupted...

// Later, resume with same uploadId
const resumed = await VideoUploader.resume('my-upload-123');

await resumed.start();
```

### Automatic Resume

Enable automatic resume on app restart:

```tsx
const upload = await VideoUploader.upload({
  file: '/path/to/video.mp4',
  url: 'https://api.example.com/upload',
  multipart: true,
  autoResume: true,
});
```

## Chunk Retry

Failed chunks are automatically retried:

```tsx
const upload = await VideoUploader.upload({
  file: '/path/to/video.mp4',
  url: 'https://api.example.com/upload',
  multipart: true,
  chunkRetryAttempts: 5,
  chunkRetryDelay: 3000, // 3 seconds
});

upload.onChunkRetry((chunk, attempt) => {
  console.log(`Retrying chunk ${chunk.index}, attempt ${attempt}`);
});
```

## Verification

Verify chunks on server:

```tsx
const upload = await VideoUploader.upload({
  file: '/path/to/video.mp4',
  url: 'https://api.example.com/upload',
  multipart: true,
  verifyChunks: true, // Server verifies each chunk
  checksumAlgorithm: 'md5', // 'md5' or 'sha256'
});
```

Server should respond with checksum:

```tsx
// Server response for each chunk
{
  "chunkIndex": 0,
  "status": "received",
  "checksum": "5d41402abc4b2a76b9719d911017c592"
}
```

## Custom Endpoints

Use different endpoints for each operation:

```tsx
const upload = await VideoUploader.upload({
  file: '/path/to/video.mp4',
  multipart: true,
  endpoints: {
    initiate: 'https://api.example.com/upload/init',
    uploadChunk: 'https://api.example.com/upload/chunk',
    complete: 'https://api.example.com/upload/finish',
    abort: 'https://api.example.com/upload/cancel',
  },
});
```

## Abort Upload

Cancel multi-part upload:

```tsx
await upload.abort(); // Notifies server to clean up chunks
```

## Complete Example

```tsx
import React, { useState, useEffect } from 'react';
import { View, Text, Button, ProgressBar } from 'react-native';
import { VideoUploader } from 'react-native-video';

function MultiPartUploadExample({ filePath, fileSize }) {
  const [upload, setUpload] = useState(null);
  const [progress, setProgress] = useState(0);
  const [chunksProgress, setChunksProgress] = useState({});
  const [state, setState] = useState('idle');

  const startUpload = async () => {
    const ul = await VideoUploader.upload({
      file: filePath,
      url: 'https://api.example.com/upload',
      multipart: true,
      chunkSize: 5 * 1024 * 1024, // 5 MB
      maxParallelUploads: 3,
      autoResume: true,
      verifyChunks: true,
    });

    ul.onProgress((prog) => {
      setProgress(prog.percentage);
    });

    ul.onChunkProgress((chunkProg) => {
      setChunksProgress(prev => ({
        ...prev,
        [chunkProg.index]: chunkProg.percentage,
      }));
    });

    ul.onStateChange((s) => setState(s));

    ul.onChunkRetry((chunk, attempt) => {
      console.log(`Retrying chunk ${chunk.index}, attempt ${attempt}`);
    });

    ul.onComplete((response) => {
      console.log('Upload completed!', response.data);
    });

    ul.onError((error) => {
      console.error('Upload failed:', error);
    });

    setUpload(ul);
    await ul.start();
  };

  return (
    
      File Size: {(fileSize / 1024 / 1024).toFixed(2)} MB
      State: {state}
      Progress: {progress}%

      

      {upload && (
        
          Chunks Progress:
          {Object.entries(chunksProgress).map(([index, prog]) => (
            
              Chunk {index}: 
              
              {prog}%
            
          ))}
        
      )}

      {state === 'idle' && (
        
      )}

      {state === 'uploading' && upload && (
         upload.pause()} />
      )}

      {state === 'paused' && upload && (
         upload.resume()} />
      )}

      {state === 'uploading' && upload && (
         upload.abort()} color="red" />
      )}
    
  );
}
```

## Server Implementation Example

Basic Node.js/Express server for multi-part uploads:

```js
// Initiate upload
app.post('/upload/initiate', (req, res) => {
  const { filename, fileSize, chunkSize } = req.body;
  const uploadId = generateUploadId();
  const chunkCount = Math.ceil(fileSize / chunkSize);
  
  // Store upload metadata
  uploads[uploadId] = {
    filename,
    fileSize,
    chunkSize,
    chunkCount,
    receivedChunks: [],
  };
  
  res.json({ uploadId, chunkCount });
});

// Upload chunk
app.put('/upload/chunk', (req, res) => {
  const uploadId = req.headers['x-upload-id'];
  const chunkIndex = parseInt(req.headers['x-chunk-index']);
  
  // Save chunk to disk
  const chunkPath = `./uploads/${uploadId}/chunk-${chunkIndex}`;
  fs.writeFileSync(chunkPath, req.body);
  
  // Calculate checksum
  const checksum = calculateMD5(req.body);
  
  // Track received chunk
  uploads[uploadId].receivedChunks.push(chunkIndex);
  
  res.json({ chunkIndex, status: 'received', checksum });
});

// Complete upload
app.post('/upload/complete', async (req, res) => {
  const { uploadId } = req.body;
  const upload = uploads[uploadId];
  
  // Merge all chunks
  const outputPath = `./videos/${upload.filename}`;
  await mergeChunks(uploadId, upload.chunkCount, outputPath);
  
  // Clean up chunks
  await cleanupChunks(uploadId);
  
  res.json({
    videoId: uploadId,
    url: `https://cdn.example.com/${uploadId}.mp4`,
  });
});
```

## Best Practices

1. **Chunk Size** - Use 5-10 MB chunks for optimal performance
2. **Parallel Uploads** - Limit to 3-5 parallel chunks
3. **Verification** - Always verify chunks with checksums
4. **Auto Resume** - Enable for better UX
5. **Error Handling** - Implement chunk-level retry logic
6. **Server Cleanup** - Clean up orphaned chunks periodically

## See Also

- [Basic Upload](./basic-upload.md) - Simple file uploads
- [Queue Management](./queue-management.md) - Handle multiple uploads
- [Configuration](./configuration.md) - Upload configuration

---

## Network Tracking

# Network Tracking

Automatically manage uploads based on network connectivity and type.

## Overview

Network tracking provides:
- **Auto Pause/Resume** - Pause when offline, resume when back online
- **Connection Type** - Detect WiFi, cellular, ethernet
- **Cellular Control** - Restrict uploads to WiFi only
- **Network Quality** - Adapt to connection speed
- **Bandwidth Monitoring** - Track network usage

## Basic Network Tracking

```tsx
import { VideoUploader } from 'react-native-video';

const upload = await VideoUploader.upload({
  file: '/path/to/video.mp4',
  url: 'https://api.example.com/upload',
  networkTracking: true, // Enable network tracking
});

upload.onNetworkChange((state) => {
  console.log('Network:', state.isConnected ? 'Online' : 'Offline');
  console.log('Type:', state.type); // 'wifi', 'cellular', 'ethernet'
});

await upload.start();
```

## WiFi Only

Restrict uploads to WiFi:

```tsx
const upload = await VideoUploader.upload({
  file: '/path/to/video.mp4',
  url: 'https://api.example.com/upload',
  requireWifi: true, // Only upload on WiFi
});

upload.onNetworkChange((state) => {
  if (state.type === 'cellular') {
    console.log('Waiting for WiFi...');
  }
});
```

## Cellular Data Limit

Limit cellular data usage:

```tsx
const upload = await VideoUploader.upload({
  file: '/path/to/video.mp4',
  url: 'https://api.example.com/upload',
  allowCellular: true,
  cellularDataLimit: 50 * 1024 * 1024, // 50 MB max on cellular
});
```

## Network Events

Listen to network state changes:

```tsx
upload.onNetworkChange((state) => {
  console.log('Connected:', state.isConnected);
  console.log('Type:', state.type); // 'wifi', 'cellular', 'ethernet', 'none'
  console.log('Quality:', state.quality); // 'excellent', 'good', 'fair', 'poor'
  console.log('Speed:', state.estimatedSpeed); // bytes per second
});
```

### Network State Object

```ts
interface NetworkState {
  isConnected: boolean;
  type: 'wifi' | 'cellular' | 'ethernet' | 'none';
  quality: 'excellent' | 'good' | 'fair' | 'poor';
  estimatedSpeed: number; // bytes per second
}
```

## Automatic Pause/Resume

Uploads automatically pause when offline:

```tsx
const upload = await VideoUploader.upload({
  file: '/path/to/video.mp4',
  url: 'https://api.example.com/upload',
  networkTracking: true,
  autoPauseOnDisconnect: true, // Auto-pause when offline
  autoResumeOnConnect: true, // Auto-resume when back online
});

upload.onStateChange((state) => {
  console.log('State:', state);
  // 'uploading' → 'paused' (when offline) → 'uploading' (when back online)
});
```

## Connection Type Detection

Check current connection:

```tsx
import { VideoUploadManager } from 'react-native-video';

const networkState = await VideoUploadManager.getNetworkState();

if (networkState.type === 'wifi') {
  console.log('Connected to WiFi');
} else if (networkState.type === 'cellular') {
  console.log('Connected to cellular');
}
```

## Network Quality Adaptation

Adapt upload based on network quality:

```tsx
const upload = await VideoUploader.upload({
  file: '/path/to/video.mp4',
  url: 'https://api.example.com/upload',
  multipart: true,
  adaptToNetworkQuality: true,
});

upload.onNetworkChange((state) => {
  if (state.quality === 'poor') {
    console.log('Reducing chunk size for poor connection');
    // SDK automatically adjusts chunk size
  }
});
```

## Bandwidth Monitoring

Track bandwidth usage:

```tsx
upload.onBandwidthUpdate((bandwidth) => {
  console.log(`Upload speed: ${(bandwidth.speed / 1024 / 1024).toFixed(2)} MB/s`);
  console.log(`Total uploaded: ${(bandwidth.totalBytes / 1024 / 1024).toFixed(2)} MB`);
});
```

## Network Permissions

### iOS

No additional permissions required.

### Android

Add to `AndroidManifest.xml`:

```xml

```

## Complete Example

```tsx
import React, { useState, useEffect } from 'react';
import { View, Text, Switch, Button } from 'react-native';
import { VideoUploader, VideoUploadManager } from 'react-native-video';

function NetworkAwareUpload({ filePath }) {
  const [upload, setUpload] = useState(null);
  const [networkState, setNetworkState] = useState(null);
  const [wifiOnly, setWifiOnly] = useState(false);

  useEffect(() => {
    const checkNetwork = async () => {
      const state = await VideoUploadManager.getNetworkState();
      setNetworkState(state);
    };

    checkNetwork();
    const interval = setInterval(checkNetwork, 5000);
    return () => clearInterval(interval);
  }, []);

  const startUpload = async () => {
    const ul = await VideoUploader.upload({
      file: filePath,
      url: 'https://api.example.com/upload',
      networkTracking: true,
      requireWifi: wifiOnly,
      autoPauseOnDisconnect: true,
      autoResumeOnConnect: true,
    });

    ul.onNetworkChange((state) => {
      setNetworkState(state);
      
      if (!state.isConnected) {
        console.log('Network disconnected - upload paused');
      } else if (state.type === 'cellular' && wifiOnly) {
        console.log('Waiting for WiFi connection...');
      } else {
        console.log('Network available - upload active');
      }
    });

    ul.onBandwidthUpdate((bandwidth) => {
      console.log(`Speed: ${(bandwidth.speed / 1024 / 1024).toFixed(2)} MB/s`);
    });

    setUpload(ul);
    await ul.start();
  };

  return (
    
      
        Network Status
        {networkState && (
          
            
              Status: {networkState.isConnected ? '✅ Connected' : '❌ Disconnected'}
            
            Type: {networkState.type}
            Quality: {networkState.quality}
            {networkState.estimatedSpeed && (
              
                Speed: {(networkState.estimatedSpeed / 1024 / 1024).toFixed(2)} MB/s
              
            )}
          
        )}
      

      
        WiFi Only:
        
      

      {networkState?.type === 'cellular' && wifiOnly && (
        
          ⚠️ Upload will wait for WiFi connection
        
      )}

      
    
  );
}
```

## Network Strategies

### Conservative (WiFi Only)

Best for large files or limited data plans:

```tsx
const upload = await VideoUploader.upload({
  file: '/path/to/large-video.mp4',
  url: 'https://api.example.com/upload',
  requireWifi: true,
});
```

### Balanced (Cellular with Limit)

Allow cellular with data limit:

```tsx
const upload = await VideoUploader.upload({
  file: '/path/to/video.mp4',
  url: 'https://api.example.com/upload',
  allowCellular: true,
  cellularDataLimit: 100 * 1024 * 1024, // 100 MB
});
```

### Aggressive (Any Connection)

Upload immediately on any connection:

```tsx
const upload = await VideoUploader.upload({
  file: '/path/to/video.mp4',
  url: 'https://api.example.com/upload',
  allowCellular: true,
  networkTracking: true,
});
```

## Best Practices

1. **WiFi for Large Files** - Require WiFi for files > 100 MB
2. **Auto Pause/Resume** - Always enable for better UX
3. **User Preference** - Let users choose WiFi-only mode
4. **Data Limits** - Set reasonable cellular data limits
5. **Network Feedback** - Show network status to users
6. **Quality Adaptation** - Enable for better reliability

## See Also

- [Basic Upload](./basic-upload.md) - Simple file uploads
- [Queue Management](./queue-management.md) - Handle multiple uploads
- [Configuration](./configuration.md) - Upload configuration

---

## Queue Management

# Queue Management

Manage multiple uploads efficiently with queue system and prioritization.

## Overview

Queue management provides:
- **Automatic Queuing** - Queue uploads when limit is reached
- **Priority Support** - Prioritize important uploads
- **Concurrent Limit** - Control simultaneous uploads
- **Queue Persistence** - Survive app restarts
- **Batch Operations** - Pause/resume/cancel multiple uploads

## Basic Queue

```tsx
import { VideoUploader } from 'react-native-video';

// Uploads are automatically queued
const upload1 = await VideoUploader.upload({
  file: '/path/to/video1.mp4',
  url: 'https://api.example.com/upload',
});

const upload2 = await VideoUploader.upload({
  file: '/path/to/video2.mp4',
  url: 'https://api.example.com/upload',
});

const upload3 = await VideoUploader.upload({
  file: '/path/to/video3.mp4',
  url: 'https://api.example.com/upload',
});

// All start automatically based on queue configuration
```

## Queue Configuration

Configure queue behavior globally:

```tsx
import { VideoUploadManager } from 'react-native-video';

VideoUploadManager.configure({
  maxConcurrentUploads: 2, // Upload 2 files at once
  queueMode: 'fifo', // 'fifo' or 'priority'
  autoStart: true, // Auto-start queued uploads
});
```

## Priority-Based Queue

Assign priorities to uploads:

```tsx
// High priority upload (starts first)
const urgentUpload = await VideoUploader.upload({
  file: '/path/to/urgent.mp4',
  url: 'https://api.example.com/upload',
  priority: 'high', // 'high', 'medium', 'low'
});

// Medium priority
const normalUpload = await VideoUploader.upload({
  file: '/path/to/normal.mp4',
  url: 'https://api.example.com/upload',
  priority: 'medium',
});

// Low priority (starts last)
const backgroundUpload = await VideoUploader.upload({
  file: '/path/to/background.mp4',
  url: 'https://api.example.com/upload',
  priority: 'low',
});
```

## Queue Operations

### Get All Uploads

```tsx
const uploads = await VideoUploadManager.getAll();

uploads.forEach(upload => {
  console.log(upload.id, upload.state, upload.progress);
});
```

### Get Queue Status

```tsx
const status = await VideoUploadManager.getQueueStatus();

console.log(status);
// {
//   total: 10,
//   uploading: 2,
//   queued: 5,
//   paused: 2,
//   completed: 1,
//   failed: 0
// }
```

### Pause All

```tsx
await VideoUploadManager.pauseAll();
```

### Resume All

```tsx
await VideoUploadManager.resumeAll();
```

### Cancel All

```tsx
await VideoUploadManager.cancelAll();
```

## Filter Uploads

### By State

```tsx
const uploads = await VideoUploadManager.getAll();

// Only uploading
const uploading = uploads.filter(u => u.state === 'uploading');

// Only queued
const queued = uploads.filter(u => u.state === 'queued');

// Failed uploads
const failed = uploads.filter(u => u.state === 'failed');
```

### By Priority

```tsx
const highPriority = uploads.filter(u => u.priority === 'high');
```

### By Metadata

```tsx
const userUploads = uploads.filter(
  u => u.metadata?.userId === 'user123'
);
```

## Queue Events

Listen to queue-level events:

```tsx
VideoUploadManager.onQueueChange((status) => {
  console.log('Queue status:', status);
  // {
  //   total: 10,
  //   uploading: 2,
  //   queued: 5,
  //   ...
  // }
});

VideoUploadManager.onUploadStart((upload) => {
  console.log('Upload started:', upload.id);
});

VideoUploadManager.onUploadComplete((upload) => {
  console.log('Upload completed:', upload.id);
});

VideoUploadManager.onUploadFailed((upload, error) => {
  console.error('Upload failed:', upload.id, error);
});
```

## Batch Upload

Upload multiple files at once:

```tsx
const files = [
  '/path/to/video1.mp4',
  '/path/to/video2.mp4',
  '/path/to/video3.mp4',
];

const uploads = await VideoUploadManager.batchUpload({
  files,
  url: 'https://api.example.com/upload',
  headers: {
    'Authorization': 'Bearer token',
  },
});

// Track batch progress
VideoUploadManager.onBatchProgress((progress) => {
  console.log(`Batch: ${progress.completed} / ${progress.total}`);
});
```

## Queue Persistence

Queue persists across app restarts:

```tsx
// On app start, resume pending uploads
useEffect(() => {
  const resumePendingUploads = async () => {
    const uploads = await VideoUploadManager.getAll();
    const pending = uploads.filter(
      u => ['uploading', 'paused', 'queued'].includes(u.state)
    );
    
    for (const upload of pending) {
      await upload.resume();
    }
  };
  
  resumePendingUploads();
}, []);
```

## Queue Strategies

### FIFO (First In, First Out)

```tsx
VideoUploadManager.configure({
  queueMode: 'fifo',
});

// Uploads process in order added
```

### Priority-Based

```tsx
VideoUploadManager.configure({
  queueMode: 'priority',
});

// Uploads process by priority: high → medium → low
```

### Custom Strategy

```tsx
VideoUploadManager.configure({
  queueMode: 'custom',
  queueComparator: (a, b) => {
    // Custom sorting logic
    // Sort by file size (smallest first)
    return a.fileSize - b.fileSize;
  },
});
```

## Complete Example

```tsx
import React, { useState, useEffect } from 'react';
import { View, Text, FlatList, Button } from 'react-native';
import { VideoUploadManager } from 'react-native-video';

function UploadQueueScreen() {
  const [uploads, setUploads] = useState([]);
  const [queueStatus, setQueueStatus] = useState(null);

  useEffect(() => {
    loadUploads();
    
    const unsubscribe = VideoUploadManager.onQueueChange((status) => {
      setQueueStatus(status);
      loadUploads();
    });
    
    return () => unsubscribe();
  }, []);

  const loadUploads = async () => {
    const all = await VideoUploadManager.getAll();
    setUploads(all);
  };

  const addUpload = async (filePath, priority = 'medium') => {
    await VideoUploader.upload({
      file: filePath,
      url: 'https://api.example.com/upload',
      priority,
    });
  };

  const pauseAll = async () => {
    await VideoUploadManager.pauseAll();
  };

  const resumeAll = async () => {
    await VideoUploadManager.resumeAll();
  };

  const clearCompleted = async () => {
    const completed = uploads.filter(u => u.state === 'completed');
    for (const upload of completed) {
      await VideoUploadManager.remove(upload.id);
    }
    loadUploads();
  };

  return (
    
      {queueStatus && (
        
          Total: {queueStatus.total}
          Uploading: {queueStatus.uploading}
          Queued: {queueStatus.queued}
          Completed: {queueStatus.completed}
        
      )}

      
        
        
        
      

       (
          
            {item.fileName}
            State: {item.state}
            Priority: {item.priority}
            {item.progress && (
              Progress: {item.progress.percentage}%
            )}
            
            
              {item.state === 'uploading' && (
                 item.pause()} />
              )}
              {item.state === 'paused' && (
                 item.resume()} />
              )}
              {item.state !== 'completed' && (
                 item.cancel()} 
                  color="red"
                />
              )}
            
          
        )}
      />
    
  );
}
```

## Best Practices

1. **Concurrent Limit** - Set to 2-3 for optimal performance
2. **Priority** - Use priorities for user-initiated uploads
3. **Persistence** - Resume pending uploads on app start
4. **Cleanup** - Remove completed uploads periodically
5. **User Control** - Allow users to pause/resume/cancel
6. **Status Updates** - Show queue status to users

## See Also

- [Basic Upload](./basic-upload.md) - Simple file uploads
- [Network Tracking](./network-tracking.md) - Network-aware uploads
- [Configuration](./configuration.md) - Upload configuration

---

## Expo Plugin

# Expo Plugin

The `react-native-video` library provides an Expo plugin to simplify the integration and configuration of specific features into your Expo project.

## Installation

To use the Expo plugin, you need to add it to your app's configuration file (`app.json` or `app.config.js`).

```json title="app.json"
{
  "expo": {
    "plugins": [
      [
        "react-native-video",
        {
          "enableAndroidPictureInPicture": true,
          "enableBackgroundAudio": true,
          "androidExtensions": {
            "useExoplayerDash": true,
            "useExoplayerHls": true
          }
        }
      ]
    ]
  }
}
```

```javascript title="app.config.js"
export default {
  plugins: [
    [
      'react-native-video',
      {
        enableAndroidPictureInPicture: true,
        enableBackgroundAudio: true,
        androidExtensions: {
          useExoplayerDash: true,
          useExoplayerHls: true,
        },
      },
    ],
  ],
};
```

## Configuration Options

The plugin accepts an optional configuration object with the following properties:

### `enableAndroidPictureInPicture` (optional)

-   **Type:** `boolean`
-   **Default:** `false`
-   **Description:** Enables Picture-in-Picture (PiP) mode on Android. This will apply the necessary configurations to your Android project.

### `enableBackgroundAudio` (optional)

-   **Type:** `boolean`
-   **Default:** `false`
-   **Description:** Enables audio playback to continue when the app is in the background on Android. Ensure you have also configured the necessary background modes capabilities in your app if required by the operating system.

### `androidExtensions` (optional)

-   **Type:** `object`
-   **Default:** `{ useExoplayerDash: true, useExoplayerHls: true }`
-   **Description:** Allows you to specify which Android ExoPlayer extensions to include. This can help reduce the size of your app by only including the extensions you need.
    -   `useExoplayerDash` (boolean, default: `true`): Whether to include ExoPlayer's Dash extension.
    -   `useExoplayerHls` (boolean, default: `true`): Whether to include ExoPlayer's HLS extension.

### `reactNativeTestApp` (optional)

-   **Type:** `boolean`
-   **Default:** `false`
-   **Description:** Whether to use `react-native-test-app` compatible mode.

## Usage

Once configured in your `app.json` or `app.config.js`, the plugin will automatically apply the necessary native project changes during the prebuild process (e.g., when running `npx expo prebuild`). No further manual setup is typically required for these features.

---

## Manual Configuration

# Manual Configuration

If you prefer not to use the Expo plugin you can configure **react-native-video** manually by editing the native project files directly.  The steps below show the exact changes performed by the plugin so you can reproduce them in a plain React Native or bare Expo project.

---

## iOS

### Enable Background Audio
To allow video sound to continue when the app goes to the background add the `audio` mode to `Info.plist`:

```xml title="ios/YourApp/Info.plist"
UIBackgroundModes

  audio

```

## Android

### Configure ExoPlayer extensions
By default the library enables DASH & HLS extensions.  You can fine-tune this by adding properties to **gradle.properties**:

```properties title="android/gradle.properties"
# Enable / disable ExoPlayer extensions used by react-native-video
RNVideo_useExoplayerDash=true   # DASH playback support
RNVideo_useExoplayerHls=true    # HLS  playback support
```
Set a value to `false` to exclude the corresponding extension and reduce APK size.

### Enable Picture-in-Picture (PiP)
Add the `android:supportsPictureInPicture` flag to your *main* activity in **AndroidManifest.xml**:

```xml title="android/app/src/main/AndroidManifest.xml"

  
    
  

```

PiP requires **API 26+** (Android 8.0). Make sure `minSdkVersion` is at least `26` when enabling this feature.

## Verification
After the modifications:

1. **iOS** – run `cd ios && pod install` then build the app from Xcode or via `npx react-native run-ios` / `npx expo run:ios`.
2. **Android** – clean & rebuild the project: `./gradlew clean && ./gradlew :app:assembleDebug` or simply run `npx react-native run-android` / `npx expo run:android`.

If the build succeeds your manual configuration is complete.

---

### Need an easier way?
Use the [Expo plugin](./expo-plugin.md) to apply exactly the same changes automatically during `expo prebuild`.

---

## Installation

# Installation

React Native Video is a library that allows you to play various kinds of video in a React Native application. It is built on top of the [`react-native-nitro-modules`](https://nitro.margelo.com/docs/what-is-nitro) framework, giving it type-safety and blazing fast communication across Native and JavaScript threads. React Native Video supports both the New Architecture and the Old Architecture.

## Requirements

### System Requirements
- iOS `15.0` or higher
- Android `6.0` or higher

### Minimal Package Requirements
- `react-native` `0.75.0` or higher
- `react-native-nitro-modules` `0.27.2` or higher 

## Installation

1. Install dependencies:
```bash
npm install react-native-video@next react-native-nitro-modules
```

2. Configure Library:
You can configure the library in two ways:
- [Using expo plugins](./configuration/expo-plugin.md)
- [Manually editing needed files](./configuration/manual.md)

3. Run the project:
If you are using Expo, you will need to generate native files:
```bash
npx expo prebuild
```

And then run the project:
```bash
npx expo run:ios # run on iOS
npx expo run:android # run on Android
```

If you are using React Native CLI, you will need to install Pods for iOS:
```bash
cd ios && pod install && cd ..
```

And then run the project:
```bash
npx react-native run-ios # run on iOS
npx react-native run-android # run on Android
```

## Patch for react-native 
  For `react-native-nitro-modules` 0.27.X or higher

  ```diff
  diff --git a/node_modules/react-native-nitro-modules/cpp/core/HybridFunction.hpp b/node_modules/react-native-nitro-modules/cpp/core/HybridFunction.hpp
  index efcea05..ffad3f2 100644
  --- a/node_modules/react-native-nitro-modules/cpp/core/HybridFunction.hpp
  +++ b/node_modules/react-native-nitro-modules/cpp/core/HybridFunction.hpp
  @@ -23,6 +23,10 @@ struct JSIConverter;
  #include 
  #include 

  +#ifdef ANDROID
  +#include 
  +#endif
  +
  namespace margelo::nitro {

  using namespace facebook;
  @@ -109,6 +113,15 @@ public:
          std::string funcName = getHybridFuncFullName(kind, name, hybridInstance.get());
          std::string message = exception.what();
          throw jsi::JSError(runtime, funcName + ": " + message);
  +#ifdef ANDROID
  +#pragma clang diagnostic push
  +#pragma clang diagnostic ignored "-Wexceptions"
  +      } catch (const jni::JniException& exception) {
  +        std::string funcName = getHybridFuncFullName(kind, name, hybridInstance.get());
  +        std::string message = exception.what();
  +        throw jsi::JSError(runtime, funcName + ": " + message);
  +#pragma clang diagnostic pop
  +#endif
        } catch (...) {
          // Some unknown exception was thrown - add method name information and re-throw as `JSError`.
          std::string funcName = getHybridFuncFullName(kind, name, hybridInstance.get());
  ```

  see [raw](https://github.com/TheWidlarzGroup/react-native-video/blob/v7/example/patches/react-native-nitro-modules%2B0.27.2.patch)

## Usage

```tsx title="App.tsx"
import { VideoView, useVideoPlayer } from 'react-native-video';

export default function App() {
  const player = useVideoPlayer({
    source: {
      uri: 'https://www.w3schools.com/html/mov_bbb.mp4',
    },
  });

  return ;
}
```

---

## Intro

# Intro

**One of the most popular video playback libraries for React Native applications.**

`react-native-video` provides a comprehensive solution for video playback in React Native, built on top of the [`react-native-nitro-modules`](https://nitro.margelo.com/docs/what-is-nitro) framework. Whether you're building a video streaming app, media player, or educational platform, `react-native-video` gives you the tools you need to create exceptional video experiences.

## Why Choose `react-native-video`?

### Native Performance
`react-native-video` is built with native video players (AVPlayer on iOS, ExoPlayer on Android) to ensure hardware-accelerated playback for smooth performance. The library includes optimized memory management and resource handling to provide the best possible user experience.

### Rich Feature Set
The library offers advanced playback controls including play, pause, seek, volume control, and playback rate adjustment. It supports multiple source types including HTTP/HTTPS streams, local files, HLS, and DASH. `react-native-video` includes subtitle support for both built-in and external subtitle files (WebVTT, SRT), native Picture-in-Picture support on both platforms, background audio playback and native fullscreen implementation.

### Developer Experience
`react-native-video` is TypeScript-first with full TypeScript support and comprehensive type definitions. It provides intuitive React hooks for easy integration. The library is compatible with React Native's New Architecture and works seamlessly with Expo managed and bare workflows.

## Quick Start

Get started in minutes with a simple video player:

```bash
npm install react-native-video@next react-native-nitro-modules
```

```tsx
import { VideoView, useVideoPlayer } from 'react-native-video';

export default function App() {
  const player = useVideoPlayer({
    uri: 'https://www.w3schools.com/html/mov_bbb.mp4',
  });

  return ;
}
```

## What's Next?

- **[Installation Guide](./installation.md)** - Get started with `react-native-video`
- **[useVideoPlayer](../players/player.md)** - Learn how to create and use video players
- **[VideoView Component](../video-view/getting-started.md)** - Understand the video display component
- **[Event Handling](../players/events/useEvent.md)** - Master player events and callbacks
- **[Configuration](./configuration/expo-plugin.md)** - Configure the player

[![React Native Video](../../static/baners/rnv-banner.png)](https://www.thewidlarzgroup.com/react-native-video/?utm_source=rnv&utm_medium=docs&utm_campaign=intro&utm_id=rnv-banner)

---

## FreeWheel

# FreeWheel

Enterprise-grade ad management with FreeWheel platform.

:::tip Pro Feature - Coming Soon
FreeWheel integration is a Pro feature currently in development.
:::

## Overview

FreeWheel provides:
- **Enterprise Ad Management** - Complete ad workflow
- **Multi-Platform** - Web, mobile, CTV, STB
- **Advanced Targeting** - Sophisticated audience targeting
- **Yield Optimization** - Maximize ad revenue
- **Real-Time Decisioning** - Dynamic ad insertion
- **Comprehensive Analytics** - Detailed reporting

## Basic Setup

```tsx
import { useVideoPlayer, VideoView } from 'react-native-video';

const player = useVideoPlayer({
  source: {
    uri: 'https://example.com/video.mp4',
  },
  ads: {
    enabled: true,
    provider: 'freewheel',
    networkId: 'your-network-id',
    serverUrl: 'https://your-freewheel-server.com',
  },
});

return ;
```

## Configuration

### Network Configuration

```tsx
ads: {
  enabled: true,
  provider: 'freewheel',
  networkId: '123456',
  serverUrl: 'https://demo.v.fwmrm.net/ad/g/1',
  profileId: 'your-profile-id',
  sectionId: 'your-section-id',
}
```

### Video Asset

Provide video asset information:

```tsx
ads: {
  enabled: true,
  provider: 'freewheel',
  networkId: '123456',
  serverUrl: '...',
  videoAsset: {
    id: 'video_123',
    duration: 300, // seconds
    url: 'https://example.com/video.mp4',
  },
}
```

### Site Section

Configure site section for targeting:

```tsx
ads: {
  enabled: true,
  provider: 'freewheel',
  networkId: '123456',
  serverUrl: '...',
  siteSection: {
    id: 'homepage',
    pageViewRandom: Math.random(),
    networkId: '123456',
  },
}
```

## Temporal Slots

Define ad break positions:

```tsx
ads: {
  enabled: true,
  provider: 'freewheel',
  networkId: '123456',
  serverUrl: '...',
  temporalSlots: [
    {
      customId: 'preroll',
      adUnit: 'preroll',
      timePosition: 0,
      maxDuration: 30,
    },
    {
      customId: 'midroll-1',
      adUnit: 'midroll',
      timePosition: 120, // 2 minutes
      maxDuration: 60,
    },
    {
      customId: 'postroll',
      adUnit: 'postroll',
      timePosition: 300, // end
      maxDuration: 30,
    },
  ],
}
```

## Custom Parameters

Pass targeting parameters:

```tsx
ads: {
  enabled: true,
  provider: 'freewheel',
  networkId: '123456',
  serverUrl: '...',
  parameters: {
    _fw_player_profile: 'react-native',
    _fw_app_name: 'MyApp',
    _fw_app_version: '1.0.0',
    _fw_device_category: 'mobile',
    custom_param1: 'value1',
    custom_param2: 'value2',
  },
}
```

## Ad Events

```tsx
// Request complete
player.addEventListener('freeWheelRequestComplete', (response) => {
  console.log('Ad request complete:', response);
  console.log('Total ads:', response.totalAds);
});

// Slot started
player.addEventListener('freeWheelSlotStarted', (slot) => {
  console.log('Slot started:', slot.customId);
  console.log('Time position:', slot.timePosition);
});

// Slot ended
player.addEventListener('freeWheelSlotEnded', (slot) => {
  console.log('Slot ended:', slot.customId);
});

// Ad impression
player.addEventListener('freeWheelAdImpression', (ad) => {
  console.log('Ad impression:', ad.adId);
  console.log('Creative ID:', ad.creativeId);
  console.log('Duration:', ad.duration);
});

// Ad clicked
player.addEventListener('freeWheelAdClick', (ad) => {
  console.log('Ad clicked:', ad.adId);
});

// Ad error
player.addEventListener('freeWheelAdError', (error) => {
  console.error('FreeWheel error:', error);
});
```

## Slot Controls

Control ad slot playback:

```tsx
// Play slot
player.playAdSlot('midroll-1');

// Skip slot (if allowed)
player.skipAdSlot('midroll-1');

// Get slot info
const slotInfo = player.getAdSlotInfo('midroll-1');
console.log('Slot:', slotInfo);
```

## Complete Example

```tsx
import React, { useState, useEffect } from 'react';
import { View, Text } from 'react-native';
import { useVideoPlayer, VideoView } from 'react-native-video';

function VideoWithFreeWheelAds({ video }) {
  const [currentSlot, setCurrentSlot] = useState(null);
  const [totalAds, setTotalAds] = useState(0);

  const player = useVideoPlayer({
    source: { uri: video.url },
    ads: {
      enabled: true,
      provider: 'freewheel',
      networkId: 'your-network-id',
      serverUrl: 'https://demo.v.fwmrm.net/ad/g/1',
      profileId: 'your-profile',
      videoAsset: {
        id: video.id,
        duration: video.duration,
        url: video.url,
      },
      temporalSlots: [
        {
          customId: 'preroll',
          adUnit: 'preroll',
          timePosition: 0,
          maxDuration: 30,
        },
        {
          customId: 'midroll',
          adUnit: 'midroll',
          timePosition: video.duration / 2,
          maxDuration: 60,
        },
      ],
      parameters: {
        _fw_player_profile: 'react-native-video',
        _fw_app_name: 'MyApp',
      },
    },
  });

  useEffect(() => {
    player.addEventListener('freeWheelRequestComplete', (response) => {
      setTotalAds(response.totalAds);
    });

    player.addEventListener('freeWheelSlotStarted', (slot) => {
      setCurrentSlot(slot.customId);
    });

    player.addEventListener('freeWheelSlotEnded', () => {
      setCurrentSlot(null);
    });

    return () => {
      // Cleanup
    };
  }, []);

  return (
    
      
      
      {currentSlot && (
        
          Ad Break: {currentSlot}
          Total Ads: {totalAds}
        
      )}
    
  );
}
```

## Advanced Features

### Ad Scheduling

Dynamic ad scheduling:

```tsx
// Add slot dynamically
player.addTemporalSlot({
  customId: 'dynamic-slot',
  adUnit: 'midroll',
  timePosition: 180,
  maxDuration: 30,
});

// Remove slot
player.removeTemporalSlot('dynamic-slot');
```

### Key-Value Targeting

```tsx
ads: {
  enabled: true,
  provider: 'freewheel',
  networkId: '123456',
  serverUrl: '...',
  keyValues: {
    genre: ['action', 'thriller'],
    rating: 'pg-13',
    premium: 'true',
  },
}
```

## Platform Support

| Platform | Supported |
|----------|-----------|
| iOS | ✅ |
| Android | ✅ |
| Android TV | ✅ |
| Apple TV | ✅ |

## Best Practices

1. **Temporal Slots** - Define clear ad break positions
2. **Parameters** - Provide detailed targeting data
3. **Error Handling** - Handle ad failures gracefully
4. **Analytics** - Use FreeWheel's reporting
5. **Testing** - Test with FreeWheel demo server

## See Also

- [Getting Started](./getting-started.md) - Ads overview
- [Google DAI](./google-dai.md) - Server-side ads *(Pro)*
- [SpotX](./spotx.md) - Premium ads *(Pro)*

---

## Getting Started with Ads

# Getting Started with Ads

Monetize your videos with integrated advertising solutions.

## Overview

React Native Video supports multiple ad platforms:

| Platform | Description | Type | Status |
|----------|-------------|------|--------|
| **Google IMA** | Industry-standard client-side ads | Free | ✅ Available |
| **Google DAI** | Server-side ad insertion (SSAI) | Pro | 🔮 Planned |
| **SpotX** | Premium video advertising | Pro | 🔮 Planned |
| **FreeWheel** | Enterprise ad management | Pro | 🔮 Planned |
| **Yospace** | Server-side ad insertion | Pro | 🔮 Planned |

## Ad Types

### Client-Side Ads (CSAI)

Ads are inserted on the client device:

- **Google IMA** - Free, VAST/VMAP support
- Works with most ad networks
- Client handles ad playback

**Benefits:**
- Easy integration
- Works with any video source
- No server-side setup

**Drawbacks:**
- Ad blockers can block
- Network switching visible
- Limited tracking

### Server-Side Ads (SSAI)

Ads are stitched into video stream on server:

- **Google DAI** - Google's SSAI solution *(Pro)*
- **Yospace** - Premium SSAI platform *(Pro)*
- Server stitches ads seamlessly

**Benefits:**
- Ad-blocker resistant
- Seamless transitions
- Better tracking
- Consistent quality

**Drawbacks:**
- Requires server-side setup
- More complex integration

## Quick Start

### Client-Side (Google IMA)

```tsx
import { useVideoPlayer, VideoView } from 'react-native-video';

const player = useVideoPlayer({
  source: {
    uri: 'https://example.com/video.mp4',
  },
  ads: {
    enabled: true,
    provider: 'ima', // Google IMA
    adTagUrl: 'https://example.com/vast.xml',
  },
});

return ;
```

### Server-Side (Google DAI) *(Pro)*

```tsx
const player = useVideoPlayer({
  source: {
    uri: 'https://dai.google.com/...',
    type: 'dai',
  },
  ads: {
    enabled: true,
    provider: 'dai',
    contentSourceId: '123',
    videoId: 'abc',
  },
});
```

## Ad Events

Listen to ad lifecycle events:

```tsx
player.addEventListener('adStart', (ad) => {
  console.log('Ad started:', ad.duration);
});

player.addEventListener('adComplete', () => {
  console.log('Ad completed');
});

player.addEventListener('adSkipped', () => {
  console.log('Ad skipped');
});

player.addEventListener('adError', (error) => {
  console.error('Ad error:', error);
});
```

## Ad Controls

Control ad playback:

```tsx
// Skip ad (if skippable)
player.skipAd();

// Check if ad is playing
const isPlayingAd = player.isPlayingAd();

// Get current ad
const currentAd = player.getCurrentAd();
console.log('Ad time remaining:', currentAd.remainingTime);
```

## Platform Support

| Platform | IMA | DAI | SpotX | FreeWheel | Yospace |
|----------|-----|-----|-------|-----------|---------|
| iOS | ✅ | 🔮 | 🔮 | 🔮 | 🔮 |
| Android | ✅ | 🔮 | 🔮 | 🔮 | 🔮 |
| Android TV | ✅ | 🔮 | 🔮 | 🔮 | 🔮 |
| Apple TV | ✅ | 🔮 | 🔮 | 🔮 | 🔮 |

## Next Steps

- [Google IMA](./google-ima.md) - Client-side ads (Free)
- [Google DAI](./google-dai.md) - Server-side ads *(Pro)*
- [SpotX](./spotx.md) - Premium video ads *(Pro)*
- [FreeWheel](./freewheel.md) - Enterprise ads *(Pro)*
- [Yospace](./yospace.md) - SSAI platform *(Pro)*

---

## Google DAI

# Google DAI

Server-side ad insertion with Google Dynamic Ad Insertion.

:::tip Pro Feature - Coming Soon
Google DAI integration is a Pro feature currently in development.
:::

## Overview

Google DAI (Dynamic Ad Insertion) provides:
- **Server-Side Ad Insertion (SSAI)** - Ads stitched into stream
- **Seamless Playback** - No buffering between ads and content
- **Ad-Blocker Resistant** - Ads part of the stream
- **DVR Support** - Ads work with live DVR
- **Better Tracking** - Server-side metrics
- **Live & VOD** - Support for both

## How It Works

1. Server stitches ads into video stream
2. Client plays single continuous stream
3. SDK tracks ad breaks via metadata
4. No client-side ad insertion needed

## Basic Setup

### VOD (Video on Demand)

```tsx
import { useVideoPlayer, VideoView } from 'react-native-video';

const player = useVideoPlayer({
  source: {
    uri: 'https://dai.google.com/...',
    type: 'dai',
  },
  ads: {
    enabled: true,
    provider: 'dai',
    contentSourceId: '2528370',
    videoId: 'tears-of-steel',
  },
});

return ;
```

### Live Stream

```tsx
const player = useVideoPlayer({
  source: {
    uri: 'https://dai.google.com/...',
    type: 'dai',
  },
  ads: {
    enabled: true,
    provider: 'dai',
    assetKey: 'sN_IYUG8STe1ZzhIIE_ksA',
  },
});
```

## Configuration

### VOD Stream

```tsx
ads: {
  enabled: true,
  provider: 'dai',
  contentSourceId: 'your-content-source-id',
  videoId: 'your-video-id',
  apiKey: 'your-api-key', // Optional
  authToken: 'your-auth-token', // Optional
}
```

### Live Stream

```tsx
ads: {
  enabled: true,
  provider: 'dai',
  assetKey: 'your-asset-key',
  apiKey: 'your-api-key', // Optional
}
```

## Ad Events

DAI provides similar events to IMA:

```tsx
// Cue points (ad break markers)
player.addEventListener('adCuePoints', (cuePoints) => {
  console.log('Ad breaks at:', cuePoints);
});

// Ad break started
player.addEventListener('adBreakStart', (adBreak) => {
  console.log('Ad break started:', adBreak);
  console.log('Duration:', adBreak.duration);
  console.log('Position:', adBreak.position); // Time in content
});

// Ad break ended
player.addEventListener('adBreakEnd', () => {
  console.log('Ad break ended');
});

// Individual ad started
player.addEventListener('adStart', (ad) => {
  console.log('Ad started:', ad.title);
  console.log('Duration:', ad.duration);
});

// Ad completed
player.addEventListener('adComplete', () => {
  console.log('Ad completed');
});

// Ad progress
player.addEventListener('adProgress', (progress) => {
  console.log('Ad time:', progress.currentTime);
});
```

## Snapback

Handle seeking during ads:

```tsx
ads: {
  enabled: true,
  provider: 'dai',
  contentSourceId: '...',
  videoId: '...',
  snapback: true, // Prevent seeking through ads
}

// Snapback event
player.addEventListener('adSnapback', (position) => {
  console.log('Seeked during ad, snapped back to:', position);
});
```

## Companion Ads

Display companion banners with DAI:

```tsx
ads: {
  enabled: true,
  provider: 'dai',
  contentSourceId: '...',
  videoId: '...',
  companionSlots: [
    { id: 'companion-1', width: 300, height: 250 },
  ],
}

// Companion ad event
player.addEventListener('companionAdReady', (companion) => {
  console.log('Companion ad:', companion.slotId);
  console.log('HTML content:', companion.content);
  // Display companion in WebView
});
```

## Stream Information

Get DAI stream info:

```tsx
const streamInfo = player.getDAIStreamInfo();

console.log('Stream ID:', streamInfo.streamId);
console.log('Stream URL:', streamInfo.url);
console.log('Is Live:', streamInfo.isLive);
console.log('Ad breaks:', streamInfo.adBreaks);
```

## Ad Pods

Handle multiple ads in sequence:

```tsx
player.addEventListener('adPodInfo', (podInfo) => {
  console.log('Pod index:', podInfo.podIndex);
  console.log('Total ads:', podInfo.totalAds);
  console.log('Current ad:', podInfo.adPosition);
  console.log('Pod duration:', podInfo.duration);
});
```

## UI Integration

```tsx
import React, { useState, useEffect } from 'react';
import { View, Text } from 'react-native';

function DAIVideoPlayer({ contentSourceId, videoId }) {
  const [isInAdBreak, setIsInAdBreak] = useState(false);
  const [adInfo, setAdInfo] = useState(null);

  const player = useVideoPlayer({
    source: {
      uri: 'https://dai.google.com/...',
      type: 'dai',
    },
    ads: {
      enabled: true,
      provider: 'dai',
      contentSourceId,
      videoId,
      snapback: true,
    },
  });

  useEffect(() => {
    player.addEventListener('adBreakStart', () => {
      setIsInAdBreak(true);
    });

    player.addEventListener('adBreakEnd', () => {
      setIsInAdBreak(false);
      setAdInfo(null);
    });

    player.addEventListener('adStart', (ad) => {
      setAdInfo({
        title: ad.title,
        duration: ad.duration,
      });
    });

    return () => {
      // Cleanup listeners
    };
  }, []);

  return (
    
      
      
      {isInAdBreak && (
        
          Ad
          {adInfo && (
            {adInfo.title}
          )}
        
      )}
    
  );
}
```

## Advanced Configuration

### Custom Request Parameters

```tsx
ads: {
  enabled: true,
  provider: 'dai',
  contentSourceId: '...',
  videoId: '...',
  customAssetKey: 'custom-key',
  customParams: {
    ppid: 'user123',
    vid: 'video456',
  },
}
```

### Ad Tracking

```tsx
ads: {
  enabled: true,
  provider: 'dai',
  contentSourceId: '...',
  videoId: '...',
  omidVersion: '1.3.7',
  omidPartnerName: 'MyApp',
  omidPartnerVersion: '1.0',
}
```

## Platform Support

| Platform | VOD | Live | DVR |
|----------|-----|------|-----|
| iOS | ✅ | ✅ | ✅ |
| Android | ✅ | ✅ | ✅ |
| Android TV | ✅ | ✅ | ✅ |
| Apple TV | ✅ | ✅ | ✅ |

## Best Practices

1. **Snapback** - Enable to prevent ad skipping
2. **Error Handling** - Handle DAI stream errors
3. **Cue Points** - Use for UI indicators
4. **Analytics** - Track ad impressions server-side
5. **Testing** - Test with Google's sample streams

## Testing

Use Google's test streams:

```tsx
// VOD test
ads: {
  enabled: true,
  provider: 'dai',
  contentSourceId: '2528370',
  videoId: 'tears-of-steel',
}

// Live test
ads: {
  enabled: true,
  provider: 'dai',
  assetKey: 'sN_IYUG8STe1ZzhIIE_ksA',
}
```

## Troubleshooting

### Stream Not Loading

- Verify content source ID and video ID
- Check API key if required
- Review network connectivity

### Ads Not Playing

- Ensure stream has ad metadata
- Check DAI console for stream status
- Verify ad insertion setup

## See Also

- [Getting Started](./getting-started.md) - Ads overview
- [Google IMA](./google-ima.md) - Client-side ads
- [Events](../events/useEvent.md) - Event handling

---

## Google IMA

# Google IMA

Integrate Google's Interactive Media Ads SDK for client-side advertising.

## Overview

Google IMA (Interactive Media Ads) provides:
- **VAST/VMAP Support** - Industry-standard ad formats
- **Pre/Mid/Post-roll** - Flexible ad placement
- **Ad Pods** - Multiple ads in sequence
- **Skippable Ads** - User can skip after countdown
- **Click-through** - Users can click ads
- **VPAID Support** - Interactive ads

## Basic Setup

```tsx
import { useVideoPlayer, VideoView } from 'react-native-video';

const player = useVideoPlayer({
  source: {
    uri: 'https://example.com/video.mp4',
  },
  ads: {
    enabled: true,
    provider: 'ima',
    adTagUrl: 'https://pubads.g.doubleclick.net/gampad/ads?...', // VAST tag
  },
});

return ;
```

## Configuration

### Ad Tag URL

Provide VAST/VMAP ad tag URL:

```tsx
ads: {
  enabled: true,
  provider: 'ima',
  adTagUrl: 'https://pubads.g.doubleclick.net/gampad/ads?iu=/123/video&...', // Your ad tag
}
```

### Multiple Ad Breaks

Use VMAP for multiple ad breaks:

```tsx
ads: {
  enabled: true,
  provider: 'ima',
  adTagUrl: 'https://example.com/vmap.xml', // VMAP with pre/mid/post-roll
}
```

### Companion Ads

Display companion banners:

```tsx
ads: {
  enabled: true,
  provider: 'ima',
  adTagUrl: '...',
  companionSlots: [
    { id: 'companion-1', width: 300, height: 250 },
    { id: 'companion-2', width: 728, height: 90 },
  ],
}
```

## Ad Events

Listen to IMA ad events:

```tsx
// Ad started
player.addEventListener('adStart', (ad) => {
  console.log('Ad started:', ad);
  console.log('Duration:', ad.duration);
  console.log('Title:', ad.title);
  console.log('Skippable:', ad.skippable);
  console.log('Skip offset:', ad.skipOffset);
});

// Ad progress
player.addEventListener('adProgress', (progress) => {
  console.log('Ad progress:', progress.currentTime, '/', progress.duration);
});

// Ad paused/resumed
player.addEventListener('adPause', () => {
  console.log('Ad paused');
});

player.addEventListener('adResume', () => {
  console.log('Ad resumed');
});

// Ad completed
player.addEventListener('adComplete', () => {
  console.log('Ad completed');
});

// Ad skipped
player.addEventListener('adSkipped', () => {
  console.log('Ad skipped by user');
});

// Ad clicked
player.addEventListener('adClick', () => {
  console.log('Ad clicked');
  // Optionally pause main video
  player.pause();
});

// Ad error
player.addEventListener('adError', (error) => {
  console.error('Ad error:', error.message);
  // Continue with main content
});

// All ads completed
player.addEventListener('allAdsCompleted', () => {
  console.log('All ads completed');
});
```

## Ad Controls

### Skip Ad

```tsx
// Check if skippable
if (player.isAdSkippable()) {
  player.skipAd();
}
```

### Pause/Resume Ad

```tsx
// Pause ad
player.pauseAd();

// Resume ad
player.resumeAd();
```

### Get Current Ad

```tsx
const currentAd = player.getCurrentAd();

if (currentAd) {
  console.log('Title:', currentAd.title);
  console.log('Duration:', currentAd.duration);
  console.log('Remaining:', currentAd.remainingTime);
  console.log('Position:', currentAd.adPosition); // 'pre', 'mid', 'post'
  console.log('Total ads in pod:', currentAd.totalAdsInPod);
  console.log('Ad index in pod:', currentAd.adIndexInPod);
}
```

## Custom UI

### Skip Button

```tsx
import React, { useState, useEffect } from 'react';
import { View, Text, TouchableOpacity } from 'react-native';

function CustomSkipButton({ player }) {
  const [canSkip, setCanSkip] = useState(false);
  const [countdown, setCountdown] = useState(0);

  useEffect(() => {
    const onAdProgress = (progress) => {
      const ad = player.getCurrentAd();
      if (!ad) return;

      const timeUntilSkip = ad.skipOffset - progress.currentTime;
      
      if (timeUntilSkip  player.removeEventListener('adProgress', onAdProgress);
  }, []);

  if (!canSkip && countdown === 0) return null;

  return (
     player.skipAd()}
      disabled={!canSkip}
    >
      
        {canSkip ? 'Skip Ad ›' : `Skip in ${countdown}s`}
      
    
  );
}
```

### Ad Countdown

```tsx
function AdCountdown({ player }) {
  const [remaining, setRemaining] = useState(0);

  useEffect(() => {
    const onAdProgress = (progress) => {
      setRemaining(Math.ceil(progress.duration - progress.currentTime));
    };

    player.addEventListener('adProgress', onAdProgress);
    return () => player.removeEventListener('adProgress', onAdProgress);
  }, []);

  return Ad: {remaining}s;
}
```

## Complete Example

```tsx
import React, { useState } from 'react';
import { View, Text, ActivityIndicator } from 'react-native';
import { useVideoPlayer, VideoView } from 'react-native-video';

function VideoWithAds({ videoUrl, adTagUrl }) {
  const [isAdPlaying, setIsAdPlaying] = useState(false);
  const [adTitle, setAdTitle] = useState('');

  const player = useVideoPlayer({
    source: { uri: videoUrl },
    ads: {
      enabled: true,
      provider: 'ima',
      adTagUrl,
    },
  });

  // Ad events
  player.addEventListener('adStart', (ad) => {
    setIsAdPlaying(true);
    setAdTitle(ad.title || 'Advertisement');
  });

  player.addEventListener('adComplete', () => {
    setIsAdPlaying(false);
    setAdTitle('');
  });

  player.addEventListener('adError', (error) => {
    console.error('Ad error:', error);
    setIsAdPlaying(false);
  });

  return (
    
      
      
      {isAdPlaying && (
        
          Ad
          {adTitle}
          
        
      )}
    
  );
}
```

## Advanced Configuration

### Request Settings

Configure ad request:

```tsx
ads: {
  enabled: true,
  provider: 'ima',
  adTagUrl: '...',
  requestSettings: {
    omidVersion: '1.3.7',
    playerType: 'react-native-video',
    playerVersion: '6.0.0',
    ppid: 'user123', // Publisher Provided ID
  },
}
```

### Ad UI Settings

Customize ad UI:

```tsx
ads: {
  enabled: true,
  provider: 'ima',
  adTagUrl: '...',
  uiSettings: {
    showCountdown: true,
    showAdAttribution: true,
  },
}
```

## Testing

Use Google's test ads:

```tsx
const TEST_AD_TAG = 'https://pubads.g.doubleclick.net/gampad/ads?iu=/21775744923/external/single_ad_samples&sz=640x480&cust_params=sample_ct%3Dlinear&ciu_szs=300x250%2C728x90&gdfp_req=1&output=vast&unviewed_position_start=1&env=vp&impl=s&correlator=';

ads: {
  enabled: true,
  provider: 'ima',
  adTagUrl: TEST_AD_TAG,
}
```

## Platform Setup

### iOS

Add to `Info.plist`:

```xml
NSAppTransportSecurity

  NSAllowsArbitraryLoads
  

```

### Android

No additional setup required.

## Best Practices

1. **Error Handling** - Always handle ad errors gracefully
2. **Loading States** - Show loading indicator during ad load
3. **User Control** - Respect skip button and ad timing
4. **Analytics** - Track ad impressions and completions
5. **Testing** - Test with various ad formats
6. **Fallback** - Continue content if ads fail

## Troubleshooting

### Ads Not Playing

- Verify ad tag URL is correct
- Check network connectivity
- Review ad error messages
- Test with Google's sample ad tags

### Ads Blocked

- Ad blockers may block IMA SDK
- Use HTTPS for ad tags
- Check app transport security settings

## See Also

- [Getting Started](./getting-started.md) - Ads overview
- [Google DAI](./google-dai.md) - Server-side ads *(Pro)*
- [Events](../events/useEvent.md) - Event handling

---

## SpotX

# SpotX

Premium video advertising with SpotX platform.

:::tip Pro Feature - Coming Soon
SpotX integration is a Pro feature currently in development.
:::

## Overview

SpotX provides:
- **Premium Video Ads** - High-quality ad inventory
- **VAST/VPAID Support** - Industry standards
- **Header Bidding** - Maximize revenue
- **Advanced Targeting** - Audience segmentation
- **Real-Time Analytics** - Detailed reporting
- **Cross-Platform** - Consistent experience

## Basic Setup

```tsx
import { useVideoPlayer, VideoView } from 'react-native-video';

const player = useVideoPlayer({
  source: {
    uri: 'https://example.com/video.mp4',
  },
  ads: {
    enabled: true,
    provider: 'spotx',
    channelId: 'your-channel-id',
  },
});

return ;
```

## Configuration

### Channel Configuration

```tsx
ads: {
  enabled: true,
  provider: 'spotx',
  channelId: '123456',
  publisherId: 'your-publisher-id',
}
```

### Content Metadata

Provide content metadata for better targeting:

```tsx
ads: {
  enabled: true,
  provider: 'spotx',
  channelId: '123456',
  contentMetadata: {
    title: 'Video Title',
    description: 'Video description',
    duration: 300, // seconds
    category: 'sports',
    tags: ['football', 'highlights'],
  },
}
```

### User Targeting

```tsx
ads: {
  enabled: true,
  provider: 'spotx',
  channelId: '123456',
  userTargeting: {
    age: 25,
    gender: 'male',
    interests: ['sports', 'technology'],
  },
}
```

## Ad Events

```tsx
// Ad loaded
player.addEventListener('adLoaded', (ad) => {
  console.log('Ad loaded:', ad);
});

// Ad started
player.addEventListener('adStart', (ad) => {
  console.log('Ad started:', ad.title);
});

// Ad quartiles
player.addEventListener('adFirstQuartile', () => {
  console.log('Ad 25% complete');
});

player.addEventListener('adMidpoint', () => {
  console.log('Ad 50% complete');
});

player.addEventListener('adThirdQuartile', () => {
  console.log('Ad 75% complete');
});

// Ad completed
player.addEventListener('adComplete', () => {
  console.log('Ad completed');
});

// Ad error
player.addEventListener('adError', (error) => {
  console.error('SpotX error:', error);
});
```

## Advanced Features

### Header Bidding

Enable header bidding for maximum revenue:

```tsx
ads: {
  enabled: true,
  provider: 'spotx',
  channelId: '123456',
  headerBidding: {
    enabled: true,
    timeout: 2000, // ms
    bidders: ['appnexus', 'rubicon', 'pubmatic'],
  },
}
```

### Ad Pods

Configure multiple ads in sequence:

```tsx
ads: {
  enabled: true,
  provider: 'spotx',
  channelId: '123456',
  adPods: {
    maxAdsPerPod: 3,
    minAdDuration: 15, // seconds
    maxAdDuration: 30, // seconds
  },
}
```

### Custom Parameters

Pass custom targeting parameters:

```tsx
ads: {
  enabled: true,
  provider: 'spotx',
  channelId: '123456',
  customParams: {
    section: 'homepage',
    device_type: 'mobile',
    app_version: '1.0.0',
  },
}
```

## Complete Example

```tsx
import React, { useState } from 'react';
import { View, Text } from 'react-native';
import { useVideoPlayer, VideoView } from 'react-native-video';

function VideoWithSpotXAds({ video }) {
  const [adPlaying, setAdPlaying] = useState(false);
  const [adProgress, setAdProgress] = useState(0);

  const player = useVideoPlayer({
    source: { uri: video.url },
    ads: {
      enabled: true,
      provider: 'spotx',
      channelId: 'your-channel-id',
      contentMetadata: {
        title: video.title,
        duration: video.duration,
        category: video.category,
      },
      headerBidding: {
        enabled: true,
        timeout: 2000,
      },
    },
  });

  player.addEventListener('adStart', () => {
    setAdPlaying(true);
  });

  player.addEventListener('adProgress', (progress) => {
    setAdProgress(progress.percentage);
  });

  player.addEventListener('adComplete', () => {
    setAdPlaying(false);
    setAdProgress(0);
  });

  return (
    
      
      
      {adPlaying && (
        
          Ad: {adProgress}%
        
      )}
    
  );
}
```

## Best Practices

1. **Metadata** - Provide detailed content metadata
2. **Header Bidding** - Enable for maximum revenue
3. **Error Handling** - Handle ad failures gracefully
4. **Analytics** - Track ad performance
5. **User Experience** - Balance ads with content

## See Also

- [Getting Started](./getting-started.md) - Ads overview
- [Google IMA](./google-ima.md) - Client-side ads
- [FreeWheel](./freewheel.md) - Enterprise ads *(Pro)*

---

## Yospace

# Yospace

Server-side ad insertion with Yospace platform.

:::tip Pro Feature - Coming Soon
Yospace integration is a Pro feature currently in development.
:::

## Overview

Yospace provides:
- **Server-Side Ad Insertion (SSAI)** - Seamless ad integration
- **Live & VOD** - Support for both formats
- **DVR Support** - Ads work with time-shifting
- **Ad-Blocker Proof** - Ads part of the stream
- **Low Latency** - Minimal impact on playback
- **Advanced Analytics** - Detailed tracking

## How It Works

1. Yospace server stitches ads into video stream
2. Client receives single manifest with ads
3. SDK tracks ad markers for UI updates
4. Seamless transitions between content and ads

## Basic Setup

### VOD Stream

```tsx
import { useVideoPlayer, VideoView } from 'react-native-video';

const player = useVideoPlayer({
  source: {
    uri: 'https://your-yospace-url/manifest.m3u8',
    type: 'yospace',
  },
  ads: {
    enabled: true,
    provider: 'yospace',
  },
});

return ;
```

### Live Stream

```tsx
const player = useVideoPlayer({
  source: {
    uri: 'https://your-yospace-url/live.m3u8',
    type: 'yospace-live',
  },
  ads: {
    enabled: true,
    provider: 'yospace',
    isLive: true,
  },
});
```

## Configuration

### VOD Configuration

```tsx
ads: {
  enabled: true,
  provider: 'yospace',
  manifestUrl: 'https://csm-e-sdk-validation.bln1.yospace.com/...',
  isLive: false,
}
```

### Live Configuration

```tsx
ads: {
  enabled: true,
  provider: 'yospace',
  manifestUrl: 'https://csm-e-sdk-validation.bln1.yospace.com/...',
  isLive: true,
  dvrWindowSize: 7200, // 2 hours in seconds
}
```

## Ad Events

```tsx
// Ad break started
player.addEventListener('yospaceAdBreakStart', (adBreak) => {
  console.log('Ad break started');
  console.log('Break ID:', adBreak.id);
  console.log('Duration:', adBreak.duration);
  console.log('Position:', adBreak.position);
});

// Ad break ended
player.addEventListener('yospaceAdBreakEnd', (adBreak) => {
  console.log('Ad break ended:', adBreak.id);
});

// Individual ad started
player.addEventListener('yospaceAdStart', (ad) => {
  console.log('Ad started:', ad.title);
  console.log('Duration:', ad.duration);
  console.log('Ad ID:', ad.id);
});

// Ad ended
player.addEventListener('yospaceAdEnd', (ad) => {
  console.log('Ad ended:', ad.id);
});

// Ad analytics
player.addEventListener('yospaceAdTracking', (event) => {
  console.log('Tracking event:', event.type);
  console.log('URL:', event.url);
});

// Error
player.addEventListener('yospaceError', (error) => {
  console.error('Yospace error:', error);
});
```

## Timeline Management

Handle DVR and seeking:

```tsx
// Get timeline
const timeline = player.getYospaceTimeline();

console.log('Content duration:', timeline.contentDuration);
console.log('Total duration:', timeline.totalDuration); // Content + ads
console.log('Ad breaks:', timeline.adBreaks);

// Convert between timeline positions
const contentTime = 120; // 2 minutes
const playheadTime = player.contentTimeToPlayheadTime(contentTime);

console.log('Content time:', contentTime);
console.log('Playhead time:', playheadTime); // Includes ads
```

## Seeking Control

Control seeking behavior during ads:

```tsx
ads: {
  enabled: true,
  provider: 'yospace',
  manifestUrl: '...',
  seekThroughAds: false, // Prevent seeking through ads
}

// Seek event
player.addEventListener('yospaceSeekBlocked', (position) => {
  console.log('Seek blocked during ad at:', position);
});
```

## Ad Markers

Display ad markers on seekbar:

```tsx
import React, { useState, useEffect } from 'react';
import { View } from 'react-native';

function SeekBarWithAdMarkers({ player }) {
  const [adMarkers, setAdMarkers] = useState([]);
  const [duration, setDuration] = useState(0);

  useEffect(() => {
    const timeline = player.getYospaceTimeline();
    setDuration(timeline.totalDuration);
    
    // Convert ad breaks to marker positions (0-1)
    const markers = timeline.adBreaks.map(adBreak => ({
      position: adBreak.position / timeline.totalDuration,
      duration: adBreak.duration / timeline.totalDuration,
    }));
    
    setAdMarkers(markers);
  }, []);

  return (
    
      {/* Progress bar */}
      
      {/* Ad markers */}
      {adMarkers.map((marker, index) => (
        
      ))}
    
  );
}
```

## Complete Example

```tsx
import React, { useState, useEffect } from 'react';
import { View, Text } from 'react-native';
import { useVideoPlayer, VideoView } from 'react-native-video';

function YospaceVideoPlayer({ manifestUrl, isLive }) {
  const [isInAdBreak, setIsInAdBreak] = useState(false);
  const [currentAd, setCurrentAd] = useState(null);
  const [timeline, setTimeline] = useState(null);

  const player = useVideoPlayer({
    source: {
      uri: manifestUrl,
      type: isLive ? 'yospace-live' : 'yospace',
    },
    ads: {
      enabled: true,
      provider: 'yospace',
      isLive,
      seekThroughAds: false,
    },
  });

  useEffect(() => {
    // Get timeline for ad markers
    const tl = player.getYospaceTimeline();
    setTimeline(tl);

    // Ad break events
    player.addEventListener('yospaceAdBreakStart', () => {
      setIsInAdBreak(true);
    });

    player.addEventListener('yospaceAdBreakEnd', () => {
      setIsInAdBreak(false);
      setCurrentAd(null);
    });

    // Individual ad events
    player.addEventListener('yospaceAdStart', (ad) => {
      setCurrentAd({
        title: ad.title,
        duration: ad.duration,
      });
    });

    return () => {
      // Cleanup
    };
  }, []);

  return (
    
      
      
      {isInAdBreak && (
        
          Ad
          {currentAd && (
            {currentAd.title}
          )}
        
      )}

      {timeline && (
        
      )}
    
  );
}
```

## Advanced Features

### Custom Analytics

```tsx
ads: {
  enabled: true,
  provider: 'yospace',
  manifestUrl: '...',
  analytics: {
    enabled: true,
    customParams: {
      userId: 'user123',
      deviceId: 'device456',
    },
  },
}
```

### Ad Replacement

Replace specific ads dynamically:

```tsx
player.addEventListener('yospaceAdBreakStart', (adBreak) => {
  // Replace ads based on user preferences
  if (userHasPremium) {
    player.skipAdBreak(adBreak.id);
  }
});
```

## Platform Support

| Platform | VOD | Live | DVR |
|----------|-----|------|-----|
| iOS | ✅ | ✅ | ✅ |
| Android | ✅ | ✅ | ✅ |
| Android TV | ✅ | ✅ | ✅ |
| Apple TV | ✅ | ✅ | ✅ |

## Best Practices

1. **Timeline** - Use timeline for accurate UI
2. **Seek Control** - Prevent seeking through ads
3. **Ad Markers** - Show ad breaks on seekbar
4. **Error Handling** - Gracefully handle SSAI errors
5. **Analytics** - Track ad impressions
6. **Testing** - Test with Yospace validation URLs

## Testing

Use Yospace validation streams:

```tsx
// VOD test
const TEST_VOD = 'https://csm-e-sdk-validation.bln1.yospace.com/csm/access/156611618/c2FtcGxlL21hc3Rlci5tM3U4?yo.br=true';

// Live test
const TEST_LIVE = 'https://csm-e-sdk-validation.bln1.yospace.com/csm/access/207411697/c2FtcGxlL21hc3Rlci5tM3U4?yo.br=true';

ads: {
  enabled: true,
  provider: 'yospace',
  manifestUrl: TEST_VOD,
}
```

## See Also

- [Getting Started](./getting-started.md) - Ads overview
- [Google DAI](./google-dai.md) - Server-side ads *(Pro)*
- [Events](../events/useEvent.md) - Event handling

---

## Adobe Analytics

# Adobe Analytics

Enterprise video analytics with Adobe Experience Platform.

:::tip Pro Feature
Adobe Analytics integration is a Pro feature.
:::

## Overview

Adobe Analytics for Media provides:

- **Enterprise-grade analytics** - Part of Adobe Experience Cloud
- **Cross-platform tracking** - Web, mobile, OTT
- **Audience insights** - Deep user segmentation
- **Marketing integration** - Connect with Adobe Campaign
- **Custom reporting** - Flexible report builder

## Installation

```bash
npm install @react-native-video/analytics-adobe
```

## Configuration

```tsx
import { AdobeAnalytics } from '@react-native-video/analytics-adobe';

// Configure at app startup
AdobeAnalytics.configure({
  trackingServer: 'your-company.sc.omtrdc.net',
  reportSuiteId: 'your-report-suite',
  marketingCloudOrgId: 'YOUR_ORG_ID@AdobeOrg',
  visitorId: 'visitor-123', // Optional
});
```

## Usage

```tsx
import { useVideoPlayer, VideoView } from 'react-native-video';
import { AdobeAnalytics } from '@react-native-video/analytics-adobe';

function Player({ source, video }) {
  const player = useVideoPlayer(source, (_player) => {
    _player.play();
  });

  // Initialize Adobe Media tracking
  AdobeAnalytics.trackMedia(player, {
    name: video.title,
    mediaId: video.id,
    length: video.duration,
    streamType: 'VOD', // 'VOD' | 'LIVE' | 'LINEAR'
    mediaType: 'Video', // 'Video' | 'Audio'
  });

  return ;
}
```

## Media Metadata

```tsx
AdobeAnalytics.trackMedia(player, {
  // Required
  name: 'Episode 1',
  mediaId: 'video-123',
  length: 3600,
  streamType: 'VOD',
  mediaType: 'Video',
  
  // Standard metadata
  show: 'My Show',
  season: '1',
  episode: '1',
  genre: 'Drama',
  firstAirDate: '2024-01-01',
  rating: 'TV-14',
  originator: 'My Network',
  network: 'Streaming',
  dayPart: 'primetime',
  
  // Custom metadata
  customMetadata: {
    subscription: 'premium',
    contentType: 'series',
  },
});
```

## Chapter Tracking

```tsx
// Start chapter
AdobeAnalytics.trackChapterStart(player, {
  name: 'Chapter 1',
  position: 1,
  length: 600,
  startTime: 0,
});

// End chapter
AdobeAnalytics.trackChapterComplete(player);

// Skip chapter
AdobeAnalytics.trackChapterSkip(player);
```

## Ad Tracking

```tsx
// Ad break
AdobeAnalytics.trackAdBreakStart(player, {
  name: 'Pre-roll',
  position: 1,
  startTime: 0,
});

// Individual ad
AdobeAnalytics.trackAdStart(player, {
  name: 'Product Ad',
  adId: 'ad-123',
  position: 1,
  length: 15,
});

AdobeAnalytics.trackAdComplete(player);
AdobeAnalytics.trackAdBreakComplete(player);
```

## Quality Metrics

```tsx
// Report quality events
AdobeAnalytics.trackBitrateChange(player, {
  bitrate: 4500000,
});

AdobeAnalytics.trackDroppedFrames(player, {
  droppedFrames: 10,
});

// Report errors
AdobeAnalytics.trackError(player, {
  errorId: 'NETWORK_ERROR',
  errorSource: 'player',
});
```

## Example

```tsx
import React, { useEffect } from 'react';
import { View } from 'react-native';
import { useVideoPlayer, VideoView, useEvent } from 'react-native-video';
import { AdobeAnalytics } from '@react-native-video/analytics-adobe';

function AdobePlayer({ video }) {
  const player = useVideoPlayer(video.source, (_player) => {
    _player.play();
  });

  useEffect(() => {
    // Start media tracking
    AdobeAnalytics.trackMedia(player, {
      name: video.title,
      mediaId: video.id,
      length: video.duration,
      streamType: video.isLive ? 'LIVE' : 'VOD',
      mediaType: 'Video',
      show: video.showName,
      season: video.season,
      episode: video.episode,
    });

    return () => {
      AdobeAnalytics.trackComplete(player);
    };
  }, []);

  return (
    
      
    
  );
}
```

## Platform Support

| Feature | iOS | Android |
|---------|-----|---------|
| Media tracking | ✅ | ✅ |
| Chapter tracking | ✅ | ✅ |
| Ad tracking | ✅ | ✅ |
| Quality metrics | ✅ | ✅ |

## See Also

- [Manual Analytics](./manual.md) - DIY analytics
- [Google Analytics](./google-analytics.md) - Alternative analytics

---

## Conviva

# Conviva

Real-time streaming intelligence and quality analytics.

:::tip Pro Feature
Conviva integration is a Pro feature.
:::

## Overview

[Conviva](https://www.conviva.com/) provides:

- **Real-time monitoring** - Live quality dashboards
- **AI-powered insights** - Automatic issue detection
- **Benchmarking** - Compare against industry standards
- **Alerting** - Proactive issue notification
- **Root cause analysis** - Diagnose quality issues

## Installation

```bash
npm install @react-native-video/analytics-conviva
```

## Configuration

```tsx
import { ConvivaAnalytics } from '@react-native-video/analytics-conviva';

// Configure at app startup
ConvivaAnalytics.configure({
  customerKey: 'YOUR_CONVIVA_CUSTOMER_KEY',
  gatewayUrl: 'https://your-gateway.conviva.com', // Optional
  logLevel: 'DEBUG', // 'DEBUG' | 'INFO' | 'WARNING' | 'ERROR' | 'NONE'
});
```

## Usage

```tsx
import { useVideoPlayer, VideoView } from 'react-native-video';
import { ConvivaAnalytics } from '@react-native-video/analytics-conviva';

function Player({ source, video }) {
  const player = useVideoPlayer(source, (_player) => {
    _player.play();
  });

  // Create Conviva session
  ConvivaAnalytics.createSession(player, {
    assetName: video.title,
    streamUrl: source,
    isLive: video.isLive,
    defaultResource: 'CDN_NAME',
    viewerId: 'user-123',
  });

  return ;
}
```

## Content Metadata

```tsx
ConvivaAnalytics.createSession(player, {
  // Required
  assetName: 'Episode 1 - Pilot',
  
  // Recommended
  streamUrl: 'https://cdn.example.com/video.m3u8',
  isLive: false,
  viewerId: 'user-456',
  defaultResource: 'Cloudfront',
  
  // Optional
  applicationName: 'My Streaming App',
  duration: 3600, // seconds
  encodedFramerate: 30,
  streamType: 'VOD', // 'VOD' | 'LIVE'
  
  // Custom tags
  customTags: {
    show: 'My Show',
    season: '1',
    genre: 'Drama',
    subscription: 'premium',
  },
});
```

## Session Control

```tsx
// Update metadata during playback
ConvivaAnalytics.updateContentMetadata(player, {
  customTags: {
    currentChapter: 'Chapter 2',
  },
});

// Report custom events
ConvivaAnalytics.reportPlaybackEvent(player, 'USER_SEEK');

// Report errors
ConvivaAnalytics.reportPlaybackError(player, 'FATAL', 'Network timeout');

// End session
ConvivaAnalytics.endSession(player);
```

## Ad Tracking

```tsx
// Ad break start
ConvivaAnalytics.adBreakStart(player, {
  podPosition: 'PRE_ROLL',
  podDuration: 30,
  podIndex: 0,
});

// Individual ad
ConvivaAnalytics.adStart(player, {
  adId: 'ad-123',
  adTitle: 'Product Ad',
  adDuration: 15,
  adPosition: 1,
});

ConvivaAnalytics.adEnd(player);
ConvivaAnalytics.adBreakEnd(player);
```

## Dashboard Metrics

Conviva automatically tracks:

| Category | Metrics |
|----------|---------|
| **Engagement** | Concurrent plays, attempts, exits |
| **Quality** | Video start failures, buffering ratio, bitrate |
| **Experience** | QoE score, video restart time |
| **Errors** | Fatal errors, warning events |
| **Ads** | Ad attempts, completion, errors |

## Example

```tsx
import React, { useEffect } from 'react';
import { View } from 'react-native';
import { useVideoPlayer, VideoView, useEvent } from 'react-native-video';
import { ConvivaAnalytics } from '@react-native-video/analytics-conviva';

function ConvivaPlayer({ video }) {
  const player = useVideoPlayer(video.source, (_player) => {
    _player.play();
  });

  useEffect(() => {
    // Create session on mount
    ConvivaAnalytics.createSession(player, {
      assetName: video.title,
      streamUrl: video.source,
      isLive: video.isLive,
      viewerId: getCurrentUserId(),
      customTags: {
        contentType: video.type,
        subscription: getUserSubscription(),
      },
    });

    // Cleanup on unmount
    return () => {
      ConvivaAnalytics.endSession(player);
    };
  }, []);

  // Track seeks
  useEvent(player, 'onSeek', () => {
    ConvivaAnalytics.reportPlaybackEvent(player, 'USER_SEEK');
  });

  return (
    
      
    
  );
}
```

## Platform Support

| Feature | iOS | Android |
|---------|-----|---------|
| Basic tracking | ✅ | ✅ |
| Live streaming | ✅ | ✅ |
| Ad tracking | ✅ | ✅ |
| Custom events | ✅ | ✅ |

## See Also

- [Manual Analytics](./manual.md) - DIY analytics
- [Mux Data](./mux.md) - Alternative analytics
- [Events](../events/useEvent.md) - Event API

---

## Google Analytics

# Google Analytics

Track video events with Google Analytics 4.

:::tip Pro Feature
Google Analytics integration is a Pro feature.
:::

## Overview

Google Analytics 4 provides:

- **Universal tracking** - Part of Google Marketing Platform
- **Event-based model** - Flexible video event tracking
- **Audience insights** - User behavior and demographics
- **BigQuery export** - Raw data for custom analysis
- **Free tier available** - With premium options

## Installation

```bash
npm install @react-native-video/analytics-google
```

## Configuration

```tsx
import { GoogleAnalytics } from '@react-native-video/analytics-google';

// Configure at app startup (uses Firebase)
GoogleAnalytics.configure({
  // Uses existing Firebase/Google Analytics setup
  // or provide manual configuration
  measurementId: 'G-XXXXXXXXXX', // Optional if Firebase is configured
});
```

## Usage

```tsx
import { useVideoPlayer, VideoView } from 'react-native-video';
import { GoogleAnalytics } from '@react-native-video/analytics-google';

function Player({ source, video }) {
  const player = useVideoPlayer(source, (_player) => {
    _player.play();
  });

  // Attach GA4 tracking
  GoogleAnalytics.track(player, {
    videoId: video.id,
    videoTitle: video.title,
    videoCategory: video.category,
  });

  return ;
}
```

## Video Events

GA4 recommended video events are tracked automatically:

| Event | When | Parameters |
|-------|------|------------|
| `video_start` | Playback begins | video_title, video_provider |
| `video_progress` | 10%, 25%, 50%, 75%, 90% | video_percent |
| `video_complete` | Video ends | video_duration |

## Custom Parameters

```tsx
GoogleAnalytics.track(player, {
  // Video metadata
  videoId: 'video-123',
  videoTitle: 'Episode 1',
  videoCategory: 'Entertainment',
  videoProvider: 'My Platform',
  videoDuration: 3600,
  
  // Custom parameters
  contentType: 'series',
  subscriptionType: 'premium',
  seasonNumber: 1,
  episodeNumber: 1,
});
```

## Manual Event Tracking

Track custom events:

```tsx
// Track custom milestones
GoogleAnalytics.trackEvent('video_chapter_complete', {
  videoId: 'video-123',
  chapterName: 'Introduction',
  chapterNumber: 1,
});

// Track user actions
GoogleAnalytics.trackEvent('video_share', {
  videoId: 'video-123',
  shareMethod: 'twitter',
});

// Track quality changes
GoogleAnalytics.trackEvent('video_quality_change', {
  videoId: 'video-123',
  quality: '1080p',
  bitrate: 4500000,
});
```

## Enhanced Measurement

Enable detailed tracking:

```tsx
GoogleAnalytics.track(player, {
  videoId: video.id,
  videoTitle: video.title,
  
  // Enhanced options
  trackProgress: true, // 10%, 25%, 50%, 75%, 90%
  trackBuffering: true,
  trackSeeks: true,
  trackQuality: true,
  trackErrors: true,
});
```

## E-commerce Integration

Track video-related purchases:

```tsx
// Track video purchase
GoogleAnalytics.trackEvent('purchase', {
  transactionId: 'txn-123',
  value: 4.99,
  currency: 'USD',
  items: [{
    itemId: video.id,
    itemName: video.title,
    itemCategory: 'Video Rental',
    price: 4.99,
  }],
});

// Track subscription from video
GoogleAnalytics.trackEvent('subscribe', {
  method: 'video_cta',
  videoId: video.id,
});
```

## Example

```tsx
import React, { useEffect } from 'react';
import { View } from 'react-native';
import { useVideoPlayer, VideoView, useEvent } from 'react-native-video';
import { GoogleAnalytics } from '@react-native-video/analytics-google';

function GAPlayer({ video }) {
  const player = useVideoPlayer(video.source, (_player) => {
    _player.play();
  });

  useEffect(() => {
    // Initialize tracking
    GoogleAnalytics.track(player, {
      videoId: video.id,
      videoTitle: video.title,
      videoCategory: video.category,
      videoDuration: video.duration,
      trackProgress: true,
      trackBuffering: true,
    });
  }, []);

  // Track custom events
  useEvent(player, 'onSeek', () => {
    GoogleAnalytics.trackEvent('video_seek', {
      videoId: video.id,
    });
  });

  return (
    
      
    
  );
}
```

## Debug Mode

```tsx
GoogleAnalytics.configure({
  debugMode: __DEV__, // Enable in development
});

// View events in GA4 DebugView
```

## Platform Support

| Feature | iOS | Android |
|---------|-----|---------|
| Basic tracking | ✅ | ✅ |
| Progress events | ✅ | ✅ |
| Custom events | ✅ | ✅ |
| E-commerce | ✅ | ✅ |

## See Also

- [Manual Analytics](./manual.md) - DIY analytics
- [Adobe Analytics](./adobe.md) - Enterprise alternative
- [Events](../events/useEvent.md) - Event API

---

## Manual Analytics

# Manual Analytics

Integrate your own analytics system using native plugins.

## Overview

Most analytics systems that track player data (e.g., bitrate, errors) can be integrated directly with ExoPlayer or AVPlayer. The [plugin system](../../plugins/plugins.md) allows for non-intrusive analytics integration with react-native-video. It should be implemented in native languages (Kotlin/Swift) to ensure efficiency.

## Architecture

```mermaid
flowchart TB
    subgraph RN[React Native App]
        subgraph RNV[react-native-video]
            PS[Plugin System]
        end
    end
    
    PS -->|onPlayerCreated| Android
    PS -->|onPlayerCreated| iOS
    
    subgraph Android[Your Plugin - Kotlin]
        EXO[ExoPlayer.AnalyticsListener]
    end
    
    subgraph iOS[Your Plugin - Swift]
        AVP[AVPlayer KVO Observers]
    end
```

## Implementation

### Android (Kotlin)

```kotlin
import androidx.annotation.OptIn
import androidx.media3.common.Format
import androidx.media3.common.PlaybackException
import androidx.media3.common.Player
import androidx.media3.common.util.UnstableApi
import androidx.media3.exoplayer.analytics.AnalyticsListener
import com.twg.video.core.plugins.NativeVideoPlayer
import com.twg.video.core.plugins.ReactNativeVideoPlugin
import java.lang.ref.WeakReference

@OptIn(UnstableApi::class)
class AnalyticsPlugin : ReactNativeVideoPlugin("MyAnalytics") {
    
    override fun onPlayerCreated(player: WeakReference) {
        val nativePlayer = player.get() ?: return
        val exoPlayer = nativePlayer.player
        
        exoPlayer.addAnalyticsListener(object : AnalyticsListener {
            override fun onBandwidthEstimate(
                eventTime: AnalyticsListener.EventTime,
                totalLoadTimeMs: Int,
                totalBytesLoaded: Long,
                bitrateEstimate: Long
            ) {
                trackMetric("bitrate", bitrateEstimate)
            }
            
            override fun onDroppedVideoFrames(
                eventTime: AnalyticsListener.EventTime,
                droppedFrames: Int,
                elapsedMs: Long
            ) {
                trackMetric("dropped_frames", droppedFrames)
            }
            
            override fun onVideoInputFormatChanged(
                eventTime: AnalyticsListener.EventTime,
                format: Format,
                decoderReuseDecision: Int?
            ) {
                trackEvent("quality_change", mapOf(
                    "width" to format.width,
                    "height" to format.height,
                    "bitrate" to format.bitrate
                ))
            }
            
            override fun onPlaybackStateChanged(
                eventTime: AnalyticsListener.EventTime,
                state: Int
            ) {
                when (state) {
                    Player.STATE_BUFFERING -> trackEvent("buffering_start")
                    Player.STATE_READY -> trackEvent("buffering_end")
                    Player.STATE_ENDED -> trackEvent("playback_complete")
                }
            }
            
            override fun onPlayerError(
                eventTime: AnalyticsListener.EventTime,
                error: PlaybackException
            ) {
                trackEvent("error", mapOf(
                    "code" to error.errorCode,
                    "message" to error.message
                ))
            }
        })
    }
    
    override fun onPlayerDestroyed(player: WeakReference) {
        flushAnalytics()
    }
    
    private fun trackEvent(name: String, params: Map = emptyMap()) {
        // Send to your analytics backend
    }
    
    private fun trackMetric(name: String, value: Number) {
        // Send to your analytics backend
    }
    
    private fun flushAnalytics() {
        // Flush pending analytics
    }
}
```

### iOS (Swift)

```swift
import AVFoundation

class AnalyticsPlugin: ReactNativeVideoPlugin {
    
    // MARK: - Properties
    
    private weak var currentPlayer: AVPlayer?
    private var rateObserver: NSKeyValueObservation?
    private var statusObserver: NSKeyValueObservation?
    private var timeObserver: Any?
    
    // MARK: - Init
    
    init() {
        super.init(name: "MyAnalytics")
    }
    
    // MARK: - Plugin Lifecycle
    
    override func onPlayerCreated(player: Weak) {
        guard let nativePlayer = player.value else { return }
        currentPlayer = nativePlayer.player
        
        setupPlaybackObservers(for: nativePlayer.player)
        setupQualityTracking(for: nativePlayer.playerItem)
    }
    
    override func onPlayerDestroyed(player: Weak) {
        removeAllObservers()
        flushAnalytics()
    }
    
    // MARK: - Setup
    
    private func setupPlaybackObservers(for player: AVPlayer) {
        rateObserver = player.observe(\.rate) { [weak self] p, _ in
            self?.trackEvent(p.rate > 0 ? "play" : "pause")
        }
        
        statusObserver = player.observe(\.status) { [weak self] p, _ in
            if p.status == .readyToPlay {
                self?.trackEvent("ready")
            } else if p.status == .failed {
                self?.trackEvent("error", params: ["message": p.error?.localizedDescription ?? ""])
            }
        }
        
        timeObserver = player.addPeriodicTimeObserver(
            forInterval: CMTime(seconds: 10, preferredTimescale: 1),
            queue: .main
        ) { [weak self] time in
            self?.trackMetric("position", value: time.seconds)
        }
    }
    
    private func setupQualityTracking(for playerItem: AVPlayerItem?) {
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(handleAccessLog),
            name: .AVPlayerItemNewAccessLogEntry,
            object: playerItem
        )
    }
    
    @objc private func handleAccessLog(_ notification: Notification) {
        guard let item = notification.object as? AVPlayerItem,
              let event = item.accessLog()?.events.last else { return }
        
        trackMetric("bitrate", value: event.indicatedBitrate)
        trackMetric("stalls", value: Double(event.numberOfStalls))
        trackMetric("dropped_frames", value: Double(event.numberOfDroppedVideoFrames))
    }
    
    private func removeAllObservers() {
        if let observer = timeObserver {
            currentPlayer?.removeTimeObserver(observer)
        }
        rateObserver?.invalidate()
        statusObserver?.invalidate()
        NotificationCenter.default.removeObserver(self)
        
        currentPlayer = nil
        timeObserver = nil
    }
    
    // MARK: - Analytics
    
    private func trackEvent(_ name: String, params: [String: Any] = [:]) {
        // Send to your analytics backend
    }
    
    private func trackMetric(_ name: String, value: Double) {
        // Send to your analytics backend
    }
    
    private func flushAnalytics() {
        // Flush pending analytics
    }
}
```

## Available Metrics

### Android (ExoPlayer AnalyticsListener)

| Event | Method | Data |
|-------|--------|------|
| Bitrate | `onBandwidthEstimate` | `bitrateEstimate` |
| Dropped frames | `onDroppedVideoFrames` | `droppedFrames`, `elapsedMs` |
| Quality change | `onVideoInputFormatChanged` | `format.width`, `format.height` |
| Buffering | `onPlaybackStateChanged` | `Player.STATE_BUFFERING` |
| Stall | `onStallStart` / `onStallEnd` | duration |
| Seek | `onSeekStarted` / `onSeekProcessed` | position |
| Error | `onPlayerError` | `errorCode`, `message` |

### iOS (AVPlayer)

| Metric | Source | Property |
|--------|--------|----------|
| Bitrate | `accessLog` | `indicatedBitrate` |
| Stalls | `accessLog` | `numberOfStalls` |
| Dropped frames | `accessLog` | `numberOfDroppedVideoFrames` |
| Bytes | `accessLog` | `numberOfBytesTransferred` |
| Playback status | KVO | `player.status` |
| Play/Pause | KVO | `player.rate` |
| Buffer | `playerItem` | `isPlaybackLikelyToKeepUp` |

## Registration

Plugins auto-register when instantiated. Create your plugin early in app lifecycle:

**Android** - `MainApplication.kt`:

```kotlin
class MainApplication : Application() {
    override fun onCreate() {
        super.onCreate()
        AnalyticsPlugin() // Auto-registers via init block
    }
}
```

**iOS** - `AppDelegate.swift`:

```swift
@main
class AppDelegate: UIResponder, UIApplicationDelegate {
    private var analyticsPlugin: AnalyticsPlugin?
    
    func application(
        _ application: UIApplication,
        didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
    ) -> Bool {
        analyticsPlugin = AnalyticsPlugin() // Auto-registers via init
        return true
    }
}
```

## See Also

- [Plugins](../../plugins/plugins.md) - Full plugin system documentation
- [Plugin Interface](../../plugins/interface.md) - Complete API reference
- [Mux Data](./mux.md) - Pre-built Mux integration *(Pro)*
- [Conviva](./conviva.md) - Pre-built Conviva integration *(Pro)*

---

## Mux Data

# Mux Data

Video-specific analytics with automatic quality metrics.

:::tip Pro Feature
Mux Data integration is a Pro feature.
:::

## Overview

[Mux Data](https://mux.com/data) provides:

- **Automatic QoE scoring** - Real-time quality of experience
- **Video-specific metrics** - Startup time, rebuffering, bitrate
- **Real-time dashboards** - Monitor live streams and VOD
- **Alerting** - Get notified about quality issues
- **A/B testing** - Compare player configurations

## Installation

```bash
npm install @react-native-video/analytics-mux
```

## Configuration

```tsx
import { useVideoPlayer, VideoView } from 'react-native-video';
import { MuxAnalytics } from '@react-native-video/analytics-mux';

// Configure once at app startup
MuxAnalytics.configure({
  envKey: 'YOUR_MUX_ENV_KEY',
  playerName: 'React Native Video',
  playerVersion: '7.0.0',
});
```

## Usage

```tsx
function Player({ source, videoId, videoTitle }) {
  const player = useVideoPlayer(source, (_player) => {
    _player.play();
  });

  // Attach Mux tracking
  MuxAnalytics.track(player, {
    videoId,
    videoTitle,
    videoSeries: 'Season 1',
    videoDuration: 3600,
    viewerUserId: 'user-123',
  });

  return ;
}
```

## Metadata

Provide rich metadata for better insights:

```tsx
MuxAnalytics.track(player, {
  // Video metadata
  videoId: 'abc123',
  videoTitle: 'Episode 1',
  videoSeries: 'My Show',
  videoDuration: 3600000, // ms
  videoIsLive: false,
  videoStreamType: 'on-demand',
  videoCdn: 'cloudfront',
  
  // Viewer metadata
  viewerUserId: 'user-456',
  viewerDeviceCategory: 'mobile',
  viewerApplicationName: 'My App',
  viewerApplicationVersion: '1.0.0',
  
  // Custom dimensions
  customDimension1: 'premium',
  customDimension2: 'organic',
});
```

## Events

Track custom events:

```tsx
// Track ad events
MuxAnalytics.trackAdBreakStart(player);
MuxAnalytics.trackAdStart(player, { adId: 'ad-123' });
MuxAnalytics.trackAdEnd(player);
MuxAnalytics.trackAdBreakEnd(player);

// Track errors
MuxAnalytics.trackError(player, {
  errorCode: 'MEDIA_ERR_NETWORK',
  errorMessage: 'Network error',
});
```

## Dashboard Metrics

Mux Data automatically tracks:

| Category | Metrics |
|----------|---------|
| **Playback** | Views, play rate, watch time |
| **Quality** | Startup time, rebuffer ratio, upscaling |
| **Engagement** | Completion rate, seek ratio |
| **Errors** | Error rate, error types |
| **Performance** | Bitrate, resolution, CDN |

## Example

```tsx
import React from 'react';
import { View } from 'react-native';
import { useVideoPlayer, VideoView } from 'react-native-video';
import { MuxAnalytics } from '@react-native-video/analytics-mux';

function MuxTrackedPlayer({ video }) {
  const player = useVideoPlayer(video.source, (_player) => {
    _player.play();
  });

  // Attach Mux tracking with metadata
  MuxAnalytics.track(player, {
    videoId: video.id,
    videoTitle: video.title,
    videoDuration: video.duration,
    videoIsLive: video.isLive,
    viewerUserId: getCurrentUserId(),
  });

  return (
    
      
    
  );
}
```

## Platform Support

| Feature | iOS | Android |
|---------|-----|---------|
| Basic tracking | ✅ | ✅ |
| Live streaming | ✅ | ✅ |
| Custom events | ✅ | ✅ |
| Ads tracking | ✅ | ✅ |

## See Also

- [Manual Analytics](./manual.md) - DIY analytics
- [Conviva](./conviva.md) - Alternative analytics
- [Events](../events/useEvent.md) - Event API

---

## NPAW (Youbora)

# NPAW (Youbora)

Comprehensive video analytics suite for streaming platforms.

:::tip Pro Feature
NPAW integration is a Pro feature.
:::

## Overview

[NPAW](https://npaw.com/) (formerly Youbora) provides:

- **360° Analytics** - Complete visibility into video performance
- **Smart alerts** - AI-powered anomaly detection
- **Content analytics** - Understand what users watch
- **Advertising insights** - Track ad performance
- **CDN analytics** - Optimize delivery

## Installation

```bash
npm install @react-native-video/analytics-npaw
```

## Configuration

```tsx
import { NPAWAnalytics } from '@react-native-video/analytics-npaw';

// Configure at app startup
NPAWAnalytics.configure({
  accountCode: 'YOUR_ACCOUNT_CODE',
  username: 'user-123', // Optional
  userType: 'premium', // Optional
});
```

## Usage

```tsx
import { useVideoPlayer, VideoView } from 'react-native-video';
import { NPAWAnalytics } from '@react-native-video/analytics-npaw';

function Player({ source, video }) {
  const player = useVideoPlayer(source, (_player) => {
    _player.play();
  });

  // Initialize NPAW tracking
  NPAWAnalytics.track(player, {
    'content.title': video.title,
    'content.id': video.id,
    'content.duration': video.duration,
    'content.isLive': video.isLive,
  });

  return ;
}
```

## Content Options

```tsx
NPAWAnalytics.track(player, {
  // Content info
  'content.title': 'Episode 1',
  'content.id': 'video-123',
  'content.program': 'My Show',
  'content.season': 'Season 1',
  'content.episodeTitle': 'Pilot',
  'content.duration': 3600,
  'content.isLive': false,
  'content.resource': 'https://cdn.example.com/video.m3u8',
  'content.cdn': 'Cloudfront',
  'content.encoding.videoCodec': 'h264',
  'content.encoding.audioCodec': 'aac',
  
  // Custom dimensions
  'content.customDimension.1': 'premium',
  'content.customDimension.2': 'mobile',
  
  // Device info (auto-detected, but can override)
  'device.brand': 'Apple',
  'device.model': 'iPhone 15',
});
```

## Ad Tracking

```tsx
// Configure ad options
NPAWAnalytics.setAdOptions(player, {
  'ad.campaign': 'Summer Sale',
  'ad.provider': 'Google IMA',
});

// Ad break
NPAWAnalytics.adBreakStart(player, {
  position: 'pre', // 'pre' | 'mid' | 'post'
});

// Individual ad
NPAWAnalytics.adStart(player, {
  title: 'Product Ad',
  duration: 15,
  position: 1,
});

NPAWAnalytics.adEnd(player);
NPAWAnalytics.adBreakEnd(player);
```

## Session Control

```tsx
// Report custom events
NPAWAnalytics.fireEvent(player, 'like', { contentId: 'video-123' });

// Update options during playback
NPAWAnalytics.setContentOptions(player, {
  'content.customDimension.3': 'chapter-2',
});

// Report errors
NPAWAnalytics.fireError(player, {
  code: 'NETWORK_ERROR',
  message: 'Connection timeout',
  isFatal: true,
});

// Stop tracking
NPAWAnalytics.stop(player);
```

## Dashboard Metrics

NPAW automatically tracks:

| Category | Metrics |
|----------|---------|
| **Views** | Plays, unique users, concurrent views |
| **Engagement** | Play time, completion rate, sessions |
| **Quality** | Buffer ratio, join time, bitrate |
| **Errors** | Fatal errors, playback failures |
| **Ads** | Impressions, completion, errors |
| **Content** | Popular content, trends |

## Example

```tsx
import React, { useEffect } from 'react';
import { View } from 'react-native';
import { useVideoPlayer, VideoView } from 'react-native-video';
import { NPAWAnalytics } from '@react-native-video/analytics-npaw';

function NPAWPlayer({ video, user }) {
  const player = useVideoPlayer(video.source, (_player) => {
    _player.play();
  });

  useEffect(() => {
    // Start tracking
    NPAWAnalytics.track(player, {
      'content.title': video.title,
      'content.id': video.id,
      'content.duration': video.duration,
      'content.isLive': video.isLive,
      'content.customDimension.1': video.category,
      'content.customDimension.2': user.subscriptionType,
    });

    // Cleanup
    return () => {
      NPAWAnalytics.stop(player);
    };
  }, []);

  return (
    
      
    
  );
}
```

## Platform Support

| Feature | iOS | Android |
|---------|-----|---------|
| Basic tracking | ✅ | ✅ |
| Live streaming | ✅ | ✅ |
| Ad tracking | ✅ | ✅ |
| Custom events | ✅ | ✅ |
| Offline views | ✅ | ✅ |

## See Also

- [Manual Analytics](./manual.md) - DIY analytics
- [Mux Data](./mux.md) - Alternative analytics
- [Conviva](./conviva.md) - Alternative analytics

---

## DRM

# DRM

## What is DRM (Digital Rights Management)?
DRM is a set of access control technologies that are used to protect copyrighted content from unauthorized use and distribution. It allows content owners to control how their digital media is used and distributed.

### When do you need it?
If you are working with copyrighted content and want to prevent unauthorized access or distribution, you will need DRM. It is especially important for streaming services, e-learning platforms, and any application that delivers premium content that you want to protect from piracy.

### What next?
This page explains how to play DRM‑protected content with React Native Video using the official DRM plugin. It covers installing and enabling the plugin, configuring sources with DRM, and platform‑specific notes for Android (Widevine) and iOS/visionOS (FairPlay).

## Install and enable the DRM plugin

:::tip Pluginable Architecture
React Native Video uses a plugin architecture. DRM support is provided by the `@react-native-video/drm` plugin and is not built into the core package.
:::

1) Install dependencies in your app:

```sh
npm install @react-native-video/drm
```

2) Enable the plugin at app startup (before creating any players):

```ts
// App.tsx (or any place you want to initialize the plugin)
import { enable } from '@react-native-video/drm';

enable();
```

The plugin autolinks on both Android and iOS. Nitro Modules are required because the plugin uses Nitro under the hood.

## Quick start

You pass DRM configuration via `VideoConfig.drm` when creating a player or using the `useVideoPlayer` hook. If `drm.type` is omitted, the default is inferred per platform (`widevine` on Android, `fairplay` on iOS/visionOS).

```tsx
import { VideoView, useVideoPlayer } from 'react-native-video';

export function Player() {
  const player = useVideoPlayer({
    source: {
    uri: 'https://example.com/manifest.mpd', // or HLS .m3u8 for FairPlay
    // On iOS these headers are also used for the default license request
    headers: { Authorization: 'Bearer ' },
    drm: {
      // type: 'widevine' | 'fairplay'  // optional; inferred by platform
      licenseUrl: 'https://license.example.com/widevine',
    },
  },
  });

  return ;
}
```

:::warning
You shouldn't include your authorization token directly in the code. Instead, use a backend method to retrieve it at runtime.
:::

## DRM config reference

All properties are optional unless marked otherwise for a platform. The table below describes each property, the expected type, platforms where it applies, whether it's required, and important notes.

| Property | Type | Platform | Required | Notes |
|---|---:|---|:---:|---|
| `type` | `'widevine' \| 'fairplay'` | Android, iOS, visionOS | No (defaulted) | Default inferred per platform when `drm` is present and `type` omitted (Android → `widevine`, iOS/visionOS → `fairplay`). |
| `licenseUrl` | `string` | Android, iOS, visionOS | Android: Yes; iOS/visionOS: Yes for default/custom flows | URL of the license (CKC) service. Required for license acquisition. |
| `licenseHeaders` | ``Record`` | Android | No | Extra headers sent with the Widevine license request. (On iOS, use `source.headers` for license requests.) |
| `multiSession` | `boolean` | Android | No | Whether to allow multiple Widevine sessions. |
| `certificateUrl` | `string` | iOS, visionOS | Yes (for FairPlay) | URL to fetch the FairPlay application certificate (used to create the SPC). |
| `contentId` | `string` | iOS, visionOS | No | If omitted, derived from the `skd://` key URL. Used when creating the SPC. |
| `getLicense` | ``(payload) => Promise`` | iOS, visionOS | No | Optional hook for custom FairPlay license logic; must resolve to a base64‑encoded CKC string. |

Payload shape passed to `getLicense` (iOS/visionOS):

| Field | Type | Description |
|---|---:|---|
| `contentId` | `string` | Content identifier for the asset. If not provided the player will try to derive it from the `skd://` key URL. |
| `licenseUrl` | `string` | The license server URL that should be used for license acquisition. |
| `keyUrl` | `string` | The key URL/identifier received from the stream (typically an `skd://` URL). |
| `spc` | `string` | The SPC (secure playback context) as a base64‑encoded string. Send raw SPC bytes to your license server (server side may expect raw bytes rather than base64). |

## Android: Widevine

- Set `drm.type` to `'widevine'` or omit it (the library will default to Widevine on Android if `drm` is present).
- `licenseUrl` is required; `licenseHeaders` and `multiSession` are optional.
- Implementation details:
	- The plugin uses ExoPlayer’s `DefaultDrmSessionManager` and `HttpMediaDrmCallback` with your `licenseUrl` and `licenseHeaders`.
	- If a first attempt fails due to device security level issues, the plugin retries with `L3` security level.

Example:

```tsx
useVideoPlayer({
  source: {
    uri: 'https://example.com/manifest.mpd',
    drm: {
      // type: 'widevine', // optional
      licenseUrl: 'https://license.example.com/widevine',
      licenseHeaders: { 'X-Custom-Header': 'value' },
      multiSession: false,
    },
  },
});
```

## iOS and visionOS: FairPlay

Two ways to get the CKC (license):

1) Default flow (no `getLicense`):
	 - Required: `certificateUrl`, `licenseUrl`.
	 - The plugin requests the application certificate, generates the SPC, then POSTs the SPC to `licenseUrl`.
	 - It uses `source.headers` (not `drm.licenseHeaders`) for the license request.

2) Custom flow (provide `getLicense`):
	 - Required: `certificateUrl`, `licenseUrl`, and a `getLicense` implementation.
	 - You receive `{ contentId, licenseUrl, keyUrl, spc }` and must return a base64‑encoded CKC string.

Notes:
- DRM isn’t supported in the iOS Simulator; the plugin returns `null` for DRM in Simulator builds.
- If `contentId` isn’t provided, it is derived from the `skd://` key URL.

Default flow example:

```tsx
useVideoPlayer({
  source: {
    uri: 'https://example.com/fairplay.m3u8',
    headers: { Authorization: 'Bearer ' }, // used for the license request
    drm: {
      // type: 'fairplay', // optional
      certificateUrl: 'https://license.example.com/fps-cert',
      licenseUrl: 'https://license.example.com/fps',
      // contentId: 'my-content-id', // optional
    },
  },
});
```

Custom `getLicense` example:

:::tip
This is example code for a custom `getLicense` implementation. it may differ from your actual implementation provided by your DRM provider
:::

```tsx
useVideoPlayer({
  source: {
  uri: 'https://example.com/fairplay.m3u8',
  drm: {
    certificateUrl: 'https://license.example.com/fps-cert',
    licenseUrl: 'https://license.example.com/fps',
    getLicense: async ({ contentId, licenseUrl, keyUrl, spc }) => {
      // Example: POST SPC to your license server and return base64 CKC
        const res = await fetch(licenseUrl, {
          method: 'POST',
          body: Buffer.from(spc, 'base64'), // server expects raw SPC bytes
          headers: {
            'Content-Type': 'application/octet-stream',
            'X-Content-ID': contentId,
            'X-Asset-Id': keyUrl,
          },
        });
        if (!res.ok) throw new Error(`License request failed: ${res.status}`);
        const ckc = await res.arrayBuffer();
        // return base64 CKC string
        return Buffer.from(ckc).toString('base64');
      },
    },
  },
});
```

## Offline
If you are looking for implementing offline playback with DRM, make sure to checkout our [Offline Video SDK](https://www.thewidlarzgroup.com/offline-video-sdk). It provides a comprehensive solution for downloading and playing Streams and DRM-protected content.

## Troubleshooting

- DRMPluginNotFound: Ensure you installed `@react-native-video/drm`, imported it, and called `enable()` before creating any players.
- iOS headers: The default FairPlay flow uses `source.headers` for license requests; `drm.licenseHeaders` are not used on iOS.
- Invalid CKC: `getLicense` must return a base64 string. Returning raw bytes or JSON will fail.
- 403/415 from license server: Verify required auth headers, content type, and whether the server expects raw SPC bytes vs base64.
- Android security level issues: The plugin retries with Widevine L3 if the first attempt fails.
- iOS Simulator: DRM isn’t supported in Simulator. Test on a real device.

## Notes and defaults

- If `drm` is provided without `type`, the library sets a platform default: Android → Widevine, iOS/visionOS → FairPlay.
- For custom DRM systems or advanced pipelines, you can implement your own plugin. See the Plugin Interface docs.

---

## Variable: ALL\_PLAYER\_EVENTS

# Variable: ALL\_PLAYER\_EVENTS

```ts
const ALL_PLAYER_EVENTS: keyof AllPlayerEvents[];
```

Defined in: [types/Events.ts:246](https://github.com/moskalakamil/react-native-video/blob/758f54e450f1f536cb2092e087be9e65f05c3e68/packages/react-native-video/src/core/types/Events.ts#L246)

---

## Variable: ALL\_VIEW\_EVENTS

# Variable: ALL\_VIEW\_EVENTS

```ts
const ALL_VIEW_EVENTS: keyof VideoViewEvents[];
```

Defined in: [types/Events.ts:270](https://github.com/moskalakamil/react-native-video/blob/758f54e450f1f536cb2092e087be9e65f05c3e68/packages/react-native-video/src/core/types/Events.ts#L270)

---

## Type Alias: AllPlayerEvents

# Type Alias: AllPlayerEvents

```ts
type AllPlayerEvents = VideoPlayerEvents & JSVideoPlayerEvents;
```

Defined in: [types/Events.ts:100](https://github.com/moskalakamil/react-native-video/blob/758f54e450f1f536cb2092e087be9e65f05c3e68/packages/react-native-video/src/core/types/Events.ts#L100)

---

## Interface: JSVideoPlayerEvents

# Interface: JSVideoPlayerEvents

## Properties

### onError()

```ts
onError: (error) => void;
```

#### Parameters

| Parameter | Type |
| ------ | ------ |
| `error` | `VideoRuntimeError` |

#### Returns

`void`

---

## Audio Events

# Audio Events

Events for audio state changes.

## onVolumeChange

```ts
onVolumeChange: (data: onVolumeChangeData) => void;
```

Fired when volume changes.

```tsx
useEvent(player, 'onVolumeChange', (data) => {
  console.log('Volume:', data.volume);
  console.log('Muted:', data.muted);
});
```

### onVolumeChangeData

| Property | Type | Description |
|----------|------|-------------|
| `volume` | `number` | Volume level (0.0 - 1.0) |
| `muted` | `boolean` | Is muted |

## onAudioBecomingNoisy

```ts
onAudioBecomingNoisy: () => void;
```

Fired when headphones are unplugged. Typically used to pause playback.

```tsx
useEvent(player, 'onAudioBecomingNoisy', () => {
  player.pause();
});
```

## onAudioFocusChange

```ts
onAudioFocusChange: (hasAudioFocus: boolean) => void;
```

Fired when audio focus changes (another app playing audio).

```tsx
useEvent(player, 'onAudioFocusChange', (hasFocus) => {
  if (!hasFocus) player.pause();
});
```

## Example

```tsx
function AudioAwarePlayer() {
  const player = useVideoPlayer(source, (_player) => {
    _player.play();
  });

  // Pause when headphones unplugged
  useEvent(player, 'onAudioBecomingNoisy', () => {
    player.pause();
  });

  // Pause when another app takes audio focus
  useEvent(player, 'onAudioFocusChange', (hasFocus) => {
    if (!hasFocus) player.pause();
  });

  return ;
}
```

---

## Buffering & Status Events

# Buffering & Status Events

Events for buffering, player status, and bandwidth.

## onBuffer

```ts
onBuffer: (buffering: boolean) => void;
```

Fired when buffering state changes.

```tsx
useEvent(player, 'onBuffer', (buffering) => {
  setIsBuffering(buffering);
});
```

## onStatusChange

```ts
onStatusChange: (status: VideoPlayerStatus) => void;
```

Fired when player status changes.

```tsx
useEvent(player, 'onStatusChange', (status) => {
  console.log('Status:', status);
  // 'idle' | 'loading' | 'ready' | 'playing' | 'paused' | 'buffering' | 'ended' | 'error'
});
```

## onBandwidthUpdate

```ts
onBandwidthUpdate: (data: BandwidthData) => void;
```

Fired when estimated bandwidth changes.

```tsx
useEvent(player, 'onBandwidthUpdate', (data) => {
  console.log('Bandwidth:', data.bitrate, 'bps');
});
```

## Example

```tsx
function BufferingPlayer() {
  const [status, setStatus] = useState('idle');
  const [buffering, setBuffering] = useState(false);

  const player = useVideoPlayer(source, (_player) => {
    _player.play();
  });

  useEvent(player, 'onStatusChange', setStatus);
  useEvent(player, 'onBuffer', setBuffering);

  return (
    
      
      {buffering && }
      Status: {status}
    
  );
}
```

---

## Interface: BandwidthData

# Interface: BandwidthData

Defined in: [types/Events.ts:131](https://github.com/moskalakamil/react-native-video/blob/758f54e450f1f536cb2092e087be9e65f05c3e68/packages/react-native-video/src/core/types/Events.ts#L131)

## Properties

### bitrate

```ts
bitrate: number;
```

Defined in: [types/Events.ts:135](https://github.com/moskalakamil/react-native-video/blob/758f54e450f1f536cb2092e087be9e65f05c3e68/packages/react-native-video/src/core/types/Events.ts#L135)

The bitrate of the video in bits per second.

***

### height?

```ts
optional height: number;
```

Defined in: [types/Events.ts:145](https://github.com/moskalakamil/react-native-video/blob/758f54e450f1f536cb2092e087be9e65f05c3e68/packages/react-native-video/src/core/types/Events.ts#L145)

The height of the video in pixels.

#### Platform

Android

***

### width?

```ts
optional width: number;
```

Defined in: [types/Events.ts:140](https://github.com/moskalakamil/react-native-video/blob/758f54e450f1f536cb2092e087be9e65f05c3e68/packages/react-native-video/src/core/types/Events.ts#L140)

The width of the video in pixels.

#### Platform

android

---

## Interface: TimedMetadata

# Interface: TimedMetadata

Defined in: [types/Events.ts:213](https://github.com/moskalakamil/react-native-video/blob/758f54e450f1f536cb2092e087be9e65f05c3e68/packages/react-native-video/src/core/types/Events.ts#L213)

## Properties

### metadata

```ts
metadata: TimedMetadataObject[];
```

Defined in: [types/Events.ts:217](https://github.com/moskalakamil/react-native-video/blob/758f54e450f1f536cb2092e087be9e65f05c3e68/packages/react-native-video/src/core/types/Events.ts#L217)

The timed metadata of the video.

---

## Type Alias: TimedMetadataObject

# Type Alias: TimedMetadataObject

```ts
type TimedMetadataObject = object;
```

Defined in: [types/Events.ts:208](https://github.com/moskalakamil/react-native-video/blob/758f54e450f1f536cb2092e087be9e65f05c3e68/packages/react-native-video/src/core/types/Events.ts#L208)

## Properties

### identifier

```ts
identifier: string;
```

Defined in: [types/Events.ts:210](https://github.com/moskalakamil/react-native-video/blob/758f54e450f1f536cb2092e087be9e65f05c3e68/packages/react-native-video/src/core/types/Events.ts#L210)

***

### value

```ts
value: string;
```

Defined in: [types/Events.ts:209](https://github.com/moskalakamil/react-native-video/blob/758f54e450f1f536cb2092e087be9e65f05c3e68/packages/react-native-video/src/core/types/Events.ts#L209)

---

## Interface: onLoadData

# Interface: onLoadData

Defined in: [types/Events.ts:148](https://github.com/moskalakamil/react-native-video/blob/758f54e450f1f536cb2092e087be9e65f05c3e68/packages/react-native-video/src/core/types/Events.ts#L148)

## Properties

### currentTime

```ts
currentTime: number;
```

Defined in: [types/Events.ts:152](https://github.com/moskalakamil/react-native-video/blob/758f54e450f1f536cb2092e087be9e65f05c3e68/packages/react-native-video/src/core/types/Events.ts#L152)

The current time of the video in seconds.

***

### duration

```ts
duration: number;
```

Defined in: [types/Events.ts:157](https://github.com/moskalakamil/react-native-video/blob/758f54e450f1f536cb2092e087be9e65f05c3e68/packages/react-native-video/src/core/types/Events.ts#L157)

The duration of the video in seconds.

#### Note

NaN if the duration is unknown.

***

### height

```ts
height: number;
```

Defined in: [types/Events.ts:161](https://github.com/moskalakamil/react-native-video/blob/758f54e450f1f536cb2092e087be9e65f05c3e68/packages/react-native-video/src/core/types/Events.ts#L161)

The height of the video in pixels.

***

### orientation

```ts
orientation: VideoOrientation;
```

Defined in: [types/Events.ts:169](https://github.com/moskalakamil/react-native-video/blob/758f54e450f1f536cb2092e087be9e65f05c3e68/packages/react-native-video/src/core/types/Events.ts#L169)

The orientation of the video.

***

### width

```ts
width: number;
```

Defined in: [types/Events.ts:165](https://github.com/moskalakamil/react-native-video/blob/758f54e450f1f536cb2092e087be9e65f05c3e68/packages/react-native-video/src/core/types/Events.ts#L165)

The width of the video in pixels.

---

## Interface: onLoadStartData

# Interface: onLoadStartData

Defined in: [types/Events.ts:174](https://github.com/moskalakamil/react-native-video/blob/758f54e450f1f536cb2092e087be9e65f05c3e68/packages/react-native-video/src/core/types/Events.ts#L174)

## Properties

### source

```ts
source: VideoPlayerSource;
```

Defined in: [types/Events.ts:183](https://github.com/moskalakamil/react-native-video/blob/758f54e450f1f536cb2092e087be9e65f05c3e68/packages/react-native-video/src/core/types/Events.ts#L183)

The source of the video.

***

### sourceType

```ts
sourceType: SourceType;
```

Defined in: [types/Events.ts:179](https://github.com/moskalakamil/react-native-video/blob/758f54e450f1f536cb2092e087be9e65f05c3e68/packages/react-native-video/src/core/types/Events.ts#L179)

The type of the source.

#### Note

`local` for local files, `network` for network sources.

---

## Interface: onPlaybackStateChangeData

# Interface: onPlaybackStateChangeData

Defined in: [types/Events.ts:186](https://github.com/moskalakamil/react-native-video/blob/758f54e450f1f536cb2092e087be9e65f05c3e68/packages/react-native-video/src/core/types/Events.ts#L186)

## Properties

### isBuffering

```ts
isBuffering: boolean;
```

Defined in: [types/Events.ts:194](https://github.com/moskalakamil/react-native-video/blob/758f54e450f1f536cb2092e087be9e65f05c3e68/packages/react-native-video/src/core/types/Events.ts#L194)

Whether the video is buffering.

***

### isPlaying

```ts
isPlaying: boolean;
```

Defined in: [types/Events.ts:190](https://github.com/moskalakamil/react-native-video/blob/758f54e450f1f536cb2092e087be9e65f05c3e68/packages/react-native-video/src/core/types/Events.ts#L190)

Whether the video is playing.

---

## Interface: onProgressData

# Interface: onProgressData

Defined in: [types/Events.ts:197](https://github.com/moskalakamil/react-native-video/blob/758f54e450f1f536cb2092e087be9e65f05c3e68/packages/react-native-video/src/core/types/Events.ts#L197)

## Properties

### bufferDuration

```ts
bufferDuration: number;
```

Defined in: [types/Events.ts:205](https://github.com/moskalakamil/react-native-video/blob/758f54e450f1f536cb2092e087be9e65f05c3e68/packages/react-native-video/src/core/types/Events.ts#L205)

The time that player is able to play with only buffer.

***

### currentTime

```ts
currentTime: number;
```

Defined in: [types/Events.ts:201](https://github.com/moskalakamil/react-native-video/blob/758f54e450f1f536cb2092e087be9e65f05c3e68/packages/react-native-video/src/core/types/Events.ts#L201)

The current time of the video in seconds.

---

## Interface: onVolumeChangeData

# Interface: onVolumeChangeData

Defined in: [types/Events.ts:220](https://github.com/moskalakamil/react-native-video/blob/758f54e450f1f536cb2092e087be9e65f05c3e68/packages/react-native-video/src/core/types/Events.ts#L220)

## Properties

### muted

```ts
muted: boolean;
```

Defined in: [types/Events.ts:228](https://github.com/moskalakamil/react-native-video/blob/758f54e450f1f536cb2092e087be9e65f05c3e68/packages/react-native-video/src/core/types/Events.ts#L228)

Whether the player is muted.

***

### volume

```ts
volume: number;
```

Defined in: [types/Events.ts:224](https://github.com/moskalakamil/react-native-video/blob/758f54e450f1f536cb2092e087be9e65f05c3e68/packages/react-native-video/src/core/types/Events.ts#L224)

The volume of the player (0.0 = 0%, 1.0 = 100%).

---

## Loading Events

# Loading Events

Events for video loading and initialization.

## onLoadStart

```ts
onLoadStart: (data: onLoadStartData) => void;
```

Fired when video starts loading.

```tsx
useEvent(player, 'onLoadStart', (data) => {
  console.log('Loading:', data.uri);
  setLoading(true);
});
```

## onLoad

```ts
onLoad: (data: onLoadData) => void;
```

Fired when video is loaded and ready to play.

```tsx
useEvent(player, 'onLoad', (data) => {
  console.log('Duration:', data.duration);
  console.log('Size:', data.naturalSize.width, 'x', data.naturalSize.height);
  setLoading(false);
});
```

### onLoadData

| Property | Type | Description |
|----------|------|-------------|
| `duration` | `number` | Duration in seconds |
| `currentTime` | `number` | Current position |
| `naturalSize` | `{ width, height }` | Video dimensions |
| `audioTracks` | `AudioTrack[]` | Available audio tracks |
| `textTracks` | `TextTrack[]` | Available text tracks |

## onReadyToDisplay

```ts
onReadyToDisplay: () => void;
```

Fired when first frame is ready to render.

```tsx
useEvent(player, 'onReadyToDisplay', () => {
  console.log('First frame ready');
  hidePosterImage();
});
```

## Example

```tsx
function LoadingPlayer() {
  const [loading, setLoading] = useState(true);
  const [duration, setDuration] = useState(0);

  const player = useVideoPlayer(source, (_player) => {
    _player.play();
  });

  useEvent(player, 'onLoadStart', () => setLoading(true));
  
  useEvent(player, 'onLoad', (data) => {
    setLoading(false);
    setDuration(data.duration);
  });

  return (
    
      
      {loading && }
      Duration: {duration}s
    
  );
}
```

---

## Playback Events

# Playback Events

Events for playback state and progress.

## onPlaybackStateChange

```ts
onPlaybackStateChange: (data: onPlaybackStateChangeData) => void;
```

Fired when playback state changes.

```tsx
useEvent(player, 'onPlaybackStateChange', (data) => {
  console.log('Playing:', data.isPlaying);
  console.log('Buffering:', data.isBuffering);
});
```

### onPlaybackStateChangeData

| Property | Type | Description |
|----------|------|-------------|
| `isPlaying` | `boolean` | Currently playing |
| `isBuffering` | `boolean` | Currently buffering |

## onPlaybackRateChange

```ts
onPlaybackRateChange: (rate: number) => void;
```

Fired when playback speed changes.

```tsx
useEvent(player, 'onPlaybackRateChange', (rate) => {
  console.log('Speed:', rate);
});
```

## onProgress

```ts
onProgress: (data: onProgressData) => void;
```

Fired periodically during playback.

```tsx
useEvent(player, 'onProgress', (data) => {
  setCurrentTime(data.currentTime);
  setPlayableDuration(data.playableDuration);
});
```

### onProgressData

| Property | Type | Description |
|----------|------|-------------|
| `currentTime` | `number` | Current position (seconds) |
| `playableDuration` | `number` | Buffered duration |
| `seekableDuration` | `number` | Seekable duration |

## onSeek

```ts
onSeek: (seekTime: number) => void;
```

Fired when seek completes.

```tsx
useEvent(player, 'onSeek', (time) => {
  console.log('Seeked to:', time);
});
```

## onEnd

```ts
onEnd: () => void;
```

Fired when video reaches the end.

```tsx
useEvent(player, 'onEnd', () => {
  console.log('Video ended');
  // Auto-play next or show replay
});
```

## Example

```tsx
function ProgressPlayer() {
  const [currentTime, setCurrentTime] = useState(0);
  const [isPlaying, setIsPlaying] = useState(false);

  const player = useVideoPlayer(source, (_player) => {
    _player.play();
  });

  useEvent(player, 'onProgress', (data) => {
    setCurrentTime(data.currentTime);
  });

  useEvent(player, 'onPlaybackStateChange', (data) => {
    setIsPlaying(data.isPlaying);
  });

  useEvent(player, 'onEnd', () => {
    // Replay
    player.seekTo(0);
    player.play();
  });

  return (
    
      
      {isPlaying ? 'Playing' : 'Paused'}
      {Math.floor(currentTime)}s
    
  );
}
```

---

## Tracks & Metadata Events

# Tracks & Metadata Events

Events for text tracks and timed metadata.

## onTrackChange

```ts
onTrackChange: (track: TextTrack | null) => void;
```

Fired when selected text track changes.

```tsx
useEvent(player, 'onTrackChange', (track) => {
  if (track) {
    console.log('Selected:', track.label);
  } else {
    console.log('Subtitles disabled');
  }
});
```

## onTextTrackDataChanged

```ts
onTextTrackDataChanged: (texts: string[]) => void;
```

Fired when current subtitle text changes.

```tsx
useEvent(player, 'onTextTrackDataChanged', (texts) => {
  console.log('Current subtitle:', texts.join(' '));
});
```

## onTimedMetadata

```ts
onTimedMetadata: (metadata: TimedMetadata) => void;
```

Fired when timed metadata is encountered (ID3 tags in HLS streams).

```tsx
useEvent(player, 'onTimedMetadata', (metadata) => {
  console.log('Metadata:', metadata);
});
```

## Example

```tsx
function SubtitlePlayer() {
  const [currentSubtitle, setCurrentSubtitle] = useState('');
  const [trackLabel, setTrackLabel] = useState('Off');

  const player = useVideoPlayer(source, (_player) => {
    _player.play();
  });

  useEvent(player, 'onTrackChange', (track) => {
    setTrackLabel(track?.label ?? 'Off');
  });

  useEvent(player, 'onTextTrackDataChanged', (texts) => {
    setCurrentSubtitle(texts.join(' '));
  });

  return (
    
      
      Track: {trackLabel}
      {currentSubtitle}
    
  );
}
```

---

## UI & External Events

# UI & External Events

Events for controls visibility and external playback (AirPlay, Chromecast).

## onControlsVisibleChange

```ts
onControlsVisibleChange: (visible: boolean) => void;
```

Fired when native controls visibility changes.

```tsx
useEvent(player, 'onControlsVisibleChange', (visible) => {
  console.log('Controls:', visible ? 'shown' : 'hidden');
});
```

## onExternalPlaybackChange

```ts
onExternalPlaybackChange: (externalPlaybackActive: boolean) => void;
```

Fired when AirPlay/external playback state changes.

```tsx
useEvent(player, 'onExternalPlaybackChange', (active) => {
  console.log('AirPlay:', active ? 'active' : 'inactive');
});
```

## Example

```tsx
function ExternalPlaybackPlayer() {
  const [isAirPlay, setIsAirPlay] = useState(false);

  const player = useVideoPlayer(source, (_player) => {
    _player.play();
  });

  useEvent(player, 'onExternalPlaybackChange', (active) => {
    setIsAirPlay(active);
  });

  return (
    
      
      {isAirPlay && 📺 Playing on external device}
    
  );
}
```

---

## useEvent

# useEvent

Subscribe to player events with automatic cleanup.

## Basic Usage

```tsx
import { useVideoPlayer, useEvent, VideoView } from 'react-native-video';

function Player() {
  const player = useVideoPlayer(source, (_player) => {
    _player.play();
  });

  useEvent(player, 'onLoad', (data) => {
    console.log('Duration:', data.duration);
  });

  useEvent(player, 'onProgress', (data) => {
    console.log('Time:', data.currentTime);
  });

  useEvent(player, 'onError', (error) => {
    console.error('Error:', error.code, error.message);
  });

  return ;
}
```

## API

```ts
function useEvent(player, event, callback): void;
```

| Parameter | Type | Description |
|-----------|------|-------------|
| `player` | `VideoPlayer` | Player instance |
| `event` | `T` | Event name |
| `callback` | `AllPlayerEvents[T]` | Callback function |

## Benefits

- **Automatic cleanup** - Removed on unmount
- **Type safety** - Inferred callback types
- **Declarative** - React-style subscriptions

## Manual Subscription

For non-React contexts or manual control:

```tsx
const subscription = player.addEventListener('onProgress', (data) => {
  console.log('Time:', data.currentTime);
});

// Later
subscription.remove();
```

## Clearing Events

```tsx
// Clear specific event
player.clearEvent('onProgress');

// Clear all events
player.clearAllEvents();

// Automatic on release
player.release();
```

## Initialization Timing

`onLoadStart` / `onLoad` fire automatically after player creation (when `initializeOnCreation: true`).

With deferred initialization:

```tsx
const player = useVideoPlayer({
  uri: source,
  initializeOnCreation: false,
});

// Attach handlers first
useEvent(player, 'onLoad', () => console.log('Loaded'));

// Then initialize
await player.initialize();
```

## See Also

- [Usage](./loading.md) - All events by category

---

## Player (VideoPlayer Class)

# Player (VideoPlayer Class)

:::tip Recommended: useVideoPlayer
For most use cases, use the [`useVideoPlayer`](./player.md) hook instead. It automatically manages the player lifecycle (creation and cleanup) within React components.
:::

The `VideoPlayer` class gives you direct control over player lifecycle. Use it when you need manual management or in non-React contexts.

## Creation

```typescript
import { VideoPlayer } from 'react-native-video';

const player = new VideoPlayer('https://example.com/video.mp4');
```
2. **Native Player Allocation**: A lightweight native player object is allocated immediately.
3. **Asset Initialization**: By default (unless you opt out) the underlying media item is prepared **asynchronously right after creation**. You can control this with `initializeOnCreation` inside `VideoConfig`.

### Deferred Initialization (Advanced)

If you pass a `VideoConfig` with `{ initializeOnCreation: false }`, the player will skip preparing the media item automatically. This is useful when:

- You need to batch‑create many players without incurring immediate decoding / network cost
- You want to attach event handlers before any network requests happen
- You want explicit control over when buffering begins (e.g. on user interaction)

To initialize later, call:
```ts
await player.initialize();
// or preload if you also want it prepared & ready
await player.preload();
```

### Initialization Methods Comparison

| Method | When to use | What it does |
|--------|-------------|--------------|
| `initialize()` | You deferred initialization and now want to create the native player item / media source | Creates & attaches the underlying player item / media source without starting playback |
| `preload()` | You want the player item prepared (buffering kicked off) ahead of an upcoming `play()` call | Ensures the media source is set and prepared; resolves once preparation started (may already be initialized) |
| Implicit (default) | `initializeOnCreation` not set or `true` | Automatically schedules initialization after JS construction |

:::info
By default, the player initializes automatically after construction. If you need to defer initialization, set `initializeOnCreation: false` in the config. You can then call `player.initialize()` or `player.preload()` later to start the player.
:::

## Playing a Video

1.  **Loading**: When the player (auto) initializes, `preload()` is called, or after `replaceSourceAsync()`, the player starts loading the video metadata and buffering content.
    -   `onLoadStart`: Fired when the video starts loading.
    -   `onLoad`: Fired when the video metadata is loaded and the player is ready to play (duration, dimensions, etc., are available).
    -   `onBuffer`: Fired when buffering starts or ends.
2.  **Playback**: Once enough data is buffered, playback begins.
    -   `onPlaybackStateChange`: Fired when the playback state changes (e.g., from `buffering` to `playing`).
    -   `onProgress`: Fired periodically with the current playback time.
    -   `onReadyToDisplay`: Fired when the first frame is ready to be displayed.

## Controlling Playback

-   `pause()`: Pauses playback. `status` changes to `paused`.
-   `seekTo(time)`, `seekBy(time)`: Changes the current playback position. `onSeek` is fired when the seek operation completes.
-   `set volume(value)`, `set muted(value)`, `set loop(value)`, `set rate(value)`: Modify player properties. Corresponding events like `onVolumeChange` or `onPlaybackRateChange` might be fired.

## Changing Source

-   `replaceSourceAsync(newSource)`: This method allows you to change the video source dynamically.
    1.  The current native player resources associated with the old source are released (similar to `release()` but specifically for the source).
    2.  A new native player instance (or reconfigured existing one) is prepared for the `newSource`.
    3.  The loading lifecycle events (`onLoadStart`, `onLoad`, etc.) will fire for the new source.
-   `replaceSourceAsync(null)`: This effectively unloads the current video and releases its associated resources without loading a new one. This is useful for freeing up memory if the player is temporarily not needed but might be used again later.

## Releasing Resources

There are two main ways to release resources:

1.  **`replaceSourceAsync(null)`**: This is a less destructive way to free resources related *only* to the current video source.
    -   The `VideoPlayer` instance itself remains usable.
    -   You can later call `replaceSourceAsync(newSource)` to load and play a new video.

2.  **`release()`**: This is a destructive operation.
   
:::danger
After calling `release()`, the player instance becomes unusable. Any subsequent calls to its methods or property access will result in errors.
:::

:::tip
It is recommended to use `replaceSourceAsync(null)` when you want to free resources related to the current video source. You should call `release()` only when you are 100% sure that you don't need the player instance anymore. Anyway garbage collector will release the player instance when it is no longer needed.
:::

## Error Handling

-   The `onError` callback, if provided, will be called when a `VideoRuntimeError` occurs. This allows you to handle issues like network errors, invalid source, or platform-specific playback problems.
-   If `onError` is not provided, errors might be thrown as exceptions.

## Using with Hooks (`useVideoPlayer`)

The `useVideoPlayer` hook simplifies managing the `VideoPlayer` lifecycle within React components.

```tsx
import { useVideoPlayer, VideoView } from 'react-native-video';

const MyComponent = () => {
  const player = useVideoPlayer(source, (_player) => {
    _player.loop = true;
  });

  return ;
};
```

-   **Automatic Creation**: `useVideoPlayer` creates a `VideoPlayer` instance when the component mounts or when the source dependency changes.
-   **Automatic Cleanup**: It automatically cleanup resources when the component unmounts or before recreating the player due to a source change. This prevents resource leaks.
-   **Dependency Management**: If the `source` prop passed to `useVideoPlayer` changes, the hook will clean up the old player instance and create a new one with the new source.

:::tip
Using `useVideoPlayer` is the recommended way to manage `VideoPlayer` instances in functional components to ensure proper lifecycle management and resource cleanup. It will also respect `initializeOnCreation` (defaults to `true`). If you need deferred initialization with the hook:

```tsx
const player = useVideoPlayer({
  uri: 'https://example.com/video.mp4',
  initializeOnCreation: false,
}, (_player) => {
  _player.onLoad = () => console.log('Loaded');
});

// Later (e.g. on user tap)
await player.initialize();
player.play();
```
:::

---

## Audio

# Audio

Control audio volume, muting, and audio mixing behavior.

## Volume

### volume

```ts
get volume(): number;
set volume(value: number): void;
```

Volume level from `0.0` (silent) to `1.0` (full).

**Set on creation:**
```tsx
const player = useVideoPlayer(source, (_player) => {
  _player.volume = 0.5; // 50%
});
```

**Change dynamically:**
```tsx
 player.volume = v}
/>
```

:::note
If the player is muted, effective volume is `0.0` regardless of this property.
:::

### muted

```ts
get muted(): boolean;
set muted(value: boolean): void;
```

Whether audio is muted.

**Set on creation:**
```tsx
const player = useVideoPlayer(source, (_player) => {
  _player.muted = true;
});
```

**Toggle dynamically:**
```tsx
 player.muted = !player.muted} 
/>
```

## Audio Mixing

### mixAudioMode

```ts
get mixAudioMode(): MixAudioMode;
set mixAudioMode(value: MixAudioMode): void;
```

Controls how audio interacts with other apps.

| Value | Description |
|-------|-------------|
| `'auto'` | Platform default (default) |
| `'mixWithOthers'` | Play alongside other apps |
| `'doNotMix'` | Stop other audio |
| `'duckOthers'` | Lower other audio volume |

**Set on creation:**
```tsx
const player = useVideoPlayer(source, (_player) => {
  _player.mixAudioMode = 'mixWithOthers';
});
```

**Use cases:**
- `'mixWithOthers'` - Social media videos that shouldn't interrupt music
- `'duckOthers'` - Navigation audio
- `'doNotMix'` - Full-screen video player

### ignoreSilentSwitchMode

```ts
get ignoreSilentSwitchMode(): IgnoreSilentSwitchMode;
set ignoreSilentSwitchMode(value: IgnoreSilentSwitchMode): void;
```

**iOS only.** Controls behavior when hardware mute switch is on.

| Value | Description |
|-------|-------------|
| `'auto'` | Platform default (default) |
| `'ignore'` | Play audio even when muted |
| `'obey'` | Respect silent switch |

```tsx
const player = useVideoPlayer(source, (_player) => {
  _player.ignoreSilentSwitchMode = 'ignore'; // Music app
});
```

---

## Types

### MixAudioMode

```ts
type MixAudioMode = 'mixWithOthers' | 'doNotMix' | 'duckOthers' | 'auto';
```

### IgnoreSilentSwitchMode

```ts
type IgnoreSilentSwitchMode = 'auto' | 'ignore' | 'obey';
```

---

## Events

### onVolumeChange

```tsx
useEvent(player, 'onVolumeChange', (data) => {
  console.log('Volume:', data.volume, 'Muted:', data.muted);
});
```

### onAudioBecomingNoisy

Fired when headphones are unplugged.

```tsx
useEvent(player, 'onAudioBecomingNoisy', () => {
  player.pause();
});
```

### onAudioFocusChange

Fired when another app takes audio focus.

```tsx
useEvent(player, 'onAudioFocusChange', (hasAudioFocus) => {
  if (!hasAudioFocus) player.pause();
});
```

---

## Complete Example

```tsx
import React, { useState } from 'react';
import { View, Button, Slider, Text, Platform } from 'react-native';
import { useVideoPlayer, useEvent, VideoView } from 'react-native-video';

function AudioControls() {
  const player = useVideoPlayer(source, (_player) => {
    _player.volume = 0.8;
    _player.mixAudioMode = 'mixWithOthers';
  });

  const [volume, setVolume] = useState(0.8);
  const [muted, setMuted] = useState(false);

  // Pause when headphones unplugged
  useEvent(player, 'onAudioBecomingNoisy', () => player.pause());

  useEvent(player, 'onVolumeChange', (data) => {
    setVolume(data.volume);
    setMuted(data.muted);
  });

  return (
    
      
      
       player.volume = v}
      />
      
       player.muted = !muted}
      />

      {Platform.OS === 'ios' && (
         player.ignoreSilentSwitchMode = 'ignore'}
        />
      )}
    
  );
}
```

---

## Background Playback

# Background Playback

Control how the player behaves when the app is in the background.

:::warning Configuration Required
To enable background audio, configure your app:
- **Expo**: Set `enableBackgroundAudio: true`. See [Expo Plugin](../../fundamentals/configuration/expo-plugin.md#enablebackgroundaudio-optional).
- **Manual**: Add `audio` background mode to `Info.plist`. See [Manual Configuration](../../fundamentals/configuration/manual.md#enable-background-audio).
:::

## playInBackground

```ts
get playInBackground(): boolean;
set playInBackground(value: boolean): void;
```

Continue playing when app is backgrounded.

| Value | Behavior |
|-------|----------|
| `true` | Continue in background |
| `false` | Pause when backgrounded (default) |

**Set on creation:**
```tsx
const player = useVideoPlayer(source, (_player) => {
  _player.playInBackground = true;
  _player.showNotificationControls = true;
});
```

**Toggle dynamically:**
```tsx
 player.playInBackground = v}
/>
```

## playWhenInactive

```ts
get playWhenInactive(): boolean;
set playWhenInactive(value: boolean): void;
```

**iOS only.** Continue playing when app is inactive (Control Center open, notification).

```tsx
const player = useVideoPlayer(source, (_player) => {
  _player.playWhenInactive = true;
});
```

:::note
`playInBackground` can override this setting.
:::

## With Notification Controls

When playing in background, show media controls in notification area:

```tsx
const player = useVideoPlayer({
  uri: source,
  metadata: {
    title: 'Episode 42',
    artist: 'Podcast Name',
    artwork: 'https://example.com/artwork.jpg',
  },
}, (_player) => {
  _player.playInBackground = true;
  _player.showNotificationControls = true;
});
```

See [Notification Controls](./notification-controls.md) for details.

## Complete Example

```tsx
import React from 'react';
import { View, Switch, Text, Platform } from 'react-native';
import { useVideoPlayer, VideoView } from 'react-native-video';

function BackgroundPlayer() {
  const player = useVideoPlayer({
    uri: source,
    metadata: { title: 'My Podcast' },
  }, (_player) => {
    _player.playInBackground = true;
    _player.showNotificationControls = true;
    _player.play();
  });

  return (
    
      
      
      
        Play in Background
         {
            player.playInBackground = v;
            player.showNotificationControls = v;
          }}
        />
      

      {Platform.OS === 'ios' && (
        
          Play When Inactive
           player.playWhenInactive = v}
          />
        
      )}
    
  );
}
```

## See Also

- [Notification Controls](./notification-controls.md) - Lock screen controls
- [Audio](./audio.md) - Audio mixing

---

## Frame Processors

# Frame Processors

Process video frames in realtime using JavaScript or native plugins.

:::tip Pro Feature - Coming Soon
Frame Processors are a Pro feature currently in development. They enable realtime video analysis and manipulation.
:::

## What are Frame Processors?

Frame Processors are JavaScript functions called for each frame the player renders. Inside these functions you can:

- **Analyze frames** in realtime using native plugins
- **Draw overlays** directly onto frames using Skia
- **Extract data** like colors, objects, or text
- **Apply filters** and visual effects

```tsx
const frameProcessor = useFrameProcessor((frame) => {
  'worklet';
  const objects = detectObjects(frame);
  console.log(`Detected: ${objects[0]?.name}`);
}, []);

return ;
```

## Use Cases

Frame Processors enable powerful video processing capabilities:

| Use Case | Description |
|----------|-------------|
| **Ambient Mode** | Extract colors for dynamic UI gradients |
| **Visual Product Search** | Detect products/clothing for e-commerce |
| **Object Detection** | Detect and track objects in video |
| **Face Recognition** | Identify faces and expressions |
| **Text Recognition (OCR)** | Extract text from video frames |
| **Motion Detection** | Detect movement or scene changes |
| **Custom Overlays** | Draw graphics, text, or AR elements |
| **Content Moderation** | Detect inappropriate content |

## Real-World Examples

### Ambient Mode (Dynamic Colors)

Extract dominant colors from the video to create ambient lighting effects around the player. This creates an immersive experience where UI elements like borders or backgrounds match the video content.

```tsx
import React, { useState } from 'react';
import { View } from 'react-native';
import { useVideoPlayer, VideoView, useFrameProcessor, runOnJS } from 'react-native-video';

function AmbientVideoPlayer({ source }) {
  const [ambientColor, setAmbientColor] = useState('#000000');

  const player = useVideoPlayer(source, (_player) => {
    _player.play();
  });

  const frameProcessor = useFrameProcessor((frame) => {
    'worklet';
    // Extract dominant color from frame edges
    const color = extractDominantColor(frame, {
      region: 'edges', // Focus on edges for ambient effect
      sampleSize: 50,
    });
    
    runOnJS(setAmbientColor)(color);
  }, []);

  return (
    
      
        
      
    
  );
}
```

**Features:**
- Real-time color extraction from video frames
- Smooth color transitions with interpolation
- Region-based sampling (edges, center, full frame)
- Perfect for music videos, ambient displays, and immersive UIs

### Visual Product Search (E-commerce)

Detect clothing and products in video content for shoppable experiences. Users can tap on items to find similar products for purchase.

```tsx
import React, { useState } from 'react';
import { View, TouchableOpacity, Image } from 'react-native';
import { useVideoPlayer, VideoView, useFrameProcessor, runOnJS } from 'react-native-video';

function ShoppableVideoPlayer({ source }) {
  const [detectedProducts, setDetectedProducts] = useState([]);
  const [isPaused, setIsPaused] = useState(false);

  const player = useVideoPlayer(source, (_player) => {
    _player.play();
  });

  const frameProcessor = useFrameProcessor((frame) => {
    'worklet';
    // Detect clothing and products in frame
    const products = detectProducts(frame, {
      categories: ['clothing', 'accessories', 'shoes'],
      minConfidence: 0.7,
    });
    
    // Map to screen coordinates
    const mapped = products.map(p => ({
      id: p.id,
      category: p.category,
      bounds: p.bounds,
      confidence: p.confidence,
    }));
    
    runOnJS(setDetectedProducts)(mapped);
  }, []);

  const handleProductTap = async (product) => {
    player.pause();
    setIsPaused(true);
    
    // Search for similar products
    const results = await searchSimilarProducts(product);
    showProductSheet(results);
  };

  return (
    
      
      
      {/* Product hotspots */}
      {detectedProducts.map((product) => (
         handleProductTap(product)}
        >
          
        
      ))}
    
  );
}
```

**Features:**
- Real-time clothing and product detection
- Tap-to-shop functionality
- Category filtering (clothing, accessories, shoes, etc.)
- Integration with product catalogs and search APIs
- Perfect for fashion videos, influencer content, and live shopping

## Installation

Frame Processors require `react-native-worklets-core`:

```bash
npm install react-native-worklets-core
```

Add the plugin to your `babel.config.js`:

```js
module.exports = {
  plugins: [
    ['react-native-worklets-core/plugin'],
  ],
};
```

## The Frame Object

A video frame contains pixel data and metadata:

```tsx
const frameProcessor = useFrameProcessor((frame) => {
  'worklet';
  console.log(`Frame: ${frame.width}x${frame.height}`);
  console.log(`Format: ${frame.pixelFormat}`);
  console.log(`Timestamp: ${frame.timestamp}ms`);
}, []);
```

### Frame Properties

| Property | Type | Description |
|----------|------|-------------|
| `width` | `number` | Frame width in pixels |
| `height` | `number` | Frame height in pixels |
| `pixelFormat` | `string` | Pixel format (`'rgb'`, `'yuv'`, etc.) |
| `timestamp` | `number` | Frame timestamp in milliseconds |
| `bytesPerRow` | `number` | Bytes per row of pixel data |

### Accessing Pixel Data

```tsx
const frameProcessor = useFrameProcessor((frame) => {
  'worklet';
  if (frame.pixelFormat === 'rgb') {
    const buffer = frame.toArrayBuffer();
    const data = new Uint8Array(buffer);
    // First pixel RGB values
    console.log(`RGB(${data[0]}, ${data[1]}, ${data[2]})`);
  }
}, []);
```

:::note
At 1080p, a raw frame is ~6MB. At 60 FPS, ~360MB/second flows through your processor. Use native plugins for heavy processing.
:::

## Native Plugins

For performance-critical tasks, use native Frame Processor Plugins written in Swift/Kotlin/C++.

### Using Community Plugins

```bash
npm install vision-camera-image-labeler
cd ios && pod install
```

```tsx
import { useImageLabeler } from 'vision-camera-image-labeler';

function VideoAnalyzer() {
  const { labelImage } = useImageLabeler();

  const frameProcessor = useFrameProcessor((frame) => {
    'worklet';
    const labels = labelImage(frame);
    console.log(`Detected: ${labels[0]?.name}`);
  }, [labelImage]);

  return ;
}
```

### Creating Custom Plugins

Create native plugins for optimal performance:

**iOS (Swift):**

```swift
@objc(ObjectDetector)
public class ObjectDetectorPlugin: FrameProcessorPlugin {
  public override func callback(_ frame: Frame, withArguments args: [AnyHashable: Any]) -> Any {
    let imageBuffer = frame.buffer
    let objects = MLKit.detectObjects(imageBuffer)
    return objects.map { $0.toJson() }
  }
}
```

**Android (Kotlin):**

```kotlin
class ObjectDetectorPlugin : FrameProcessorPlugin() {
  override fun callback(frame: Frame, params: Map): Any {
    val image = frame.image
    val objects = MLKit.detectObjects(image)
    return objects.map { it.toJson() }
  }
}
```

## Drawing with Skia

Draw directly onto frames using Skia:

```tsx
import { Skia } from '@shopify/react-native-skia';

const frameProcessor = useFrameProcessor((frame) => {
  'worklet';
  
  // Detect faces
  const faces = detectFaces(frame);
  
  // Draw rectangles around faces
  const canvas = frame.getSkiaCanvas();
  const paint = Skia.Paint();
  paint.setColor(Skia.Color('cyan'));
  paint.setStyle('stroke');
  paint.setStrokeWidth(3);
  
  for (const face of faces) {
    canvas.drawRect(face.bounds, paint);
  }
}, []);
```

### Drawing Examples

**Text overlay:**

```tsx
const frameProcessor = useFrameProcessor((frame) => {
  'worklet';
  const canvas = frame.getSkiaCanvas();
  const font = Skia.Font(null, 24);
  const paint = Skia.Paint();
  paint.setColor(Skia.Color('white'));
  
  canvas.drawText('LIVE', 20, 40, font, paint);
}, []);
```

**Blur region:**

```tsx
const frameProcessor = useFrameProcessor((frame) => {
  'worklet';
  const faces = detectFaces(frame);
  
  for (const face of faces) {
    frame.applyBlur(face.bounds, 20); // 20px blur radius
  }
}, []);
```

## Performance

Frame Processors run synchronously in the render pipeline.

### Timing Constraints

| FPS | Time per Frame |
|-----|----------------|
| 24 | 41ms |
| 30 | 33ms |
| 60 | 16ms |

### Optimization Tips

1. **Lower resolution** - Process at lower resolution when possible:

```tsx
const player = useVideoPlayer({
  uri: source,
  frameProcessorResolution: { width: 640, height: 360 },
});
```

2. **Skip frames** - Process every Nth frame:

```tsx
let frameCount = 0;

const frameProcessor = useFrameProcessor((frame) => {
  'worklet';
  frameCount++;
  if (frameCount % 3 !== 0) return; // Process every 3rd frame
  
  const result = heavyProcessing(frame);
}, []);
```

3. **Use native plugins** - Offload heavy work to native code

4. **Async processing** - Queue results for async handling:

```tsx
const frameProcessor = useFrameProcessor((frame) => {
  'worklet';
  const result = detectObjects(frame);
  
  // Send to JS thread asynchronously
  runOnJS(handleDetection)(result);
}, []);
```

## Complete Example

```tsx
import React, { useState } from 'react';
import { View, Text } from 'react-native';
import { useVideoPlayer, VideoView, useFrameProcessor, runOnJS } from 'react-native-video';

function ObjectDetectionPlayer({ source }) {
  const [detectedObjects, setDetectedObjects] = useState([]);

  const player = useVideoPlayer(source, (_player) => {
    _player.play();
  });

  const frameProcessor = useFrameProcessor((frame) => {
    'worklet';
    
    // Detect objects using native plugin
    const objects = detectObjects(frame, {
      maxResults: 5,
      minConfidence: 0.7,
    });
    
    // Extract names
    const names = objects.map(obj => obj.name);
    
    // Update React state (async)
    runOnJS(setDetectedObjects)(names);
  }, []);

  return (
    
      
      
      
        Detected Objects:
        {detectedObjects.map((obj, i) => (
          • {obj}
        ))}
      
    
  );
}
```

## Platform Support

| Feature | iOS | Android |
|---------|-----|---------|
| Frame access | ✅ | ✅ |
| Native plugins | ✅ | ✅ |
| Skia drawing | ✅ | ✅ |
| GPU acceleration | ✅ | ✅ |
| Custom resolution | ✅ | ✅ |

## Disabling Frame Processors

If not using Frame Processors, disable them to reduce bundle size:

**Android (`gradle.properties`):**
```properties
ReactNativeVideo_enableFrameProcessors=false
```

**iOS (`Podfile`):**
```ruby
$RNVideoEnableFrameProcessors = false
```

**Expo (`app.json`):**
```json
{
  "plugins": [
    ["react-native-video", {
      "enableFrameProcessors": false
    }]
  ]
}
```

## See Also

- [VisionCamera Frame Processors](https://react-native-vision-camera.com/docs/guides/frame-processors) - Similar API for camera frames
- [Playback](./playback.md) - Video playback controls
- [Events](../events/useEvent.md) - Event handling

---

## Lifecycle

# Lifecycle

Manage the player's lifecycle including initialization, preloading, and cleanup.

## Overview

| State | Description |
|-------|-------------|
| **Created** | Player exists, may not be initialized |
| **Initialized** | Native player ready, source loading |
| **Ready** | Media loaded, ready to play |
| **Released** | Resources freed, instance unusable |

## initialize()

```ts
initialize(): Promise;
```

Manually initialize the native player. Only needed with deferred initialization.

```tsx
const player = useVideoPlayer({
  uri: source,
  initializeOnCreation: false,
});

// Later, on user action
await player.initialize();
player.play();
```

**When to use:**
- Batch-creating players without immediate network cost
- Attaching event handlers before network requests
- Explicit control over when buffering begins

## preload()

```ts
preload(): Promise;
```

Start buffering without playing. Initializes if needed.

```tsx
// Preload next video for instant playback
await player.preload();

// Later
player.play(); // Instant start
```

:::warning
Preloading too many videos can cause memory issues. Limit to 2-3.
:::

## release()

```ts
release(): void;
```

Release all native resources. **Player becomes unusable after this.**

```tsx
// ❌ Wrong
player.release();
player.play(); // Throws error!

// ✅ Correct - clear source, keep player
await player.replaceSourceAsync(null);
await player.replaceSourceAsync({ uri: newSource }); // Works!
```

### When to Use

| Scenario | Use |
|----------|-----|
| Done with player permanently | `release()` |
| Might play another video later | `replaceSourceAsync(null)` |
| Switching videos | `replaceSourceAsync(newSource)` |
| Using `useVideoPlayer` hook | Automatic cleanup |

:::danger
After `release()`, any access to the player throws an error.
:::

## With useVideoPlayer

Hook manages lifecycle automatically:

```tsx
function Player() {
  // Created on mount, released on unmount
  const player = useVideoPlayer(source);
  
  return ;
}
```

## Complete Example

```tsx
import React, { useState, useEffect } from 'react';
import { View, Button, Text } from 'react-native';
import { VideoPlayer, VideoView } from 'react-native-video';

function ManualLifecycle() {
  const [player, setPlayer] = useState(null);
  const [status, setStatus] = useState('No player');

  const create = () => {
    const p = new VideoPlayer({
      uri: source,
      initializeOnCreation: false,
    });
    setPlayer(p);
    setStatus('Created');
  };

  const init = async () => {
    await player?.initialize();
    setStatus('Initialized');
  };

  const preload = async () => {
    await player?.preload();
    setStatus('Preloaded');
  };

  const release = () => {
    player?.release();
    setPlayer(null);
    setStatus('Released');
  };

  useEffect(() => {
    return () => player?.release();
  }, [player]);

  return (
    
      {player && }
      Status: {status}
      
      
      
       player?.play()} disabled={!player} />
      
    
  );
}
```

## See Also

- [useVideoPlayer](../use-video-player.md) - Hook documentation
- [Player](../player.md) - Detailed lifecycle
- [Source](./source.md) - Source management

---

## Low Latency

# Low Latency

Minimize delay between live video capture and playback for real-time experiences.

:::tip Pro Feature
Low Latency streaming is a Pro feature that enables sub-5-second latency for live content.
:::

## Overview

Traditional live streaming has 15-45 second delays. Low Latency reduces this to:

| Mode | Latency | Use Case |
|------|---------|----------|
| Standard | 15-45s | Regular broadcasts |
| Low Latency | 3-5s | Sports, news, events |
| Ultra Low Latency |  {
  _player.play();
});
```

### Low-Latency DASH (LL-DASH)

DASH-IF specification for low latency with chunked transfer encoding.

```tsx
const player = useVideoPlayer({
  uri: 'https://example.com/live/manifest.mpd',
  lowLatency: {
    enabled: true,
    targetLatency: 2,
    minLatency: 1,
    maxLatency: 5,
  },
});
```

## Configuration

### lowLatency

```ts
interface LowLatencyConfig {
  enabled: boolean;
  targetLatency?: number;
  minLatency?: number;
  maxLatency?: number;
  catchupRate?: number;
  fallbackRate?: number;
}
```

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `enabled` | `boolean` | `false` | Enable low latency mode |
| `targetLatency` | `number` | `3` | Target latency in seconds |
| `minLatency` | `number` | `1` | Minimum allowed latency |
| `maxLatency` | `number` | `8` | Maximum before catchup |
| `catchupRate` | `number` | `1.1` | Playback speed to catch up |
| `fallbackRate` | `number` | `0.95` | Playback speed when too close |

## Latency Control

### getLatency()

```ts
getLatency(): number;
```

Get current live latency in seconds.

```tsx
useEvent(player, 'onProgress', () => {
  const latency = player.getLatency();
  console.log(`Current latency: ${latency}s`);
});
```

### seekToLive()

```ts
seekToLive(): void;
```

Jump to the live edge of the stream.

```tsx
 player.seekToLive()} />
```

### isAtLiveEdge

```ts
get isAtLiveEdge(): boolean;
```

Whether playback is at the live edge.

```tsx
const [atLive, setAtLive] = useState(true);

useEvent(player, 'onProgress', () => {
  setAtLive(player.isAtLiveEdge);
});

return (
  
    {!atLive && (
       player.seekToLive()} />
    )}
  
);
```

## Events

### onLatencyChange

Fired when latency changes significantly.

```tsx
useEvent(player, 'onLatencyChange', (data) => {
  console.log('Latency:', data.latency);
  console.log('Target:', data.targetLatency);
  console.log('At live edge:', data.isAtLiveEdge);
});
```

### onLiveEdgeChange

Fired when playback enters or leaves the live edge.

```tsx
useEvent(player, 'onLiveEdgeChange', (atLiveEdge) => {
  if (!atLiveEdge) {
    showToast('You are behind live');
  }
});
```

## Best Practices

### 1. Server Configuration

Low latency requires server support:

```
# LL-HLS requirements
- Part duration: 0.2-0.5s
- Partial segments enabled
- Preload hints
- Delta updates

# LL-DASH requirements  
- Segment duration: 1-2s
- Chunked transfer encoding
- availabilityTimeOffset
```

### 2. Adaptive Latency

Adjust target based on network conditions:

```tsx
const player = useVideoPlayer({
  uri: liveStreamUrl,
  lowLatency: {
    enabled: true,
    targetLatency: 3,
    minLatency: 2,
    maxLatency: 6,
    // Speed up playback slightly to catch up when behind
    catchupRate: 1.05,
    // Slow down when too close to live edge
    fallbackRate: 0.95,
  },
});
```

### 3. Live Indicator UI

Show users their position relative to live:

```tsx
function LiveIndicator({ player }) {
  const [latency, setLatency] = useState(0);
  const [atLive, setAtLive] = useState(true);

  useEvent(player, 'onProgress', () => {
    setLatency(player.getLatency());
    setAtLive(player.isAtLiveEdge);
  });

  return (
    
      {atLive ? (
        
          ● LIVE
        
      ) : (
         player.seekToLive()}>
          
            {Math.round(latency)}s behind • Tap to go live
          
        
      )}
    
  );
}
```

## Complete Example

```tsx
import React, { useState } from 'react';
import { View, Text, TouchableOpacity } from 'react-native';
import { useVideoPlayer, useEvent, VideoView } from 'react-native-video';

function LowLatencyPlayer({ streamUrl }) {
  const player = useVideoPlayer({
    uri: streamUrl,
    lowLatency: {
      enabled: true,
      targetLatency: 3,
      minLatency: 2,
      maxLatency: 8,
    },
  }, (_player) => {
    _player.play();
  });

  const [latency, setLatency] = useState(0);
  const [atLive, setAtLive] = useState(true);

  useEvent(player, 'onProgress', () => {
    setLatency(player.getLatency());
    setAtLive(player.isAtLiveEdge);
  });

  return (
    
      
      
      
        {atLive ? (
          
            ● LIVE
          
        ) : (
           player.seekToLive()}
          >
            ⏩ Go Live ({Math.round(latency)}s behind)
          
        )}
        
        
          Latency: {latency.toFixed(1)}s
        
      
    
  );
}
```

## Platform Support

| Feature | iOS | Android |
|---------|-----|---------|
| LL-HLS | ✅ iOS 14+ | ✅ ExoPlayer |
| LL-DASH | ❌ | ✅ ExoPlayer |
| `getLatency()` | ✅ | ✅ |
| `seekToLive()` | ✅ | ✅ |
| Auto catchup | ✅ | ✅ |

## Use Cases

- **Live Sports** - Sync with real-time action
- **Live Auctions** - Fair bidding with minimal delay
- **Interactive Shows** - Real-time audience participation
- **Live Gaming** - Watch esports with crowd
- **Breaking News** - Immediate updates
- **Live Commerce** - Shop during live streams

## See Also

- [Source](./source.md) - Video configuration
- [Playback](./playback.md) - Playback controls
- [Events](../events/useEvent.md) - Event handling

---

## Multiview

# Multiview

Play multiple video streams simultaneously in a single synchronized view.

:::tip Pro Feature - Coming Soon
Multiview is a Pro feature currently in development.
:::

## Overview

Multiview enables:

- **Multiple angles** - Watch sports from different camera angles
- **Split screen** - Compare videos side by side
- **Picture-in-Picture grid** - Display 2, 4, or more streams
- **Synchronized playback** - All streams play in sync
- **Audio switching** - Choose which stream's audio to hear

## Quick Start

```tsx
import { useMultiview, MultiviewGrid } from 'react-native-video';

function MultiAnglePlayer() {
  const multiview = useMultiview([
    { uri: 'https://example.com/camera1.m3u8', label: 'Main' },
    { uri: 'https://example.com/camera2.m3u8', label: 'Goal' },
    { uri: 'https://example.com/camera3.m3u8', label: 'Tactical' },
    { uri: 'https://example.com/camera4.m3u8', label: 'Player' },
  ]);

  return (
    
  );
}
```

## useMultiview Hook

```ts
const multiview = useMultiview(sources: MultiviewSource[], config?: MultiviewConfig);
```

### MultiviewSource

```ts
interface MultiviewSource {
  uri: string;
  label?: string;
  type?: 'hls' | 'dash' | 'mp4';
  drm?: DRMConfig;
}
```

### MultiviewConfig

```ts
interface MultiviewConfig {
  syncTolerance?: number;  // Max desync in ms (default: 100)
  activeAudio?: number;    // Index of stream for audio (default: 0)
  autoSync?: boolean;      // Auto-sync streams (default: true)
}
```

## Layouts

### Built-in Layouts

```tsx
// 2x2 Grid (4 streams)

// 1+3 Layout (1 large + 3 small)

// Side by side (2 streams)

// Picture in Picture (1 large + 1 small overlay)

```

### Custom Layout

```tsx

```

## Controls

### Playback Control

```tsx
// Play all streams
multiview.play();

// Pause all streams
multiview.pause();

// Seek all streams to position
multiview.seekTo(30); // 30 seconds

// Get current time (from primary stream)
const time = multiview.currentTime;
```

### Audio Selection

```tsx
// Switch audio to stream index 2
multiview.setActiveAudio(2);

// Get current audio source
const audioIndex = multiview.activeAudio;
```

### Focus Stream

```tsx
// Expand stream to fullscreen temporarily
multiview.focusStream(1);

// Return to grid
multiview.unfocus();

// Check if focused
const isFocused = multiview.focusedStream !== null;
```

### Stream Management

```tsx
// Add stream dynamically
multiview.addStream({ uri: 'https://example.com/camera5.m3u8' });

// Remove stream
multiview.removeStream(2);

// Replace stream
multiview.replaceStream(1, { uri: 'https://example.com/alternate.m3u8' });
```

## Events

```tsx
// Stream loaded
useEvent(multiview, 'onStreamLoad', (index, data) => {
  console.log(`Stream ${index} loaded:`, data.duration);
});

// Sync status changed
useEvent(multiview, 'onSyncChange', (data) => {
  console.log('Streams synced:', data.isSynced);
  console.log('Max desync:', data.maxDesync);
});

// Audio switched
useEvent(multiview, 'onAudioChange', (index) => {
  console.log('Audio now from stream:', index);
});

// Stream error
useEvent(multiview, 'onStreamError', (index, error) => {
  console.error(`Stream ${index} error:`, error);
});
```

## Complete Example

```tsx
import React, { useState } from 'react';
import { View, TouchableOpacity, Text } from 'react-native';
import { useMultiview, MultiviewGrid, useEvent } from 'react-native-video';

const CAMERA_ANGLES = [
  { uri: 'https://example.com/main.m3u8', label: 'Main Camera' },
  { uri: 'https://example.com/goal.m3u8', label: 'Goal Line' },
  { uri: 'https://example.com/tactical.m3u8', label: 'Tactical' },
  { uri: 'https://example.com/player.m3u8', label: 'Player Cam' },
];

function SportsMultiview() {
  const [layout, setLayout] = useState('2x2');
  const [activeAudio, setActiveAudio] = useState(0);

  const multiview = useMultiview(CAMERA_ANGLES, {
    activeAudio,
    syncTolerance: 50,
  });

  const handleStreamTap = (index: number) => {
    // Double tap to focus, single tap to switch audio
    setActiveAudio(index);
    multiview.setActiveAudio(index);
  };

  return (
    
       multiview.focusStream(index)}
      />

      {/* Layout switcher */}
      
         setLayout('2x2')}>
          
            Grid
          
        
         setLayout('1+3')}>
          
            Focus
          
        
      

      {/* Audio indicator */}
      
        🔊 {CAMERA_ANGLES[activeAudio].label}
      
    
  );
}
```

## Use Cases

| Use Case | Layout | Description |
|----------|--------|-------------|
| **Sports** | 2x2, 1+3 | Multiple camera angles, tactical views |
| **E-sports** | 1+3 | Main game + player cams |
| **Surveillance** | 2x2, 3x3 | Multiple security cameras |
| **Education** | side-by-side | Instructor + slides |
| **Comparison** | side-by-side | Before/after, A/B testing |
| **Live Events** | pip | Main stage + backstage |

## Performance Tips

1. **Limit streams** - 4 streams max recommended on mobile
2. **Lower quality** - Use lower bitrates for non-focused streams
3. **Lazy loading** - Load streams as needed

```tsx
multiview.setStreamQuality(0, 'high');   // Main stream
multiview.setStreamQuality(1, 'medium'); // Secondary
multiview.setStreamQuality(2, 'low');    // Background
multiview.setStreamQuality(3, 'low');    // Background
```

## Platform Support

| Feature | iOS | Android |
|---------|-----|---------|
| 2 streams | ✅ | ✅ |
| 4 streams | ✅ | ✅ |
| 6+ streams | ⚠️ Device dependent | ⚠️ Device dependent |
| Audio switching | ✅ | ✅ |
| Synchronized seek | ✅ | ✅ |
| Custom layouts | ✅ | ✅ |

## See Also

- [Playback](./playback.md) - Single video playback
- [Low Latency](./low-latency.md) - For live multiview
- [Events](../events/useEvent.md) - Event handling

---

## Notification Controls

# Notification Controls

Show media controls in the system notification area and lock screen.

## Overview

- **Android**: Each player has its own notification + MediaSession (Google Assistant, external controls)
- **iOS**: One notification for the last active player

Usually paired with `playInBackground` to keep playback when app is backgrounded.

## showNotificationControls

```ts
get showNotificationControls(): boolean;
set showNotificationControls(value: boolean): void;
```

Enable/disable notification controls.

```tsx
const player = useVideoPlayer({
  uri: source,
  metadata: {
    title: 'Episode 42',
    artist: 'Podcast Name',
    artwork: 'https://example.com/artwork.jpg',
  },
}, (_player) => {
  _player.playInBackground = true;
  _player.showNotificationControls = true;
});
```

## Configuration Required

:::warning
Background audio must be configured:
- **Expo**: Set `enableBackgroundAudio: true`. See [Expo Plugin](../../fundamentals/configuration/expo-plugin.md#enablebackgroundaudio-optional).
- **Manual**: Add `audio` background mode to `Info.plist`. See [Manual Configuration](../../fundamentals/configuration/manual.md#enable-background-audio).
:::

### Android Manifest

```xml

  
  
    
  

```

## Metadata

Customize notification appearance with source metadata:

```tsx
const player = useVideoPlayer({
  uri: source,
  metadata: {
    title: 'Song Title',
    artist: 'Artist Name',
    artwork: 'https://example.com/cover.jpg',
  },
}, (_player) => {
  _player.showNotificationControls = true;
});
```

| Property | Description |
|----------|-------------|
| `title` | Main title |
| `artist` | Secondary text |
| `artwork` | Cover image URL |

## Testing

:::note
iOS notification controls must be tested on a **real device**. Simulator does not support them.
:::

## Complete Example

```tsx
import React from 'react';
import { View, Button } from 'react-native';
import { useVideoPlayer, VideoView } from 'react-native-video';

function PodcastPlayer() {
  const player = useVideoPlayer({
    uri: 'https://example.com/podcast.mp3',
    metadata: {
      title: 'Episode 42: The Answer',
      artist: 'My Podcast',
      artwork: 'https://example.com/cover.jpg',
    },
  }, (_player) => {
    _player.playInBackground = true;
    _player.showNotificationControls = true;
    _player.play();
  });

  return (
    
      
      
       player.isPlaying ? player.pause() : player.play()}
      />
    
  );
}
```

## See Also

- [Background](./background.md) - Background playback
- [Source](./source.md) - Metadata configuration

---

## Playback

# Playback

Control video playback including play, pause, seeking, and playback rate.

## Autoplay

Start playback immediately when the player is created using the callback:

```tsx
const player = useVideoPlayer(source, (_player) => {
  _player.play();
});
```

## play()

```ts
play(): void;
```

Start playback.

```tsx
// On button press
 player.play()} />
```

## pause()

```ts
pause(): void;
```

Pause playback.

```tsx
 player.pause()} />
```

## isPlaying

```ts
get isPlaying(): boolean;
```

Whether the player is currently playing. Read-only.

```tsx
// Toggle play/pause
 player.isPlaying ? player.pause() : player.play()} 
/>
```

## Playback Speed

### rate

```ts
get rate(): number;
set rate(value: number): void;
```

Playback speed. Default is `1.0`.

| Value | Speed |
|-------|-------|
| `0.5` | Half speed |
| `1.0` | Normal |
| `2.0` | Double speed |

**Set on creation:**
```tsx
const player = useVideoPlayer(source, (_player) => {
  _player.rate = 1.5;
});
```

**Change dynamically:**
```tsx
 player.rate = 2.0} />
```

:::note
Setting rate to `0` will pause the video.
:::

### loop

```ts
get loop(): boolean;
set loop(value: boolean): void;
```

Whether the video restarts when it ends.

**Set on creation:**
```tsx
const player = useVideoPlayer(source, (_player) => {
  _player.loop = true;
});
```

**Toggle dynamically:**
```tsx
 player.loop = !player.loop} 
/>
```

## Seeking

### seekTo()

```ts
seekTo(time: number): void;
```

Seek to a specific time in seconds.

```tsx
// Jump to 30 seconds
player.seekTo(30);

// Jump to 2 minutes
player.seekTo(120);
```

### seekBy()

```ts
seekBy(time: number): void;
```

Seek forward or backward by seconds. Negative values seek backward.

```tsx
// Skip controls
 player.seekBy(-10)} />
 player.seekBy(10)} />
```

:::note
Time is automatically clamped to valid range (0 to duration).
:::

## Time Properties

### currentTime

```ts
get currentTime(): number;
set currentTime(value: number): void;
```

Current playback position in seconds.

```tsx
// Get current time
console.log(player.currentTime);

// Set current time (same as seekTo)
player.currentTime = 60;
```

### duration

```ts
get duration(): number;
```

Total duration in seconds. Read-only.

```tsx
useEvent(player, 'onLoad', (data) => {
  console.log('Duration:', data.duration);
});
```

:::note
Returns `NaN` before `onLoad` event fires.
:::

## Complete Example

```tsx
import React, { useState } from 'react';
import { View, Button, Text, Slider } from 'react-native';
import { useVideoPlayer, useEvent, VideoView } from 'react-native-video';

function PlayerControls() {
  const player = useVideoPlayer(source, (_player) => {
    _player.play(); // Autoplay
    _player.loop = true;
  });

  const [currentTime, setCurrentTime] = useState(0);
  const [duration, setDuration] = useState(0);

  useEvent(player, 'onLoad', (data) => setDuration(data.duration));
  useEvent(player, 'onProgress', (data) => setCurrentTime(data.currentTime));

  const formatTime = (sec: number) => {
    const m = Math.floor(sec / 60);
    const s = Math.floor(sec % 60);
    return `${m}:${s.toString().padStart(2, '0')}`;
  };

  return (
    
      
      
       player.seekTo(v)}
      />
      
      {formatTime(currentTime)} / {formatTime(duration)}
      
      
         player.seekBy(-10)} />
         player.isPlaying ? player.pause() : player.play()} 
        />
         player.seekBy(10)} />
      
      
      
        {[0.5, 1, 1.5, 2].map(speed => (
           player.rate = speed} />
        ))}
      
    
  );
}
```

---

## Source

# Source

Manage video source and configuration.

## source

```ts
get source(): VideoPlayerSource;
```

Current video source. Read-only. Use `replaceSourceAsync()` to change.

```tsx
console.log('Playing:', player.source.uri);
```

## replaceSourceAsync()

```ts
replaceSourceAsync(source: VideoSource | VideoConfig | null): Promise;
```

Replace the current video source.

```tsx
// Change video
await player.replaceSourceAsync({ uri: 'https://example.com/video2.mp4' });
player.play();

// Clear source (free resources)
await player.replaceSourceAsync(null);
```

:::tip
Use `replaceSourceAsync(null)` to free resources while keeping the player instance.
:::

---

## Types

### VideoSource

```ts
type VideoSource = string | number;
```

- **URL**: `'https://example.com/video.mp4'`
- **Local file**: `require('./assets/video.mp4')`

### VideoConfig

```ts
interface VideoConfig {
  uri: VideoSource;
  headers?: Record;
  drm?: DrmParams;
  bufferConfig?: BufferConfig;
  metadata?: CustomVideoMetadata;
  externalSubtitles?: ExternalSubtitle[];
  initializeOnCreation?: boolean;
}
```

| Property | Type | Description |
|----------|------|-------------|
| `uri` | `VideoSource` | Video URL or local file. Required. |
| `headers?` | `Record` | HTTP headers |
| `drm?` | `DrmParams` | DRM config. See [DRM](../drm.md). |
| `bufferConfig?` | `BufferConfig` | Buffer config. See [useVideoPlayer](../use-video-player.md#buffer-config). |
| `metadata?` | `CustomVideoMetadata` | Metadata for notifications |
| `externalSubtitles?` | `ExternalSubtitle[]` | External subtitle tracks |
| `initializeOnCreation?` | `boolean` | Initialize immediately. Default: `true`. |

---

## Examples

**Basic:**
```tsx
const player = useVideoPlayer({ uri: 'https://example.com/video.mp4' });
```

**With headers:**
```tsx
const player = useVideoPlayer({
  uri: 'https://api.example.com/video.mp4',
  headers: { 'Authorization': 'Bearer token' },
});
```

**With subtitles:**
```tsx
const player = useVideoPlayer({
  uri: 'https://example.com/video.mp4',
  externalSubtitles: [
    { uri: 'https://example.com/en.vtt', label: 'English', language: 'en', type: 'vtt' },
    { uri: 'https://example.com/es.vtt', label: 'Español', language: 'es', type: 'vtt' },
  ],
});
```

**With metadata (for notifications):**
```tsx
const player = useVideoPlayer({
  uri: 'https://example.com/video.mp4',
  metadata: {
    title: 'Big Buck Bunny',
    artist: 'Blender Foundation',
    artwork: 'https://example.com/thumb.jpg',
  },
}, (_player) => {
  _player.showNotificationControls = true;
});
```

**Deferred initialization:**
```tsx
const player = useVideoPlayer({
  uri: 'https://example.com/video.mp4',
  initializeOnCreation: false,
});

// Later
await player.initialize();
player.play();
```

---

## Playlist Example

```tsx
function PlaylistPlayer() {
  const videos = [
    'https://example.com/video1.mp4',
    'https://example.com/video2.mp4',
    'https://example.com/video3.mp4',
  ];
  const [index, setIndex] = useState(0);

  const player = useVideoPlayer({ uri: videos[index] }, (_player) => {
    _player.play();
  });

  useEvent(player, 'onEnd', async () => {
    const next = (index + 1) % videos.length;
    await player.replaceSourceAsync({ uri: videos[next] });
    setIndex(next);
    player.play();
  });

  return (
    
      
      Playing: {index + 1} / {videos.length}
      {/* ... */}
    
  );
}
```

---

## Status

# Status

Monitor player status and manage event listeners.

## status

```ts
get status(): VideoPlayerStatus;
```

Current player status. Read-only.

```tsx
useEvent(player, 'onStatusChange', (status) => {
  console.log('Status:', status);
});
```

### VideoPlayerStatus Values

| Status | Description |
|--------|-------------|
| `'idle'` | No source loaded |
| `'loading'` | Source loading |
| `'ready'` | Ready to play |
| `'playing'` | Playing |
| `'paused'` | Paused |
| `'buffering'` | Buffering |
| `'ended'` | Reached end |
| `'error'` | Error occurred |

```tsx
function StatusIcon({ player }) {
  const [status, setStatus] = useState(player.status);
  
  useEvent(player, 'onStatusChange', setStatus);

  switch (status) {
    case 'loading':
    case 'buffering':
      return ;
    case 'playing':
      return ;
    case 'ended':
      return ;
    case 'error':
      return ;
    default:
      return ;
  }
}
```

---

## Event Management

### addEventListener()

```ts
addEventListener(event, callback): ListenerSubscription;
```

Add event listener. Returns subscription to remove it.

```tsx
const subscription = player.addEventListener('onProgress', (data) => {
  console.log('Time:', data.currentTime);
});

// Later
subscription.remove();
```

:::tip
In React, prefer `useEvent` hook for automatic cleanup.
:::

### clearAllEvents()

```ts
clearAllEvents(): void;
```

Remove all event listeners.

```tsx
player.clearAllEvents();
```

---

## Events

### onStatusChange

```tsx
useEvent(player, 'onStatusChange', (status) => {
  if (status === 'ready') console.log('Ready to play');
  if (status === 'buffering') console.log('Buffering...');
});
```

### onError

```tsx
useEvent(player, 'onError', (error) => {
  console.error('Error:', error.code, error.message);
});
```

---

## Complete Example

```tsx
import React, { useState } from 'react';
import { View, Text, ActivityIndicator, TouchableOpacity } from 'react-native';
import { useVideoPlayer, useEvent, VideoView, VideoPlayerStatus } from 'react-native-video';

function StatusPlayer() {
  const player = useVideoPlayer(source);

  const [status, setStatus] = useState('idle');
  const [error, setError] = useState(null);

  useEvent(player, 'onStatusChange', setStatus);
  useEvent(player, 'onError', (err) => setError(err.message));

  const getColor = () => {
    switch (status) {
      case 'playing': return '#4CAF50';
      case 'paused': return '#FFC107';
      case 'buffering': return '#2196F3';
      case 'error': return '#F44336';
      default: return '#757575';
    }
  };

  return (
    
      
        

        {(status === 'loading' || status === 'buffering') && (
          
            
          
        )}

        {status === 'error' && (
          
            ⚠️ {error}
          
        )}
      

      
        
        {status.toUpperCase()}
      

       {
        if (status === 'playing') player.pause();
        else if (status === 'ended') { player.seekTo(0); player.play(); }
        else player.play();
      }}>
        
          {status === 'playing' ? 'Pause' : status === 'ended' ? 'Replay' : 'Play'}
        
      
    
  );
}
```

## See Also

- [Events](../events/useEvent.md) - Event handling
- [Playback](./playback.md) - Playback control

---

## Text Tracks

# Text Tracks

Manage subtitles and closed captions.

## Overview

Text tracks can come from:
- **Embedded** - Built into video (HLS, DASH)
- **External** - Separate files (VTT, SRT)

## selectedTrack

```ts
get selectedTrack(): TextTrack | undefined;
```

Currently selected track, or `undefined` if none.

```tsx
useEvent(player, 'onTrackChange', (track) => {
  console.log(track ? `Subtitles: ${track.label}` : 'Subtitles: Off');
});
```

## getAvailableTextTracks()

```ts
getAvailableTextTracks(): TextTrack[];
```

Get all available tracks after video loads.

```tsx
useEvent(player, 'onLoad', () => {
  const tracks = player.getAvailableTextTracks();
  console.log('Available:', tracks);
});
```

## selectTextTrack()

```ts
selectTextTrack(textTrack: TextTrack | null): void;
```

Select a track or disable subtitles.

```tsx
// Enable English
const tracks = player.getAvailableTextTracks();
const en = tracks.find(t => t.language === 'en');
if (en) player.selectTextTrack(en);

// Disable
player.selectTextTrack(null);
```

## External Subtitles

Load from external files:

```tsx
const player = useVideoPlayer({
  uri: 'https://example.com/video.mp4',
  externalSubtitles: [
    { uri: 'https://example.com/en.vtt', label: 'English', language: 'en', type: 'vtt' },
    { uri: 'https://example.com/es.vtt', label: 'Español', language: 'es', type: 'vtt' },
  ],
});
```

**Supported formats:** VTT (recommended), SRT

---

## Types

### TextTrack

```ts
interface TextTrack {
  id: string;
  label: string;
  language?: string;
  selected: boolean;
}
```

### ExternalSubtitle

```ts
interface ExternalSubtitle {
  uri: string;
  label: string;
  language: string;
  type: 'vtt' | 'srt';
}
```

---

## Events

### onTrackChange

```tsx
useEvent(player, 'onTrackChange', (track) => {
  // track is null when subtitles disabled
});
```

### onTextTrackDataChanged

Fired when current subtitle text changes.

```tsx
useEvent(player, 'onTextTrackDataChanged', (texts) => {
  console.log('Current text:', texts);
});
```

---

## Complete Example

```tsx
import React, { useState } from 'react';
import { View, Button, Modal, TouchableOpacity, Text } from 'react-native';
import { useVideoPlayer, useEvent, VideoView } from 'react-native-video';

function SubtitlePicker() {
  const player = useVideoPlayer({
    uri: source,
    externalSubtitles: [
      { uri: 'https://example.com/en.vtt', label: 'English', language: 'en', type: 'vtt' },
      { uri: 'https://example.com/es.vtt', label: 'Español', language: 'es', type: 'vtt' },
    ],
  });

  const [tracks, setTracks] = useState([]);
  const [current, setCurrent] = useState();
  const [show, setShow] = useState(false);

  useEvent(player, 'onLoad', () => setTracks(player.getAvailableTextTracks()));
  useEvent(player, 'onTrackChange', (t) => setCurrent(t ?? undefined));

  const select = (track: TextTrack | null) => {
    player.selectTextTrack(track);
    setShow(false);
  };

  return (
    
      
      
       setShow(true)}
      />

      
        
           select(null)}>
            Off {!current && '✓'}
          
          
          {tracks.map(track => (
             select(track)}>
              {track.label} {track.selected && '✓'}
            
          ))}
          
           setShow(false)} />
        
      
    
  );
}
```

## See Also

- [Source](./source.md) - External subtitles config
- [Events](../events/useEvent.md) - Event handling

---

## useVideoPlayer

# useVideoPlayer

The recommended way to create and manage a `VideoPlayer` instance in React components.

## Basic Usage

```tsx
import { useVideoPlayer, VideoView } from 'react-native-video';

function Player() {
  const player = useVideoPlayer(source, (_player) => {
    _player.play();
  });

  return ;
}
```

## With Configuration

```tsx
const player = useVideoPlayer({
  uri: 'https://example.com/video.mp4',
  headers: { Authorization: 'Bearer token' },
}, (_player) => {
  _player.loop = true;
  _player.volume = 0.8;
  _player.play();
});
```

## Benefits

- **Automatic cleanup** - Resources released on unmount
- **Dependency management** - Recreates player when source changes
- **Lifecycle management** - No manual `release()` needed

:::tip
For advanced lifecycle control or non-React contexts, see [Player](./player.md).
:::

## Core Functionality

The `VideoPlayer` class offers a comprehensive set of methods and properties to control video playback:

### Playback Control

| Method | Description |
|--------|-------------|
| `play()` | Starts or resumes video playback. |
| `pause()` | Pauses video playback. |
| `seekBy(time: number)` | Seeks the video forward or backward by the specified number of seconds. |
| `seekTo(time: number)` | Seeks the video to a specific time in seconds. |
| `replaceSourceAsync(source: VideoSource \| VideoConfig \| null)` | Replaces the current video source with a new one. Pass `null` to release the current source without replacing it. |
| `initialize()` | Manually initialize the underlying native player item when `initializeOnCreation` was set to `false`. No-op if already initialized. |
| `preload()` | Ensures the media source is set and prepared (buffering started) without starting playback. If not yet initialized it will initialize first. |
| `release()` | Releases the player's native resources. The player is no longer usable after calling this method. **Note:** If you intend to reuse the player instance with a different source, use `replaceSourceAsync(null)` to clear resources instead of `release()`. |

### Properties

| Property | Access | Type | Description |
|----------|--------|------|-------------|
| `source` | Read-only | `VideoPlayerSource` | Gets the current `VideoPlayerSource` object. |
| `status` | Read-only | `VideoPlayerStatus` | Gets the current status (e.g., `playing`, `paused`, `buffering`). |
| `duration` | Read-only | `number` | Gets the total duration of the video in seconds. Returns `NaN` until metadata is loaded. |
| `volume` | Read/Write | `number` | Gets or sets the player volume (0.0 to 1.0). |
| `currentTime` | Read/Write | `number` | Gets or sets the current playback time in seconds. |
| `muted` | Read/Write | `boolean` | Gets or sets whether the video is muted. |
| `loop` | Read/Write | `boolean` | Gets or sets whether the video should loop. |
| `rate` | Read/Write | `number` | Gets or sets the playback rate (e.g., 1.0 for normal speed, 0.5 for half speed, 2.0 for double speed). |
| `mixAudioMode` | Read/Write | `MixAudioMode` | Controls how this player's audio mixes with other audio sources (see [MixAudioMode](./usage/audio.md#mixaudiomode-1)). |
| `ignoreSilentSwitchMode` | Read/Write | `IgnoreSilentSwitchMode` | iOS-only. Determines how audio should behave when the hardware mute (silent) switch is on. |
| `playInBackground` | Read/Write | `boolean` | Whether playback should continue when the app goes to the background. |
| `playWhenInactive` | Read/Write | `boolean` | Whether playback should continue when the app is inactive (e.g., during a phone call). |
| `isPlaying` | Read-only | `boolean` | Returns `true` if the video is currently playing. |
| `selectedTrack` | Read-only | `TextTrack \| undefined` | Currently selected text track, or `undefined` when no track is selected. |

### Error Handling

| Property | Type | Description |
|----------|------|-------------|
| `onError?` | `(error: VideoRuntimeError) => void` | A callback function that is invoked when a runtime error occurs in the player. You can use this to catch and handle errors gracefully. |

### Buffer Config

You can fine‑tune buffering via `bufferConfig` on the `VideoConfig` you pass to `useVideoPlayer`/`VideoPlayer`. This controls how much data is buffered, live latency targets, and iOS network constraints.

Example

```ts
const player = useVideoPlayer({
  source: {
    uri: 'https://example.com/stream.m3u8',
    bufferConfig: {
      // Android
      minBufferMs: 5000,
      maxBufferMs: 10000,
      // iOS
      preferredForwardBufferDurationMs: 3000,
      // Live (cross‑platform target)
      livePlayback: { targetOffsetMs: 500 },
    },
  },
});
```

#### Android
Properties below are Android‑only

| Property | Type | Description |
|----------|------|-------------|
| `minBufferMs` | `number` | Minimum media duration the player attempts to keep buffered (ms). Default: 5000. |
| `maxBufferMs` | `number` | Maximum media duration the player attempts to buffer (ms). Default: 10000. |
| `bufferForPlaybackMs` | `number` | Media that must be buffered before playback can start or resume after user action (ms). Default: 1000. |
| `bufferForPlaybackAfterRebufferMs` | `number` | Media that must be buffered to resume after a rebuffer (ms). Default: 2000. |
| `backBufferDurationMs` | `number` | Duration kept behind the current position to allow instant rewind without rebuffer (ms). |
| `livePlayback.minPlaybackSpeed` | `number` | Minimum playback speed used to maintain target live offset. |
| `livePlayback.maxPlaybackSpeed` | `number` | Maximum playback speed used to catch up to target live offset. |
| `livePlayback.minOffsetMs` | `number` | Minimum allowed live offset (ms). |
| `livePlayback.maxOffsetMs` | `number` | Maximum allowed live offset (ms). |
| `livePlayback.targetOffsetMs` | `number` | Target live offset the player tries to maintain (ms). |

#### iOS, visionOS, tvOS
Properties below are Apple platforms‑only

| Property | Type | Description |
|----------|------|-------------|
| `preferredForwardBufferDurationMs` | `number` | Preferred duration the player attempts to retain ahead of the playhead (ms). |
| `preferredPeakBitRate` | `number` | Desired limit of network bandwidth for loading the current item (bits per second). |
| `preferredMaximumResolution` | `{ width: number; height: number }` | Preferred maximum video resolution. |
| `preferredPeakBitRateForExpensiveNetworks` | `number` | Bandwidth limit for expensive networks (e.g., cellular), in bits per second. |
| `preferredMaximumResolutionForExpensiveNetworks` | `{ width: number; height: number }` | Preferred maximum resolution on expensive networks. |
| `livePlayback.targetOffsetMs` | `number` | Target live offset (ms) the player will try to maintain. |

## DRM

Protected content is supported via a plugin. See the full DRM guide: [DRM](./drm.md).

Quick notes:
- Install and enable the official plugin `@react-native-video/drm` and call `enable()` at app startup before creating players.
- Pass DRM configuration on the source using the `drm` property of `VideoConfig` (see the DRM guide for platform specifics and `getLicense` examples).
- If you defer initialization (`initializeOnCreation: false`), be sure to call `await player.initialize()` (or `preload()`) before expecting DRM license acquisition events.

---

## Plugin Usage Examples

# Plugin Usage Examples

This document provides practical examples of implementing common plugin scenarios for React Native Video.

## Basic Plugin Template

```kotlin title="Android"
class MyPlugin : ReactNativeVideoPlugin("MyPlugin") {
    override fun onPlayerCreated(player: WeakReference) {
        Log.d("MyPlugin", "Player created with uri ${player.get()?.source.uri}")
    }
    
    override fun onPlayerDestroyed(player: WeakReference) {
        Log.d("MyPlugin", "Player destroyed")
    }
    
    override fun overrideSource(source: NativeVideoPlayerSource): NativeVideoPlayerSource {
        Log.d("MyPlugin", "Overriding source with uri ${source.uri}")
        return source
    }
}

// Usage
val plugin = MyPlugin() // Automatically registered
```

```swift title="iOS"
class MyPlugin: ReactNativeVideoPlugin {
    init() {
        super.init(name: "MyPlugin")
    }
    
    override func onPlayerCreated(player: Weak) {
        // Custom logic when player is created
    }
    
    override func onPlayerDestroyed(player: Weak) {
        // Custom cleanup when player is destroyed
    }
    
    override func overrideSource(source: NativeVideoPlayerSource) async -> NativeVideoPlayerSource {
        // Modify source if needed
        return source
    }
}

// Usage
let plugin = MyPlugin() // Automatically registered
```

## DRM Plugin

Implement custom DRM handling for protected content.

:::warning

DRM plugins are not supported yet in React Native Video. `getDRMManager` is not implemented yet and will have no effect.

:::

```kotlin title="Android"
class CustomDRMPlugin : ReactNativeVideoPlugin("CustomDRM") {
    override fun getDRMManager(source: NativeVideoPlayerSource): Any? {
        if (source.isDRMProtected() && source.drmType == "custom") {
            return CustomDRMManager(
                licenseUrl = source.drmLicenseUrl,
                certificateUrl = source.drmCertificateUrl,
                keyId = source.drmKeyId
            )
        }
        return null
    }
}
```

```swift title="iOS"
class CustomDRMPlugin: ReactNativeVideoPlugin {
    init() {
        super.init(name: "CustomDRM")
    }
    
    override func getDRMManager(source: NativeVideoPlayerSource) async -> Any? {
        guard source.isDRMProtected() && source.drmType == "custom" else {
            return nil
        }
        
        return CustomDRMManager(
            licenseUrl: source.drmLicenseUrl,
            certificateUrl: source.drmCertificateUrl,
            keyId: source.drmKeyId
        )
    }
}
```

---

## Plugin Interface

# Plugin Interface Reference

This document provides a complete reference for the `ReactNativeVideoPluginSpec` interface and the base `ReactNativeVideoPlugin` implementation.

## ReactNativeVideoPluginSpec Interface

### Required Properties

#### id: String
Unique identifier for the plugin. Must be unique across all registered plugins.

```kotlin
// Android
override val id: String = "my_unique_plugin_id"
```

```swift
// iOS
var id: String { "my_unique_plugin_id" }
```

#### name: String
Human-readable name for the plugin, used in debug logging.

```kotlin
// Android
override val name: String = "My Custom Plugin"
```

```swift
// iOS
var name: String { "My Custom Plugin" }
```

## Lifecycle Methods

### Player Lifecycle

#### onPlayerCreated
Called when a new player instance is created.

```kotlin
// Android
@UnstableApi
fun onPlayerCreated(player: WeakReference)
```

```swift
// iOS
func onPlayerCreated(player: Weak)
```

**Parameters:**
- `player`: Weak reference to the newly created player instance

**Use Cases:**
- Initialize player-specific resources
- Set up player event listeners
- Configure player settings

#### onPlayerDestroyed
Called when a player instance is being destroyed.

```kotlin
// Android
@UnstableApi
fun onPlayerDestroyed(player: WeakReference)
```

```swift
// iOS
func onPlayerDestroyed(player: Weak)
```

**Parameters:**
- `player`: Weak reference to the player instance being destroyed

**Use Cases:**
- Clean up player-specific resources
- Remove event listeners
- Save state or analytics data

### Video View Lifecycle

#### onVideoViewCreated
Called when a new video view is created.

```kotlin
// Android
@UnstableApi
fun onVideoViewCreated(view: WeakReference)
```

```swift
// iOS
func onVideoViewCreated(view: Weak)
```

**Parameters:**
- `view`: Weak reference to the newly created video view

**Use Cases:**
- Configure view-specific settings
- Set up UI event handlers
- Initialize view overlays

#### onVideoViewDestroyed
Called when a video view is being destroyed.

```kotlin
// Android
@UnstableApi
fun onVideoViewDestroyed(view: WeakReference)
```

```swift
// iOS
func onVideoViewDestroyed(view: Weak)
```

**Parameters:**
- `view`: Weak reference to the video view being destroyed

**Use Cases:**
- Clean up view-specific resources
- Remove UI event handlers
- Save view state

## Content Modification Methods

### overrideSource
Modify the video source before it's processed by the player.

```kotlin
// Android
fun overrideSource(source: NativeVideoPlayerSource): NativeVideoPlayerSource
```

```swift
// iOS
func overrideSource(source: NativeVideoPlayerSource) async -> NativeVideoPlayerSource
```

**Parameters:**
- `source`: The original video source

**Returns:**
- Modified video source (can be the same instance if no changes needed)

**Use Cases:**
- Add authentication headers
- Modify URLs (e.g., CDN switching)
- Add tracking parameters
- Transform source format

### getDRMManager
Provide a custom DRM manager for protected content.

```kotlin
// Android
fun getDRMManager(source: NativeVideoPlayerSource): Any?
```

```swift
// iOS
func getDRMManager(source: NativeVideoPlayerSource) async -> Any?
```

**Parameters:**
- `source`: The video source that may require DRM

**Returns:**
- DRM manager instance, or `null` if this plugin doesn't handle DRM for this source

**Use Cases:**
- Widevine DRM implementation
- FairPlay DRM implementation
- Custom DRM solutions
- License acquisition logic

## Android-Specific Methods

### getMediaDataSourceFactory
Override the data source factory used by ExoPlayer.

```kotlin
fun getMediaDataSourceFactory(
    source: NativeVideoPlayerSource,
    mediaDataSourceFactory: DataSource.Factory
): DataSource.Factory?
```

**Parameters:**
- `source`: The video source
- `mediaDataSourceFactory`: The default data source factory

**Returns:**
- Custom data source factory, or `null` to use the default

**Use Cases:**
- Custom caching strategies
- Network optimization
- Custom authentication
- Analytics data collection

### getMediaSourceFactory
Override the media source factory used by ExoPlayer.

```kotlin
fun getMediaSourceFactory(
    source: NativeVideoPlayerSource,
    mediaSourceFactory: MediaSource.Factory,
    mediaDataSourceFactory: DataSource.Factory
): MediaSource.Factory?
```

**Parameters:**
- `source`: The video source
- `mediaSourceFactory`: The default media source factory
- `mediaDataSourceFactory`: The data source factory

**Returns:**
- Custom media source factory, or `null` to use the default

**Use Cases:**
- Custom media format support
- Advanced ExoPlayer configuration
- Source-specific optimizations

### getMediaItemBuilder
Override the media item builder used by ExoPlayer.

```kotlin
fun getMediaItemBuilder(
    source: NativeVideoPlayerSource,
    mediaItemBuilder: MediaItem.Builder
): MediaItem.Builder?
```

**Parameters:**
- `source`: The video source
- `mediaItemBuilder`: The default media item builder

**Returns:**
- Modified media item builder, or `null` to use the default

**Use Cases:**
- Add custom metadata
- Configure subtitles
- Set playback preferences
- Configure DRM settings

### shouldDisableCache
Control whether caching should be disabled for a source.

```kotlin
fun shouldDisableCache(source: NativeVideoPlayerSource): Boolean
```

**Parameters:**
- `source`: The video source

**Returns:**
- `true` to disable caching, `false` to allow caching

**Use Cases:**
- Disable caching for live streams
- Disable caching for DRM content
- Custom caching policies

## Base Implementation: ReactNativeVideoPlugin

The base class provides default implementations for all methods:

### Automatic Registration
```kotlin
// Android
init {
    PluginsRegistry.shared.register(this)
}
```

```swift
// iOS
public init(name: String) {
    self.name = name
    self.id = "RNV_Plugin_\(name)"
    PluginsRegistry.shared.register(plugin: self)
}
```

### Automatic Cleanup (iOS only)
```swift
deinit {
    PluginsRegistry.shared.unregister(plugin: self)
}
```

### Default Implementations

All methods have sensible defaults:
- Lifecycle methods: No-op implementations
- `overrideSource`: Returns the original source unchanged
- `getDRMManager`: Returns `null`
- Factory methods (Android): Return `null` (use defaults)
- `shouldDisableCache`: Returns `false`

## Method Calling Order

### Source Processing Flow
1. `overrideSource` - Called for each registered plugin in order
2. `getDRMManager` - Called for each plugin until one returns non-null
3. Factory methods (Android) - Called for each plugin until one returns non-null

### Lifecycle Flow
1. View/Player creation methods called for all plugins
2. Source processing happens during playback
3. View/Player destruction methods called for all plugins

## Error Handling

### DRM Plugin Not Found
If no plugin provides a DRM manager when required:

```kotlin
// Android
throw LibraryError.DRMPluginNotFound
```

```swift
// iOS
throw LibraryError.DRMPluginNotFound.error()
```

### Best Practices
- Return `null` from optional methods when not providing custom behavior
- Handle weak reference nullability properly
- Use appropriate error handling in async methods (iOS)
- Log meaningful debug information

## Platform Differences Summary

| Feature | Android | iOS |
|---------|---------|-----|
| Async Support | No | Yes (async/await) |
| Media Factories | Full ExoPlayer support | Limited AVFoundation |
| Cache Control | Yes | No |
| Auto Cleanup | Manual | Automatic (deinit) |
| Weak References | `WeakReference` | `Weak` |

---

## Plugins

# Plugins Overview

The **React Native Video** library offers a robust plugin system to extend and customize video functionality on Android and iOS. With plugins, you can override source handling, implement custom DRM, modify media factories, and respond to player lifecycle events.

:::tip Use in Third Party Library Guide
If you are looking how to import React Native Video in your native code to use plugins, you can checkout [Use in Third Party Library](./use-in-third-party-library.md) page.
:::

## What Are Plugins?

Plugins are modular extensions that hook into the video player's lifecycle and processing pipeline. They allow you to:

-  **Customize video sources** before playback
-  **Implement custom DRM** for protected content
-  **Override media factories** (Android only)
-  **React to player lifecycle events** for analytics, logging, or cleanup
-  **Control caching behavior** for performance

## Architecture

The plugin system consists of three main components:

| Component                    | Description                                                                                 |
|:-----------------------------|:-------------------------------------------------------------------------------------------|
| `PluginsRegistry`            | Singleton that manages plugin registration and coordinates plugin interactions              |
| `ReactNativeVideoPluginSpec` | Interface/protocol defining the contract all plugins must implement                        |
| `ReactNativeVideoPlugin`     | Base implementation with convenient defaults; override only the methods you care about     |

:::tip
Plugins are automatically registered when you instantiate a class that extends `ReactNativeVideoPlugin`.  
:::

## Core Concepts

### Plugin Lifecycle

Plugins receive notifications for key events:

-  **Player creation/destruction** — react to player instance lifecycle
-  **Video view creation/destruction** — handle UI component lifecycle
-  **Source processing** — modify video sources before playback
-  **DRM requests** — provide custom DRM handling
-  **Media factory overrides** — customize ExoPlayer components (Android)

:::caution
All player and view references passed to plugins are **weak references** to prevent memory leaks.
:::

## Platform Differences

| Feature                        | Android (Kotlin / ExoPlayer)                   | iOS (Swift / AVFoundation)         |
|:-------------------------------|:-----------------------------------------------|:-----------------------------------|
| Underlying player              | ExoPlayer                                      | AVFoundation                       |
| Media factory customization    | Extensive                                      | Limited                            |
| Cache control                  | Supported                                      | Limited                            |
| Plugin method style            | Synchronous                                    | Async/await                        |
| Memory management              | Manual cleanup                                 | Manual cleanup                     |

## Getting Started

### Example: Android Plugin

```kotlin
// Android
class MyPlugin : ReactNativeVideoPlugin("MyPluginName") {
    override fun onPlayerCreated(player: WeakReference) {
        // Custom logic here
    }
}
```

### Example: iOS Plugin

```swift
// iOS
class MyPlugin: ReactNativeVideoPlugin {
    init() {
        super.init(name: "MyPluginName")
    }

    override func onPlayerCreated(player: Weak) {
        // Custom logic here
    }
}
```

## Next Steps

-  [**Plugin Registry**](./registry) — Learn about plugin management and registration
-  [**Plugin Interface**](./interface) — Complete API reference for plugin methods
-  [**Usage Examples**](./examples) — Practical implementations and common patterns

---

## Plugin Registry

# Plugin Registry

The `PluginsRegistry` is a singleton that manages all plugin instances and coordinates their interactions with the video player system. It handles registration, unregistration, and notification distribution to all active plugins.

## Singleton Pattern

Both Android and iOS use a shared singleton:

```kotlin title="Android"
// Register
PluginsRegistry.shared.register(plugin)
// Unregister
PluginsRegistry.shared.unregister(plugin)
```

```swift title="iOS"
// Register
PluginsRegistry.shared.register(plugin: plugin)
// Unregister
PluginsRegistry.shared.unregister(plugin: plugin)
```

:::tip Plugin Ordering
Plugins are processed in registration order. Later plugins can override earlier ones.
:::

## Registration Methods

### Automatic Registration

You can use the base class `ReactNativeVideoPlugin` to automatically register your plugin. This will also mock all the methods that are not implemented in your plugin. 

:::danger
You still need to unregister your plugin manually when you are done with it. Otherwise, you will have a memory leak.
:::

```kotlin title="Android"
class MyPlugin : ReactNativeVideoPlugin("MyPlugin") {
    // ...
}
val plugin = MyPlugin() // Auto-registered
```

```swift title="iOS"
class MyPlugin: ReactNativeVideoPlugin {
    init() {
        super.init(name: "MyPlugin")
    }
    // Auto-unregistered in deinit
}
let plugin = MyPlugin() // Auto-registered
```

### Manual Registration

You can also manually register your plugin. This is useful if you want to implement a plugin that is not a subclass of `ReactNativeVideoPlugin`.
You will need to implement the `ReactNativeVideoPluginSpec` interface. This is a protocol that defines the methods and properties that a plugin must implement.

```kotlin title="Android"
class MyCustomPlugin : ReactNativeVideoPluginSpec {
    override val id = "my_custom_id"
    override val name = "MyCustomPlugin"
    // ...
}
val plugin = MyCustomPlugin()
PluginsRegistry.shared.register(plugin)
```

```swift title="iOS"
class MyCustomPlugin: ReactNativeVideoPluginSpec {
    let id = "my_custom_id"
    let name = "MyCustomPlugin"
    // ...
}
let plugin = MyCustomPlugin()
PluginsRegistry.shared.register(plugin: plugin)
```

## Plugin ID Generation

When using the base class, IDs are auto-generated:

```kotlin title="Android"
ID Format: "RNV_Plugin_{name}"
Example: "RNV_Plugin_MyCustomDRM"
```

```swift title="iOS"
ID Format: "RNV_Plugin_{name}"
Example: "RNV_Plugin_MyCustomDRM"
```

## Plugin Internals

Bellow are the internals of the plugin registry, that shows logic for certain methods.

### Source Processing

The registry coordinates source modifications:

```kotlin title="Android"
internal fun overrideSource(source: NativeVideoPlayerSource): NativeVideoPlayerSource {
    var overriddenSource = source
    for (plugin in plugins.values) {
        overriddenSource = plugin.overrideSource(overriddenSource)
    }
    return overriddenSource
}
```

```swift title="iOS"
internal func overrideSource(source: NativeVideoPlayerSource) async -> NativeVideoPlayerSource {
    var overriddenSource = source
    for plugin in plugins.values {
        overriddenSource = await plugin.overrideSource(source: source)
    }
    return overriddenSource
}
```

### DRM Manager Resolution

Finds the first plugin that can provide a DRM manager:

```kotlin title="Android"
internal fun getDRMManager(source: NativeVideoPlayerSource): Any {
    for (plugin in plugins.values) {
        val manager = plugin.getDRMManager(source)
        if (manager != null) return manager
    }
    throw LibraryError.DRMPluginNotFound
}
```

```swift title="iOS"
internal func getDrmManager(source: NativeVideoPlayerSource) async throws -> Any? {
    for plugin in plugins.values {
        if let drmManager = await plugin.getDRMManager(source: source) {
            return drmManager
        }
    }
    throw LibraryError.DRMPluginNotFound.error()
}
```

## Android-Specific Registry Methods

| Method Name                       | Purpose                                                   |
|:----------------------------------|:----------------------------------------------------------|
| `overrideMediaDataSourceFactory`  | Override data source factory for custom ExoPlayer sources  |
| `overrideMediaSourceFactory`      | Override media source factory                             |
| `overrideMediaItemBuilder`        | Customize the media item builder                          |
| `shouldDisableCache`              | Control caching behavior                                  |

Example signatures:

```kotlin
internal fun overrideMediaDataSourceFactory(
    source: NativeVideoPlayerSource,
    mediaDataSourceFactory: DataSource.Factory
): DataSource.Factory

internal fun overrideMediaSourceFactory(
    source: NativeVideoPlayerSource,
    mediaSourceFactory: MediaSource.Factory,
    mediaDataSourceFactory: DataSource.Factory
): MediaSource.Factory

internal fun overrideMediaItemBuilder(
    source: NativeVideoPlayerSource,
    mediaItemBuilder: MediaItem.Builder
): MediaItem.Builder

internal fun shouldDisableCache(source: NativeVideoPlayerSource): Boolean
```

## Best Practices

-  **Memory management**: Registry holds strong references to plugins; plugins get weak references to players/views.
-  **Unregister plugins**: Use unregistration to prevent memory leaks.
-  **Performance**: Minimize work in notification handlers. Cache expensive operations. Be mindful of plugin order.

---

## Use in Third Party Library

# Use in Third Party Library

You can use React Native Video in your third party library either as a dependency if you want to have specific version of the library or as a peer dependency if you want to version selection to be handled by the consumer of the library.

## In JS

Add `react-native-video` as a dependency or peer dependency.

```json title="package.json"
{
  "dependencies": {
    "react-native-video": "latest"
  }
  // OR
  "peerDependencies": {
    "react-native-video": "*"
  }
}
```

And then you can import it in your code.

```ts
import { VideoPlayer } from 'react-native-video';

const player = new VideoPlayer({ uri: 'https://www.example.com/video.mp4' });

player.play();
```

## In Native

### iOS
Add `ReactNativeVideo` as a dependency in your `*.podspec` file.

```ruby title="*.podspec"
Pod::Spec.new do |s|
  // ...

  s.dependency 'ReactNativeVideo'
end
```

### Android

Add `:react-native-video` and `:react-native-nitro-modules` as a dependency in your `build.gradle` file. Also you will need to add `androidx.media3` dependencies. to use player and source in your library.

```groovy title="build.gradle"
// ...

dependencies {
  // ...

  implementation project(':react-native-video')
  implementation project(':react-native-nitro-modules')

  implementation "androidx.media3:media3-common:1.4.1"
  implementation "androidx.media3:media3-exoplayer:1.4.1"
}
```

---

## Chapters

# Chapters

Navigate through video chapters with visual timeline markers.

## Overview

The Chapters component provides a rich chapter navigation experience with:
- Visual markers on the seek bar
- Chapter list panel
- Automatic chapter detection during playback
- Smooth seeking to chapter start points

```tsx

```

## Props

| Prop | Type | Default | Description |
|------|------|---------|-------------|
| `chapters` | `Chapter[]` | `[]` | Array of chapter data |
| `showOnSeekBar` | `boolean` | `true` | Show markers on seek bar |
| `markerColor` | `string` | `'#FFFFFF'` | Marker color on seek bar |
| `activeColor` | `string` | `'#FF5722'` | Active chapter highlight color |
| `style` | `ViewStyle` | - | Container style |
| `panelStyle` | `ViewStyle` | - | Chapter list panel style |
| `itemStyle` | `ViewStyle` | - | Individual chapter item style |
| `thumbnailStyle` | `ImageStyle` | - | Thumbnail image style |
| `titleStyle` | `TextStyle` | - | Chapter title text style |
| `timeStyle` | `TextStyle` | - | Chapter time text style |
| `onChapterChange` | `(chapter: Chapter) => void` | - | Callback when chapter changes |
| `onChapterSelect` | `(chapter: Chapter) => void` | - | Callback when user selects chapter |

## Chapter Type

```ts
interface Chapter {
  id: string;
  title: string;
  startTime: number;  // in seconds
  endTime?: number;   // in seconds (optional)
  thumbnail?: string; // URL or require() for local image
  description?: string;
}
```

## Basic Example

```tsx
import { VideoView, Controls, useVideoPlayer } from 'react-native-video';

const chapters = [
  { 
    id: '1', 
    title: 'Introduction', 
    startTime: 0,
    thumbnail: require('./thumbnails/intro.jpg')
  },
  { 
    id: '2', 
    title: 'Getting Started', 
    startTime: 45,
    thumbnail: require('./thumbnails/start.jpg')
  },
  { 
    id: '3', 
    title: 'Advanced Topics', 
    startTime: 180,
    thumbnail: require('./thumbnails/advanced.jpg')
  },
  { 
    id: '4', 
    title: 'Conclusion', 
    startTime: 320,
    thumbnail: require('./thumbnails/conclusion.jpg')
  },
];

function VideoWithChapters({ source }) {
  const player = useVideoPlayer(source);

  return (
    
      
        
        
        {/* Chapters with seek bar markers */}
   {
      console.log('Now playing:', chapter.title);
    }}
  />
        
        
        
      
    
  );
}
```

## Seek Bar Markers Only

If you only want chapter markers on the seek bar without a chapter list:

```tsx

```

## Custom Chapter List Panel

```tsx

```

## Dynamic Chapters from API

```tsx
function VideoWithDynamicChapters({ videoId }) {
  const [chapters, setChapters] = useState([]);
  const player = useVideoPlayer(source);

  useEffect(() => {
    async function loadChapters() {
      const response = await fetch(`/api/videos/${videoId}/chapters`);
      const data = await response.json();
      setChapters(data.chapters);
    }
    loadChapters();
  }, [videoId]);

  return (
    
      
        {chapters.length > 0 && (
          
        )}
        {/* ... other controls */}
      
    
  );
}
```

## Combining with Other Controls

```tsx

  {/* Top bar with chapter button */}
  
     {/* Just the toggle button */}
    
  

  

  {/* Bottom bar */}
  
    
    
      {/* Chapter markers rendered inside seek bar */}
      
    
  

  {/* Chapter panel (shown when button is pressed) */}
  

```

---

## Custom UI Controls

# Custom UI Controls

Build beautiful, fully customizable video player interfaces using our compound component API.

## Overview

React Native Video provides a powerful compound component pattern that lets you create custom video player UIs. Instead of being locked into a single design, you compose your interface from modular, pre-built components.

```tsx
import { VideoView, Controls } from 'react-native-video';

function MyPlayer() {
  const player = useVideoPlayer(source);

  return (
    
      
        
        
        
      
    
  );
}
```

## Compound API Philosophy

The compound component pattern gives you:

- **Full Control** - Position, style, and animate any control element
- **Flexibility** - Use only the components you need
- **Consistency** - Built-in state management and player synchronization
- **Customization** - Override styles or wrap components with your own logic

## Available Components

- Playback UI: [PlayPause, SeekBar, Duration, Fullscreen, Mute, Volume](./playback.md)
- Screen sharing: [AirPlay, Chromecast, native pickers](./screen-sharing.md)
- Subtitles: [Subtitle selector](./subtitles.md)
- Pro features: [Chapters](./chapters.md) · [ResolutionSelect](./resolution-select.md) · SeekBar preview thumbnails (in SeekBar props)
- SeekBar preview thumbnails *(Pro)* — see [Playback Controls](./playback.md#seekbar)

## Basic Example

```tsx
import { VideoView, Controls } from 'react-native-video';

function BasicPlayer({ source }) {
  const player = useVideoPlayer(source);

  return (
    
      
        {/* Top bar */}
        
          
          
        

        {/* Center play button */}
        
          
        

        {/* Bottom bar */}
        
          
          
          
        
      
    
  );
}
```

## Custom Styling

All control components accept standard React Native style props:

```tsx

```

## Building Custom Components

You can also build entirely custom controls using the player hooks:

```tsx
import { useVideoPlayer } from 'react-native-video';

function CustomPlayButton() {
  const player = useVideoPlayer();
  
  const handlePress = () => {
    if (player.isPlaying) {
      player.pause();
    } else {
      player.play();
    }
  };

  return (
    
      
    
  );
}
```

---

## Playback Controls

# Playback Controls

Core playback UI components built with the compound API.

## PlayPause
```tsx

```
| Prop | Type | Default | Description |
| --- | --- | --- | --- |
| `size` | `number` | `44` | Button size |
| `color` | `string` | `'#FFFFFF'` | Icon color |
| `playIcon` | `ReactNode` | - | Custom play icon |
| `pauseIcon` | `ReactNode` | - | Custom pause icon |
| `style` | `ViewStyle` | - | Container style |
| `iconStyle` | `ViewStyle` | - | Icon style |
| `onPress` | `() => void` | - | Extra callback |

---

## SeekBar
```tsx

```
| Prop | Type | Default | Description |
| --- | --- | --- | --- |
| `progressColor` | `string` | `'#FFFFFF'` | Played progress color |
| `bufferColor` | `string` | `rgba(255,255,255,0.5)` | Buffered progress color |
| `trackColor` | `string` | `rgba(255,255,255,0.3)` | Track background |
| `thumbColor` | `string` | `'#FFFFFF'` | Thumb color |
| `thumbSize` | `number` | `12` | Thumb size |
| `height` | `number` | `4` | Track height |
| `style` | `ViewStyle` | - | Container style |
| `trackStyle` | `ViewStyle` | - | Track style |
| `thumbStyle` | `ViewStyle` | - | Thumb style |
| `showBuffer` | `boolean` | `true` | Show buffer bar |
| `showPreviewThumbnails` | `boolean` | `false` | *(Pro)* Frame thumbnails on scrub |
| `onSeekStart` | `() => void` | - | Called on seek start |
| `onSeekEnd` | `(time: number) => void` | - | Called on seek end |

---

## Duration
```tsx

```
| Prop | Type | Default | Description |
| --- | --- | --- | --- |
| `format` | `'mm:ss' \| 'hh:mm:ss' \| 'auto'` | `'auto'` | Time format |
| `showRemaining` | `boolean` | `false` | Show remaining instead of current |
| `separator` | `string` | `' / '` | Separator between current/total |
| `textStyle` | `TextStyle` | - | Text style |
| `currentTimeStyle` | `TextStyle` | - | Current time text style |
| `durationStyle` | `TextStyle` | - | Duration text style |
| `style` | `ViewStyle` | - | Container style |

---

## Fullscreen
```tsx

```
| Prop | Type | Default | Description |
| --- | --- | --- | --- |
| `size` | `number` | `24` | Button size |
| `color` | `string` | `'#FFFFFF'` | Icon color |
| `enterIcon` | `ReactNode` | - | Custom enter icon |
| `exitIcon` | `ReactNode` | - | Custom exit icon |
| `style` | `ViewStyle` | - | Container style |
| `onEnter` | `() => void` | - | Callback on enter |
| `onExit` | `() => void` | - | Callback on exit |

---

## Mute
```tsx

```
| Prop | Type | Default | Description |
| --- | --- | --- | --- |
| `size` | `number` | `24` | Button size |
| `color` | `string` | `'#FFFFFF'` | Icon color |
| `mutedIcon` | `ReactNode` | - | Custom muted icon |
| `unmutedIcon` | `ReactNode` | - | Custom unmuted icon |
| `style` | `ViewStyle` | - | Container style |
| `onToggle` | `(muted: boolean) => void` | - | Callback on toggle |

---

## Volume
```tsx

```
| Prop | Type | Default | Description |
| --- | --- | --- | --- |
| `orientation` | `'horizontal' \| 'vertical'` | `'horizontal'` | Slider orientation |
| `showIcon` | `boolean` | `true` | Show volume icon |
| `trackColor` | `string` | `rgba(255,255,255,0.3)` | Track color |
| `fillColor` | `string` | `'#FFFFFF'` | Fill color |
| `thumbColor` | `string` | `'#FFFFFF'` | Thumb color |
| `iconColor` | `string` | `'#FFFFFF'` | Icon color |
| `size` | `number` | `100` | Slider length |
| `style` | `ViewStyle` | - | Container style |
| `onChange` | `(volume: number) => void` | - | Callback on change |

---

## Resolution Select

# Resolution Select

Quality and resolution picker for adaptive streaming (HLS/DASH).

## Overview

The ResolutionSelect component enables users to manually select video quality, overriding automatic bitrate adaptation. This is useful when:
- Users want consistent quality regardless of network conditions
- Saving data is a priority (select lower resolution)
- Maximum quality is desired on fast connections

```tsx

```

## Props

| Prop | Type | Default | Description |
|------|------|---------|-------------|
| `buttonSize` | `number` | `24` | Size of toggle button |
| `buttonColor` | `string` | `'#FFFFFF'` | Button icon color |
| `buttonIcon` | `ReactNode` | - | Custom button icon |
| `showBitrate` | `boolean` | `false` | Show bitrate alongside resolution |
| `showCurrentQuality` | `boolean` | `true` | Show current quality on button |
| `autoLabel` | `string` | `'Auto'` | Label for automatic quality |
| `style` | `ViewStyle` | - | Container style |
| `panelStyle` | `ViewStyle` | - | Selection panel style |
| `itemStyle` | `ViewStyle` | - | Individual item style |
| `itemTextStyle` | `TextStyle` | - | Item text style |
| `activeColor` | `string` | `'#007AFF'` | Active selection color |
| `onSelect` | `(resolution: Resolution \| 'auto') => void` | - | Callback on selection |
| `formatLabel` | `(resolution: Resolution) => string` | - | Custom label formatter |

## Resolution Type

```ts
interface Resolution {
  width: number;
  height: number;
  bitrate: number;
  label?: string;      // e.g., "1080p", "720p", "4K"
  frameRate?: number;  // e.g., 30, 60
  codec?: string;      // e.g., "h264", "hevc"
}
```

## Basic Example

```tsx
import { VideoView, Controls, useVideoPlayer } from 'react-native-video';

function VideoWithQualitySelector({ source }) {
  const player = useVideoPlayer(source);

  return (
    
      
        
          
          
        

        

        
          
          
        
      
    
  );
}
```

## Custom Styling

```tsx

```

## Custom Label Formatter

```tsx
 {
    const quality = resolution.height >= 2160 ? '4K' 
      : resolution.height >= 1080 ? 'Full HD'
      : resolution.height >= 720 ? 'HD'
      : 'SD';
    
    const bitrateMbps = (resolution.bitrate / 1000000).toFixed(1);
    
    return `${quality} (${resolution.height}p) - ${bitrateMbps} Mbps`;
  }}
/>
```

## Handling Selection

```tsx
function VideoWithQualityControl({ source }) {
  const player = useVideoPlayer(source);
  const [currentQuality, setCurrentQuality] = useState('auto');

  const handleQualitySelect = (resolution) => {
    if (resolution === 'auto') {
      setCurrentQuality('auto');
      // Enable automatic bitrate selection
      player.setAutomaticBitrateEnabled(true);
    } else {
      setCurrentQuality(`${resolution.height}p`);
      // Set specific bitrate
      player.setPreferredBitrate(resolution.bitrate);
    }
  };

  return (
    
      
        
        {/* ... other controls */}
      
    
  );
}
```

## Data Saver Mode

Implement a data saver that limits maximum quality:

```tsx
function DataSaverVideoPlayer({ source }) {
  const player = useVideoPlayer(source);
  const [dataSaverEnabled, setDataSaverEnabled] = useState(false);

  return (
    
      
        
          {/* Data saver toggle */}
           setDataSaverEnabled(!dataSaverEnabled)}
            style={styles.dataSaverButton}
          >
            
              {dataSaverEnabled ? '📉 Data Saver ON' : '📊 Data Saver OFF'}
            
          

           {
              if (dataSaverEnabled && resolution !== 'auto') {
                // Limit to 480p in data saver mode
                if (resolution.height > 480) {
                  Alert.alert(
                    'Data Saver Active',
                    'Maximum quality is limited to 480p while Data Saver is enabled.'
                  );
                  return;
                }
              }
              // Apply selection...
            }}
          />
        
        {/* ... other controls */}
      
    
  );
}
```

## Network-Aware Quality

```tsx
import NetInfo from '@react-native-community/netinfo';

function NetworkAwarePlayer({ source }) {
  const player = useVideoPlayer(source);
  const [networkType, setNetworkType] = useState('unknown');

  useEffect(() => {
    const unsubscribe = NetInfo.addEventListener(state => {
      setNetworkType(state.type);
      
      // Auto-adjust quality based on network
      if (state.type === 'cellular') {
        player.setMaxBitrate(2000000); // 2 Mbps on cellular
      } else if (state.type === 'wifi') {
        player.setMaxBitrate(null); // Unlimited on WiFi
      }
    });

    return () => unsubscribe();
  }, []);

  return (
    
      
        
        {/* ... */}
      
    
  );
}
```

## Available Resolutions

The available resolutions depend on the video source. For HLS/DASH streams, resolutions are automatically detected from the manifest. You can access them programmatically:

```tsx
function QualityInfo({ player }) {
  const [resolutions, setResolutions] = useState([]);

  useEffect(() => {
    const availableResolutions = player.getAvailableResolutions();
    setResolutions(availableResolutions);
    
    console.log('Available qualities:', availableResolutions);
    // Example output:
    // [
    //   { width: 1920, height: 1080, bitrate: 5000000, label: '1080p' },
    //   { width: 1280, height: 720, bitrate: 2500000, label: '720p' },
    //   { width: 854, height: 480, bitrate: 1000000, label: '480p' },
    //   { width: 640, height: 360, bitrate: 500000, label: '360p' },
    // ]
  }, [player]);

  return (
    
  );
}
```

---

## Screen Sharing (Casting)

# Screen Sharing (Casting)

AirPlay and Chromecast controls built with the compound API. These buttons open the native route picker so users can choose a device.

## AirPlay (iOS)
```tsx

```
| Prop | Type | Default | Description |
| --- | --- | --- | --- |
| `size` | `number` | `24` | Button size |
| `tintColor` | `string` | `'#FFFFFF'` | Icon color (inactive) |
| `activeTintColor` | `string` | `'#007AFF'` | Icon color (active) |
| `style` | `ViewStyle` | - | Container style |
| `prioritizesVideoDevices` | `boolean` | `true` | Prefer video-capable devices |

**Platform support**
| Platform | Supported |
| --- | --- |
| iOS | ✅ |
| Android | ❌ (use Chromecast) |

## Chromecast (Android)
```tsx

```
| Prop | Type | Default | Description |
| --- | --- | --- | --- |
| `size` | `number` | `24` | Button size |
| `tintColor` | `string` | `'#FFFFFF'` | Icon color |
| `style` | `ViewStyle` | - | Container style |

**Platform support**
| Platform | Supported |
| --- | --- |
| iOS | ❌ (use AirPlay) |
| Android | ✅ |

**Setup**
- Chromecast requires Android project setup. See the [Chromecast Setup Guide](../video-view/getting-started.md).

## Invoking native pickers
Both `Controls.AirPlay` and `Controls.Chromecast` render platform-native route pickers. Place the buttons wherever you need them; tapping opens the system device selector.

---

## Skip Intro & Binge Watching

# Skip Intro & Binge Watching

Netflix-style components for seamless viewing experiences.

:::tip Pro Feature - Coming Soon
Skip Intro and Binge Watching components are Pro features currently in development.
:::

## Overview

Enhance your streaming app with:

- **Skip Intro** - Let users skip opening credits
- **Skip Recap** - Skip "previously on..." segments
- **Skip Outro** - Skip end credits
- **Next Episode** - Auto-play countdown with preview
- **Binge Mode** - Continuous playback between episodes

## Skip Intro

### Basic Usage

```tsx
import { VideoView, SkipIntro } from 'react-native-video';

function Player({ source, introEnd }) {
  const player = useVideoPlayer(source);

  return (
    
      
      
      
    
  );
}
```

### With Time Range

Show button only during intro:

```tsx

```

### Customization

```tsx
}
  position="bottom-right" // 'bottom-right' | 'bottom-left' | 'top-right'
  animationType="slide"   // 'slide' | 'fade' | 'none'
/>
```

## Skip Recap

For "Previously on..." segments:

```tsx

```

## Skip Outro

For end credits:

```tsx
const duration = player.duration;

```

## Next Episode

### Basic Usage

```tsx
import { NextEpisode } from 'react-native-video';

function Player({ currentEpisode, nextEpisode }) {
  const player = useVideoPlayer(currentEpisode.source);

  const handlePlayNext = () => {
    // Navigate to next episode
    navigation.replace('Player', { episode: nextEpisode });
  };

  return (
    
      
      
      
    
  );
}
```

### With Preview

```tsx

```

### Customization

```tsx
 console.log('User cancelled')}
  nextTitle="Next Episode"
  
  // Styling
  style={styles.container}
  countdownStyle={styles.countdown}
  titleStyle={styles.title}
  buttonStyle={styles.button}
  
  // Labels
  playNextLabel="Play Next Episode"
  cancelLabel="Cancel"
  countdownFormat={(seconds) => `Starting in ${seconds}...`}
/>
```

## Binge Mode

Automatic continuous playback:

```tsx
import { useBingeMode } from 'react-native-video';

function SeriesPlayer({ episodes, startIndex }) {
  const [currentIndex, setCurrentIndex] = useState(startIndex);
  
  const binge = useBingeMode({
    episodes: episodes.map(ep => ep.source),
    currentIndex,
    onEpisodeChange: setCurrentIndex,
    countdownDuration: 5,
    autoPlay: true,
  });

  return (
    
      
      
      {/* Auto-shows next episode UI */}
      
      
      {/* Episode info */}
      {episodes[currentIndex].title}
    
  );
}
```

### Binge Mode Options

```ts
interface BingeModeConfig {
  episodes: string[];           // Array of source URIs
  currentIndex: number;
  onEpisodeChange: (index: number) => void;
  countdownDuration?: number;   // Seconds before auto-play (default: 10)
  autoPlay?: boolean;           // Auto-play next (default: true)
  skipCredits?: boolean;        // Auto-skip outros (default: false)
  skipIntros?: boolean;         // Auto-skip intros (default: false)
  introMarkers?: number[];      // Intro end times per episode
  outroMarkers?: number[];      // Outro start times per episode
}
```

## Markers from API

Load skip markers from your backend:

```tsx
function Player({ videoId }) {
  const [markers, setMarkers] = useState(null);

  useEffect(() => {
    fetch(`/api/videos/${videoId}/markers`)
      .then(res => res.json())
      .then(setMarkers);
  }, [videoId]);

  const player = useVideoPlayer(source);

  if (!markers) return ;

  return (
    
      
      
      {markers.intro && (
        
      )}
      
      {markers.recap && (
        
      )}
      
      {markers.outro && (
        
      )}
    
  );
}
```

### Markers API Response

```ts
interface VideoMarkers {
  intro?: { start: number; end: number };
  recap?: { start: number; end: number };
  outro?: { start: number; end: number };
}
```

## Complete Example

```tsx
import React, { useState, useEffect } from 'react';
import { View, Text, Image } from 'react-native';
import { 
  useVideoPlayer, 
  VideoView, 
  SkipIntro, 
  NextEpisode 
} from 'react-native-video';

function StreamingPlayer({ series, episodeIndex }) {
  const episode = series.episodes[episodeIndex];
  const nextEpisode = series.episodes[episodeIndex + 1];

  const player = useVideoPlayer(episode.source, (_player) => {
    _player.play();
  });

  const handlePlayNext = () => {
    navigation.replace('Player', {
      series,
      episodeIndex: episodeIndex + 1,
    });
  };

  return (
    
      

      {/* Skip intro button */}
      {episode.introEnd && (
        
      )}

      {/* Next episode countdown */}
      {nextEpisode && (
        
      )}

      {/* Episode info */}
      
        {episode.title}
        
          S{episode.season}E{episode.number}
        
      
    
  );
}
```

## Platform Support

| Feature | iOS | Android |
|---------|-----|---------|
| Skip Intro | ✅ | ✅ |
| Skip Recap | ✅ | ✅ |
| Skip Outro | ✅ | ✅ |
| Next Episode | ✅ | ✅ |
| Binge Mode | ✅ | ✅ |
| Animations | ✅ | ✅ |

## See Also

- [Playback Controls](./playback.md) - Basic UI components
- [Chapters](./chapters.md) - Video chapters *(Pro)*
- [Events](../players/events/useEvent.md) - Event handling

---

## Subtitles

# Subtitles

Custom subtitle/caption selector with styling support.

```tsx

```

## Props
| Prop | Type | Default | Description |
| --- | --- | --- | --- |
| `buttonSize` | `number` | `24` | Size of toggle button |
| `buttonColor` | `string` | `'#FFFFFF'` | Button icon color |
| `activeColor` | `string` | `'#007AFF'` | Active track indicator color |
| `style` | `ViewStyle` | - | Container style |
| `panelStyle` | `ViewStyle` | - | Selection panel style |
| `itemStyle` | `ViewStyle` | - | Individual item style |
| `itemTextStyle` | `TextStyle` | - | Item text style |
| `showOffOption` | `boolean` | `true` | Show "Off" option |
| `offLabel` | `string` | `'Off'` | Label for off option |
| `onSelect` | `(track: TextTrack \| null) => void` | - | Callback when track selected |

## Example
```tsx

```

---

## Fullscreen

# Fullscreen

Control fullscreen mode programmatically and respond to fullscreen state changes.

## Methods

Access these methods via a ref to `VideoView`:

```tsx
const videoRef = useRef(null);

```

### enterFullscreen()

```ts
enterFullscreen(): void;
```

Enter fullscreen mode.

```tsx
videoRef.current?.enterFullscreen();
```

### exitFullscreen()

```ts
exitFullscreen(): void;
```

Exit fullscreen mode.

```tsx
videoRef.current?.exitFullscreen();
```

## Events

### onFullscreenChange

```ts
onFullscreenChange?: (isFullscreen: boolean) => void;
```

Called when the fullscreen state changes.

```tsx
 {
    console.log('Fullscreen:', isFullscreen);
  }}
/>
```

### willEnterFullscreen

```ts
willEnterFullscreen?: () => void;
```

Called immediately before entering fullscreen mode.

```tsx
 {
    // Hide other UI elements
  }}
/>
```

### willExitFullscreen

```ts
willExitFullscreen?: () => void;
```

Called immediately before exiting fullscreen mode.

```tsx
 {
    // Prepare to show other UI elements
  }}
/>
```

## Complete Example

```tsx
import React, { useRef, useState } from 'react';
import { View, Button } from 'react-native';
import { useVideoPlayer, VideoView, VideoViewRef } from 'react-native-video';

function FullscreenPlayer({ source }) {
  const videoRef = useRef(null);
  const [isFullscreen, setIsFullscreen] = useState(false);

  const player = useVideoPlayer(source, (_player) => {
    _player.play();
  });

  const toggleFullscreen = () => {
    if (isFullscreen) {
      videoRef.current?.exitFullscreen();
    } else {
      videoRef.current?.enterFullscreen();
    }
  };

  return (
    
       console.log('Entering fullscreen...')}
        willExitFullscreen={() => console.log('Exiting fullscreen...')}
      />
      
      
    
  );
}
```

## Platform Behavior

| Platform | Behavior |
|----------|----------|
| iOS | Presents native fullscreen player |
| Android | Expands video to fill screen, hides status bar |

## See Also

- [Props](./props.md) - All VideoView props
- [Picture in Picture](./picture-in-picture.md) - PiP mode

---

## Getting Started

# Getting Started

The `VideoView` component is responsible for rendering the video content managed by a `VideoPlayer` instance onto the screen. It also provides UI functionalities like native controls, fullscreen, and picture-in-picture mode.

## Basic Usage

To use `VideoView`, you need to pass a `VideoPlayer` instance to its `player` prop.

```tsx
import React from 'react';
import { VideoPlayer, VideoView } from 'react-native-video';
import { StyleSheet } from 'react-native';

const App = () => {
  const player = useVideoPlayer('https://example.com/video.mp4', (_player) => {
    // This is optional setup function that will be called when the player is created.
    _player.play();
  });

  return (
    
  );
};

const styles = StyleSheet.create({
  video: {
    width: '100%',
    height: 200,
  },
});

export default App;
```

## Props

| Prop | Type | Required | Default | Description |
|------|------|----------|---------|-------------|
| `player` | `VideoPlayer` | Yes | - | The `VideoPlayer` instance that manages the video to be displayed. |
| `style` | `ViewStyle` | No | - | Standard React Native styles to control the layout and appearance of the `VideoView`. |
| `controls` | `boolean` | No | `false` | Whether to show the native video playback controls (play/pause, seek bar, volume, etc.). |
| `pictureInPicture` | `boolean` | No | `false` | Whether to enable and show the picture-in-picture (PiP) button in the native controls (if supported by the platform and controls are visible). |
| `autoEnterPictureInPicture` | `boolean` | No | `false` | Whether the video should automatically enter PiP mode when it starts playing and the app is backgrounded (behavior might vary by platform). |
| `resizeMode` | `'contain' \| 'cover' \| 'stretch' \| 'none'` | No | `'none'` | How the video should be resized to fit the view. |
| `keepScreenAwake` | `boolean` | No | `true` | Whether to keep the device screen awake while the video view is mounted. |
| `surfaceType` | `'surface' \| 'texture'` | No (Android only) | `'surface'` | (Android) Underlying native view type. `'surface'` uses a SurfaceView (better performance, no transforms/overlap), `'texture'` uses a TextureView (supports animations, transforms, overlapping UI) at a small performance cost. Ignored on iOS. |

## Events

`VideoView` also accepts several event callback props related to UI state changes:

| Event | Type | Description |
|-------|------|-------------|
| `onPictureInPictureChange?` | `(event: { isActive: boolean }) => void` | Fired when the picture-in-picture mode starts or stops. |
| `onFullscreenChange?` | `(event: { isFullscreen: boolean }) => void` | Fired when the fullscreen mode starts or stops. |
| `willEnterFullscreen?` | `() => void` | Fired just before the view enters fullscreen mode. |
| `willExitFullscreen?` | `() => void` | Fired just before the view exits fullscreen mode. |
| `willEnterPictureInPicture?` | `() => void` | Fired just before the view enters picture-in-picture mode. |
| `willExitPictureInPicture?` | `() => void` | Fired just before the view exits picture-in-picture mode. |

These can be used to update your component's state or UI in response to these changes.

```tsx
 {
    console.log(isFullscreen ? 'Entered fullscreen' : 'Exited fullscreen');
  }}
  onPictureInPictureChange={({ isActive }) => {
    console.log(isActive ? 'PiP active' : 'PiP inactive');
  }}
/>
```

## Refs and Imperative Methods

You can obtain a ref to the `VideoView` component to call imperative methods:

```tsx
const videoViewRef = React.useRef(null);

// ...

// Later, you can call methods like:
videoViewRef.current?.enterFullscreen();
```

Available methods on the `VideoViewRef`:

| Method | Type | Description |
|--------|------|-------------|
| `enterFullscreen()` | `() => void` | Programmatically requests the video view to enter fullscreen mode. |
| `exitFullscreen()` | `() => void` | Programmatically requests the video view to exit fullscreen mode. |
| `enterPictureInPicture()` | `() => void` | Programmatically requests the video view to enter picture-in-picture mode. |
| `exitPictureInPicture()` | `() => void` | Programmatically requests the video view to exit picture-in-picture mode. |
| `canEnterPictureInPicture()` | `() => boolean` | Checks if picture-in-picture mode is currently available and supported. Returns `true` if PiP can be entered, `false` otherwise. |

## Android: Choosing a surface type

On Android the default rendering path uses a `SurfaceView` (set via `surfaceType="surface"`) for optimal decoding performance and lower latency. However `SurfaceView` lives in a separate window and can't be:

- Animated with transforms (scale, rotate, opacity fade)
- Clipped by parent views (rounded corners, masks)
- Overlapped reliably with sibling views (z-order issues)

If you need those UI effects, switch to `TextureView`:

```tsx

```

Use `TextureView` only when required, as it can be slightly less performant and may increase power consumption on some devices.

---

## Picture in Picture

# Picture in Picture

Enable Picture-in-Picture (PiP) mode to let users watch video in a floating window while using other apps.

## Props

### pictureInPicture

```ts
optional pictureInPicture: boolean;
```

Enable PiP and show the PiP button in native controls. Defaults to `false`.

```tsx

```

### autoEnterPictureInPicture

```ts
optional autoEnterPictureInPicture: boolean;
```

Automatically enter PiP when the app goes to background. Defaults to `false`.

```tsx

```

## Methods

Access these methods via a ref to `VideoView`:

```tsx
const videoRef = useRef(null);

```

### enterPictureInPicture()

```ts
enterPictureInPicture(): void;
```

Enter PiP mode programmatically.

```tsx
videoRef.current?.enterPictureInPicture();
```

### exitPictureInPicture()

```ts
exitPictureInPicture(): void;
```

Exit PiP mode programmatically.

```tsx
videoRef.current?.exitPictureInPicture();
```

### canEnterPictureInPicture()

```ts
canEnterPictureInPicture(): boolean;
```

Check if PiP is supported on the current device.

```tsx
const canPiP = videoRef.current?.canEnterPictureInPicture();

if (canPiP) {
  videoRef.current?.enterPictureInPicture();
}
```

## Events

### onPictureInPictureChange

```ts
onPictureInPictureChange?: (isInPiP: boolean) => void;
```

Called when PiP state changes.

```tsx
 {
    console.log('PiP:', isInPiP);
  }}
/>
```

### willEnterPictureInPicture

```ts
willEnterPictureInPicture?: () => void;
```

Called immediately before entering PiP mode.

```tsx
 {
    // Prepare for PiP
  }}
/>
```

### willExitPictureInPicture

```ts
willExitPictureInPicture?: () => void;
```

Called immediately before exiting PiP mode.

```tsx
 {
    // Prepare to return to full view
  }}
/>
```

## Complete Example

```tsx
import React, { useRef, useState } from 'react';
import { View, Button, Text } from 'react-native';
import { useVideoPlayer, VideoView, VideoViewRef } from 'react-native-video';

function PiPPlayer({ source }) {
  const videoRef = useRef(null);
  const [isInPiP, setIsInPiP] = useState(false);
  const [canPiP, setCanPiP] = useState(false);

  const player = useVideoPlayer(source, (_player) => {
    _player.play();
  });

  const handleLayout = () => {
    setCanPiP(videoRef.current?.canEnterPictureInPicture() ?? false);
  };

  const togglePiP = () => {
    if (isInPiP) {
      videoRef.current?.exitPictureInPicture();
    } else {
      videoRef.current?.enterPictureInPicture();
    }
  };

  return (
    
      
      
      {canPiP ? (
        
      ) : (
        PiP not supported on this device
      )}
    
  );
}
```

## Platform Configuration

### iOS

Add to your `Info.plist`:

```xml
UIBackgroundModes

  audio

```

### Android

PiP requires Android 8.0 (API 26) or higher. Add to your `AndroidManifest.xml`:

```xml

```

## Platform Support

| Feature | iOS | Android |
|---------|-----|---------|
| PiP | ✅ iOS 14+ | ✅ API 26+ |
| Auto-enter | ✅ | ✅ |
| Custom controls in PiP | ✅ | ❌ |

## See Also

- [Props](./props.md) - All VideoView props
- [Fullscreen](./fullscreen.md) - Fullscreen mode
- [Background](../players/usage/background.md) - Background playback

---

## Props

# Props

All available props for the `VideoView` component.

## player

```ts
player: VideoPlayer;
```

The player instance that controls video playback. Create it using `useVideoPlayer`.

```tsx
const player = useVideoPlayer(source);

return ;
```

## style

```ts
optional style: ViewStyle;
```

Standard React Native view style. Use it to set dimensions, positioning, and other layout properties.

```tsx

```

## controls

```ts
optional controls: boolean;
```

Whether to show native video controls. Defaults to `false`.

```tsx

```

:::tip
For custom controls, use the [UI components](../ui/getting-started.md) instead.
:::

## resizeMode

```ts
optional resizeMode: ResizeMode;
```

How the video should be resized to fit the view. Defaults to `'none'`.

```tsx

```

### ResizeMode

```ts
type ResizeMode = 'contain' | 'cover' | 'stretch' | 'none';
```

| Value | Description |
|-------|-------------|
| `'contain'` | Scale uniformly to fit entirely within the view (letterboxing) |
| `'cover'` | Scale uniformly to fill the view (may crop) |
| `'stretch'` | Stretch to fill the view (may distort) |
| `'none'` | No resizing, uses default behavior (contain) |

## keepScreenAwake

```ts
optional keepScreenAwake: boolean;
```

Whether to keep the screen awake while the video view is mounted. Defaults to `true`.

```tsx

```

## surfaceType

```ts
optional surfaceType: SurfaceType;
```

The type of underlying native view. **Android only.** Defaults to `'surface'`.

```tsx

```

### SurfaceType

```ts
type SurfaceType = 'surface' | 'texture';
```

| Value | Description |
|-------|-------------|
| `'surface'` | Uses SurfaceView. More performant, but cannot be animated or transformed |
| `'texture'` | Uses TextureView. Less performant, but can be animated and transformed |

:::note
Use `'texture'` when you need to apply animations or transforms to the video view (e.g., rotation, scale).
:::

## Complete Example

```tsx
import { useVideoPlayer, VideoView } from 'react-native-video';

function VideoPlayer({ source }) {
  const player = useVideoPlayer(source, (_player) => {
    _player.play();
  });

  return (
    
  );
}
```

## See Also

- [Getting Started](./getting-started.md) - VideoView basics
- [Fullscreen](./fullscreen.md) - Fullscreen mode
- [Picture in Picture](./picture-in-picture.md) - PiP mode
