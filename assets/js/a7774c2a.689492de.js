"use strict";(self.webpackChunk_react_native_video_docs=self.webpackChunk_react_native_video_docs||[]).push([["8950"],{463:function(e,n,o){o.r(n),o.d(n,{frontMatter:()=>a,toc:()=>i,default:()=>h,metadata:()=>r,assets:()=>t,contentTitle:()=>l});var r=JSON.parse('{"id":"player/downloading/events","title":"Events","description":"Event system for tracking download progress and status","source":"@site/docs/player/downloading/events.md","sourceDirName":"player/downloading","slug":"/player/downloading/events","permalink":"/react-native-video/docs/v7/player/downloading/events","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"sidebar_label":"events","description":"Event system for tracking download progress and status"},"sidebar":"docsSidebar","previous":{"title":"downloading","permalink":"/react-native-video/docs/v7/player/downloading/"},"next":{"title":"track selection","permalink":"/react-native-video/docs/v7/player/downloading/track-selection"}}'),s=o(4848),d=o(6151);let a={sidebar_position:3,sidebar_label:"events",description:"Event system for tracking download progress and status"},l="Events",t={},i=[{value:"Available Events",id:"available-events",level:2},{value:"<code>onError</code>",id:"onerror",level:3},{value:"<code>onDownloadProgress</code>",id:"ondownloadprogress",level:3},{value:"<code>onDownloadEnd</code>",id:"ondownloadend",level:3},{value:"Using Events",id:"using-events",level:2}];function c(e){let n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,d.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"events",children:"Events"})}),"\n",(0,s.jsxs)(n.p,{children:["The Offline Video SDK emits events that allow you to monitor and react to changes in download status and progress. You can subscribe to these events using the ",(0,s.jsx)(n.code,{children:"useEvent"})," hook from ",(0,s.jsx)(n.code,{children:"react-native-video"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"available-events",children:"Available Events"}),"\n",(0,s.jsx)(n.h3,{id:"onerror",children:(0,s.jsx)(n.code,{children:"onError"})}),"\n",(0,s.jsx)(n.p,{children:"Fired when an error occurs during download."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Callback signature:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"(error: string) => void\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"error"}),": Error message describing what went wrong"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'import { useEvent } from "react-native-video";\n\nuseEvent("onError", (error: string) => {\n  console.error("Download error:", error);\n});\n'})}),"\n",(0,s.jsx)(n.h3,{id:"ondownloadprogress",children:(0,s.jsx)(n.code,{children:"onDownloadProgress"})}),"\n",(0,s.jsx)(n.p,{children:"Fired periodically during downloads with current progress information."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Callback signature:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"(downloads: DownloadStatus[]) => void\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"downloads"}),": Array of ",(0,s.jsx)(n.code,{children:"DownloadStatus"})," - See ",(0,s.jsx)(n.a,{href:"/react-native-video/docs/v7/player/downloading/#downloadstatus",children:"DownloadStatus structure"})," in API Reference for complete properties"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'import { useEvent } from "react-native-video";\n\nuseEvent("onDownloadProgress", (downloads: DownloadStatus[]) => {\n  downloads.forEach((download) => {\n    console.log(`Download ${download.id}: ${(download.progress * 100).toFixed(1)}%`);\n  });\n});\n'})}),"\n",(0,s.jsx)(n.h3,{id:"ondownloadend",children:(0,s.jsx)(n.code,{children:"onDownloadEnd"})}),"\n",(0,s.jsx)(n.p,{children:"Fired when a download completes (successfully or with failure)."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Callback signature:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"(download: DownloadStatus) => void\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"download"}),": Final ",(0,s.jsx)(n.code,{children:"DownloadStatus"})," - See ",(0,s.jsx)(n.a,{href:"/react-native-video/docs/v7/player/downloading/#downloadstatus",children:"DownloadStatus structure"})," in API Reference for complete properties. When this event fires, ",(0,s.jsx)(n.code,{children:"status"})," will be either ",(0,s.jsx)(n.code,{children:"'completed'"})," or ",(0,s.jsx)(n.code,{children:"'failed'"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'import { useEvent } from "react-native-video";\n\nuseEvent("onDownloadEnd", (download: DownloadStatus) => {\n  if (download.status === "completed") {\n    console.log(`Download ${download.id} completed successfully`);\n  } else {\n    console.log(`Download ${download.id} failed`);\n  }\n});\n'})}),"\n",(0,s.jsx)(n.h2,{id:"using-events",children:"Using Events"}),"\n",(0,s.jsxs)(n.p,{children:["Events are automatically typed and can be used with the ",(0,s.jsx)(n.code,{children:"useEvent"})," hook from ",(0,s.jsx)(n.code,{children:"react-native-video"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'import { useEvent } from "react-native-video";\n\nfunction DownloadManager() {\n  useEvent("onDownloadProgress", (downloads) => {\n    // Update UI with progress\n  });\n\n  useEvent("onDownloadEnd", (download) => {\n    // Handle completion\n  });\n\n  useEvent("onError", (error) => {\n    // Handle errors\n  });\n\n  // ... rest of component\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"useEvent"})," hook automatically manages cleanup when the component unmounts, preventing memory leaks."]})]})}function h(e={}){let{wrapper:n}={...(0,d.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},6151:function(e,n,o){o.d(n,{R:()=>a,x:()=>l});var r=o(6540);let s={},d=r.createContext(s);function a(e){let n=r.useContext(d);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(d.Provider,{value:n},e.children)}}}]);