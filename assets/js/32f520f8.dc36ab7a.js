"use strict";(self.webpackChunk_react_native_video_docs=self.webpackChunk_react_native_video_docs||[]).push([["3768"],{85603:function(e,n,a){a.r(n),a.d(n,{frontMatter:()=>i,toc:()=>d,default:()=>p,metadata:()=>t,assets:()=>r,contentTitle:()=>o});var t=JSON.parse('{"id":"extensions/uploading/queue-management","title":"Queue Management","description":"Manage multiple uploads efficiently with queue system and prioritization.","source":"@site/docs/extensions/uploading/queue-management.md","sourceDirName":"extensions/uploading","slug":"/extensions/uploading/queue-management","permalink":"/react-native-video/docs/v7/extensions/uploading/queue-management","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Multi-Part Upload","permalink":"/react-native-video/docs/v7/extensions/uploading/multi-part-upload"},"next":{"title":"Network Tracking","permalink":"/react-native-video/docs/v7/extensions/uploading/network-tracking"}}'),l=a(74848),s=a(56151);let i={},o="Queue Management",r={},d=[{value:"Overview",id:"overview",level:2},{value:"Basic Queue",id:"basic-queue",level:2},{value:"Queue Configuration",id:"queue-configuration",level:2},{value:"Priority-Based Queue",id:"priority-based-queue",level:2},{value:"Queue Operations",id:"queue-operations",level:2},{value:"Get All Uploads",id:"get-all-uploads",level:3},{value:"Get Queue Status",id:"get-queue-status",level:3},{value:"Pause All",id:"pause-all",level:3},{value:"Resume All",id:"resume-all",level:3},{value:"Cancel All",id:"cancel-all",level:3},{value:"Filter Uploads",id:"filter-uploads",level:2},{value:"By State",id:"by-state",level:3},{value:"By Priority",id:"by-priority",level:3},{value:"By Metadata",id:"by-metadata",level:3},{value:"Queue Events",id:"queue-events",level:2},{value:"Batch Upload",id:"batch-upload",level:2},{value:"Queue Persistence",id:"queue-persistence",level:2},{value:"Queue Strategies",id:"queue-strategies",level:2},{value:"FIFO (First In, First Out)",id:"fifo-first-in-first-out",level:3},{value:"Priority-Based",id:"priority-based",level:3},{value:"Custom Strategy",id:"custom-strategy",level:3},{value:"Complete Example",id:"complete-example",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"See Also",id:"see-also",level:2}];function u(e){let n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"queue-management",children:"Queue Management"})}),"\n",(0,l.jsx)(n.p,{children:"Manage multiple uploads efficiently with queue system and prioritization."}),"\n",(0,l.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,l.jsx)(n.p,{children:"Queue management provides:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Automatic Queuing"})," - Queue uploads when limit is reached"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Priority Support"})," - Prioritize important uploads"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Concurrent Limit"})," - Control simultaneous uploads"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Queue Persistence"})," - Survive app restarts"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Batch Operations"})," - Pause/resume/cancel multiple uploads"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"basic-queue",children:"Basic Queue"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-tsx",children:"import { VideoUploader } from 'react-native-video';\n\n// Uploads are automatically queued\nconst upload1 = await VideoUploader.upload({\n  file: '/path/to/video1.mp4',\n  url: 'https://api.example.com/upload',\n});\n\nconst upload2 = await VideoUploader.upload({\n  file: '/path/to/video2.mp4',\n  url: 'https://api.example.com/upload',\n});\n\nconst upload3 = await VideoUploader.upload({\n  file: '/path/to/video3.mp4',\n  url: 'https://api.example.com/upload',\n});\n\n// All start automatically based on queue configuration\n"})}),"\n",(0,l.jsx)(n.h2,{id:"queue-configuration",children:"Queue Configuration"}),"\n",(0,l.jsx)(n.p,{children:"Configure queue behavior globally:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-tsx",children:"import { VideoUploadManager } from 'react-native-video';\n\nVideoUploadManager.configure({\n  maxConcurrentUploads: 2, // Upload 2 files at once\n  queueMode: 'fifo', // 'fifo' or 'priority'\n  autoStart: true, // Auto-start queued uploads\n});\n"})}),"\n",(0,l.jsx)(n.h2,{id:"priority-based-queue",children:"Priority-Based Queue"}),"\n",(0,l.jsx)(n.p,{children:"Assign priorities to uploads:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-tsx",children:"// High priority upload (starts first)\nconst urgentUpload = await VideoUploader.upload({\n  file: '/path/to/urgent.mp4',\n  url: 'https://api.example.com/upload',\n  priority: 'high', // 'high', 'medium', 'low'\n});\n\n// Medium priority\nconst normalUpload = await VideoUploader.upload({\n  file: '/path/to/normal.mp4',\n  url: 'https://api.example.com/upload',\n  priority: 'medium',\n});\n\n// Low priority (starts last)\nconst backgroundUpload = await VideoUploader.upload({\n  file: '/path/to/background.mp4',\n  url: 'https://api.example.com/upload',\n  priority: 'low',\n});\n"})}),"\n",(0,l.jsx)(n.h2,{id:"queue-operations",children:"Queue Operations"}),"\n",(0,l.jsx)(n.h3,{id:"get-all-uploads",children:"Get All Uploads"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-tsx",children:"const uploads = await VideoUploadManager.getAll();\n\nuploads.forEach(upload => {\n  console.log(upload.id, upload.state, upload.progress);\n});\n"})}),"\n",(0,l.jsx)(n.h3,{id:"get-queue-status",children:"Get Queue Status"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-tsx",children:"const status = await VideoUploadManager.getQueueStatus();\n\nconsole.log(status);\n// {\n//   total: 10,\n//   uploading: 2,\n//   queued: 5,\n//   paused: 2,\n//   completed: 1,\n//   failed: 0\n// }\n"})}),"\n",(0,l.jsx)(n.h3,{id:"pause-all",children:"Pause All"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-tsx",children:"await VideoUploadManager.pauseAll();\n"})}),"\n",(0,l.jsx)(n.h3,{id:"resume-all",children:"Resume All"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-tsx",children:"await VideoUploadManager.resumeAll();\n"})}),"\n",(0,l.jsx)(n.h3,{id:"cancel-all",children:"Cancel All"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-tsx",children:"await VideoUploadManager.cancelAll();\n"})}),"\n",(0,l.jsx)(n.h2,{id:"filter-uploads",children:"Filter Uploads"}),"\n",(0,l.jsx)(n.h3,{id:"by-state",children:"By State"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-tsx",children:"const uploads = await VideoUploadManager.getAll();\n\n// Only uploading\nconst uploading = uploads.filter(u => u.state === 'uploading');\n\n// Only queued\nconst queued = uploads.filter(u => u.state === 'queued');\n\n// Failed uploads\nconst failed = uploads.filter(u => u.state === 'failed');\n"})}),"\n",(0,l.jsx)(n.h3,{id:"by-priority",children:"By Priority"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-tsx",children:"const highPriority = uploads.filter(u => u.priority === 'high');\n"})}),"\n",(0,l.jsx)(n.h3,{id:"by-metadata",children:"By Metadata"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-tsx",children:"const userUploads = uploads.filter(\n  u => u.metadata?.userId === 'user123'\n);\n"})}),"\n",(0,l.jsx)(n.h2,{id:"queue-events",children:"Queue Events"}),"\n",(0,l.jsx)(n.p,{children:"Listen to queue-level events:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-tsx",children:"VideoUploadManager.onQueueChange((status) => {\n  console.log('Queue status:', status);\n  // {\n  //   total: 10,\n  //   uploading: 2,\n  //   queued: 5,\n  //   ...\n  // }\n});\n\nVideoUploadManager.onUploadStart((upload) => {\n  console.log('Upload started:', upload.id);\n});\n\nVideoUploadManager.onUploadComplete((upload) => {\n  console.log('Upload completed:', upload.id);\n});\n\nVideoUploadManager.onUploadFailed((upload, error) => {\n  console.error('Upload failed:', upload.id, error);\n});\n"})}),"\n",(0,l.jsx)(n.h2,{id:"batch-upload",children:"Batch Upload"}),"\n",(0,l.jsx)(n.p,{children:"Upload multiple files at once:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-tsx",children:"const files = [\n  '/path/to/video1.mp4',\n  '/path/to/video2.mp4',\n  '/path/to/video3.mp4',\n];\n\nconst uploads = await VideoUploadManager.batchUpload({\n  files,\n  url: 'https://api.example.com/upload',\n  headers: {\n    'Authorization': 'Bearer token',\n  },\n});\n\n// Track batch progress\nVideoUploadManager.onBatchProgress((progress) => {\n  console.log(`Batch: ${progress.completed} / ${progress.total}`);\n});\n"})}),"\n",(0,l.jsx)(n.h2,{id:"queue-persistence",children:"Queue Persistence"}),"\n",(0,l.jsx)(n.p,{children:"Queue persists across app restarts:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-tsx",children:"// On app start, resume pending uploads\nuseEffect(() => {\n  const resumePendingUploads = async () => {\n    const uploads = await VideoUploadManager.getAll();\n    const pending = uploads.filter(\n      u => ['uploading', 'paused', 'queued'].includes(u.state)\n    );\n    \n    for (const upload of pending) {\n      await upload.resume();\n    }\n  };\n  \n  resumePendingUploads();\n}, []);\n"})}),"\n",(0,l.jsx)(n.h2,{id:"queue-strategies",children:"Queue Strategies"}),"\n",(0,l.jsx)(n.h3,{id:"fifo-first-in-first-out",children:"FIFO (First In, First Out)"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-tsx",children:"VideoUploadManager.configure({\n  queueMode: 'fifo',\n});\n\n// Uploads process in order added\n"})}),"\n",(0,l.jsx)(n.h3,{id:"priority-based",children:"Priority-Based"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-tsx",children:"VideoUploadManager.configure({\n  queueMode: 'priority',\n});\n\n// Uploads process by priority: high \u2192 medium \u2192 low\n"})}),"\n",(0,l.jsx)(n.h3,{id:"custom-strategy",children:"Custom Strategy"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-tsx",children:"VideoUploadManager.configure({\n  queueMode: 'custom',\n  queueComparator: (a, b) => {\n    // Custom sorting logic\n    // Sort by file size (smallest first)\n    return a.fileSize - b.fileSize;\n  },\n});\n"})}),"\n",(0,l.jsx)(n.h2,{id:"complete-example",children:"Complete Example"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-tsx",children:"import React, { useState, useEffect } from 'react';\nimport { View, Text, FlatList, Button } from 'react-native';\nimport { VideoUploadManager } from 'react-native-video';\n\nfunction UploadQueueScreen() {\n  const [uploads, setUploads] = useState([]);\n  const [queueStatus, setQueueStatus] = useState(null);\n\n  useEffect(() => {\n    loadUploads();\n    \n    const unsubscribe = VideoUploadManager.onQueueChange((status) => {\n      setQueueStatus(status);\n      loadUploads();\n    });\n    \n    return () => unsubscribe();\n  }, []);\n\n  const loadUploads = async () => {\n    const all = await VideoUploadManager.getAll();\n    setUploads(all);\n  };\n\n  const addUpload = async (filePath, priority = 'medium') => {\n    await VideoUploader.upload({\n      file: filePath,\n      url: 'https://api.example.com/upload',\n      priority,\n    });\n  };\n\n  const pauseAll = async () => {\n    await VideoUploadManager.pauseAll();\n  };\n\n  const resumeAll = async () => {\n    await VideoUploadManager.resumeAll();\n  };\n\n  const clearCompleted = async () => {\n    const completed = uploads.filter(u => u.state === 'completed');\n    for (const upload of completed) {\n      await VideoUploadManager.remove(upload.id);\n    }\n    loadUploads();\n  };\n\n  return (\n    <View>\n      {queueStatus && (\n        <View style={styles.queueStatus}>\n          <Text>Total: {queueStatus.total}</Text>\n          <Text>Uploading: {queueStatus.uploading}</Text>\n          <Text>Queued: {queueStatus.queued}</Text>\n          <Text>Completed: {queueStatus.completed}</Text>\n        </View>\n      )}\n\n      <View style={styles.actions}>\n        <Button title=\"Pause All\" onPress={pauseAll} />\n        <Button title=\"Resume All\" onPress={resumeAll} />\n        <Button title=\"Clear Completed\" onPress={clearCompleted} />\n      </View>\n\n      <FlatList\n        data={uploads}\n        renderItem={({ item }) => (\n          <View style={styles.uploadItem}>\n            <Text>{item.fileName}</Text>\n            <Text>State: {item.state}</Text>\n            <Text>Priority: {item.priority}</Text>\n            {item.progress && (\n              <Text>Progress: {item.progress.percentage}%</Text>\n            )}\n            \n            <View style={styles.itemActions}>\n              {item.state === 'uploading' && (\n                <Button title=\"Pause\" onPress={() => item.pause()} />\n              )}\n              {item.state === 'paused' && (\n                <Button title=\"Resume\" onPress={() => item.resume()} />\n              )}\n              {item.state !== 'completed' && (\n                <Button \n                  title=\"Cancel\" \n                  onPress={() => item.cancel()} \n                  color=\"red\"\n                />\n              )}\n            </View>\n          </View>\n        )}\n      />\n    </View>\n  );\n}\n"})}),"\n",(0,l.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Concurrent Limit"})," - Set to 2-3 for optimal performance"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Priority"})," - Use priorities for user-initiated uploads"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Persistence"})," - Resume pending uploads on app start"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Cleanup"})," - Remove completed uploads periodically"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"User Control"})," - Allow users to pause/resume/cancel"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Status Updates"})," - Show queue status to users"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.a,{href:"/react-native-video/docs/v7/extensions/uploading/basic-upload",children:"Basic Upload"})," - Simple file uploads"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.a,{href:"/react-native-video/docs/v7/extensions/uploading/network-tracking",children:"Network Tracking"})," - Network-aware uploads"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.a,{href:"/react-native-video/docs/v7/extensions/uploading/configuration",children:"Configuration"})," - Upload configuration"]}),"\n"]})]})}function p(e={}){let{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(u,{...e})}):u(e)}},56151:function(e,n,a){a.d(n,{R:()=>i,x:()=>o});var t=a(96540);let l={},s=t.createContext(l);function i(e){let n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:i(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);